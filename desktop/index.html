<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OffGrid LLM</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
    <!-- Marked.js for Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Terminal Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Light Theme (VS Code Default Light) */
            --bg-primary: #ffffff;
            --bg-secondary: #f3f3f3; /* Sidebar/Activity Bar */
            --bg-tertiary: #e5e5e5; /* Borders/Inputs */
            --text-primary: #333333;
            --text-secondary: #616161;
            --accent-primary: #00bcd4; /* Cyan */
            --accent-hover: #00acc1;
            --border-color: #e5e5e5;
            --card-bg: #ffffff;
            --card-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            --input-bg: #ffffff;
            --input-border: #cecece;
            --code-bg: #f3f3f3;
            --code-inline-bg: rgba(27, 31, 35, 0.05);
            --header-bg: #f3f3f3;
            --nav-bg: #f3f3f3;
            --message-user-bg: transparent;
            --message-assistant-bg: #f8f8f8;
            --scrollbar-track: #f3f3f3;
            --scrollbar-thumb: #c1c1c1;
            --scrollbar-thumb-hover: #a8a8a8;
            --terminal-bg: #1e1e1e; /* Terminal always dark usually */
            --terminal-text: #d4d4d4;
            --success-color: #00bcd4;
            
            /* ANSI Colors - Modified for White/Cyan/Gray theme */
            --ansi-black: #555555;
            --ansi-cyan: #00bcd4; /* Cyan */
            --ansi-green: #00bcd4; /* Map Green to Cyan */
            --ansi-yellow: #e5e5e5; /* Map Yellow to White */
            --ansi-red: #e5e5e5; /* Map Red to White */
            --ansi-blue: #00bcd4; /* Map Blue to Cyan */
            --ansi-magenta: #00bcd4; /* Map Magenta to Cyan */
            --ansi-white: #ffffff;
            --ansi-gray: #9d9d9d; /* Visible Gray */
        }

        [data-theme="dark"] {
            /* Dark Theme (VS Code Default Dark) */
            --bg-primary: #1e1e1e;
            --bg-secondary: #252526; /* Sidebar */
            --bg-tertiary: #333333; /* Activity Bar/Inputs */
            --text-primary: #cccccc;
            --text-secondary: #969696;
            --accent-primary: #00bcd4; /* Cyan */
            --accent-hover: #00acc1;
            --border-color: #454545;
            --card-bg: #252526;
            --card-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            --input-bg: #3c3c3c;
            --input-border: #3c3c3c;
            --code-bg: #1e1e1e;
            --code-inline-bg: rgba(110, 118, 129, 0.4);
            --header-bg: #1e1e1e;
            --nav-bg: #252526;
            --message-user-bg: transparent;
            --message-assistant-bg: #252526;
            --scrollbar-track: #1e1e1e;
            --scrollbar-thumb: #424242;
            --scrollbar-thumb-hover: #4f4f4f;
            --terminal-bg: #1e1e1e;
            --terminal-text: #d4d4d4;
            --success-color: #00bcd4;
        }

        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif;
        }
        
        body { 
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: background 0.3s ease, color 0.3s ease;
        }

        /* Utility Classes for Theme */
        .app-header {
            background: var(--header-bg);
            border-bottom: 1px solid var(--border-color);
            padding: 16px 24px;
            flex-shrink: 0;
        }
        
        .app-nav {
            background: var(--nav-bg);
            border-bottom: 1px solid var(--border-color);
            padding: 0 24px;
            flex-shrink: 0;
        }

        .text-accent { color: var(--accent-primary); }
        .text-secondary { color: var(--text-secondary); }
        .bg-primary { background: var(--bg-primary); }
        .bg-secondary { background: var(--bg-secondary); }
        .border-theme { border-color: var(--border-color); }
        
        .input-theme {
            background: var(--input-bg);
            border: 1px solid var(--input-border);
            color: var(--text-primary);
        }
        
        .input-theme:focus {
            border-color: var(--accent-primary);
            outline: none;
        }

        .card { 
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 24px;
            box-shadow: var(--card-shadow);
            transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.3s ease;
        }
        
        .card:hover {
            border-color: var(--accent-primary);
        }
        
        .btn {
            padding: 6px 14px;
            border-radius: 2px;
            cursor: pointer;
            transition: background 0.2s ease;
            border: none;
            font-size: 13px;
            font-weight: 400;
            outline: none;
            color: white;
        }
        
        .btn:hover:not(:disabled) {
            opacity: 0.9;
        }
        
        .btn-sm { 
            padding: 4px 10px; 
            font-size: 12px; 
        }
        
        .btn:disabled { 
            opacity: 0.5; 
            cursor: not-allowed;
        }
        
        .btn-primary { 
            background: var(--accent-primary);
            color: white; 
        }
        
        .btn-primary:hover:not(:disabled) { 
            background: var(--accent-hover);
        }
        
        .btn-secondary { 
            background: var(--bg-tertiary);
            color: var(--text-primary); 
            border: 1px solid var(--border-color);
        }
        
        .btn-secondary:hover:not(:disabled) { 
            background: var(--bg-secondary);
        }
        
        .btn-danger { 
            background: #f14c4c;
            color: white; 
        }
        
        .btn-danger:hover:not(:disabled) { 
            background: #d63b3b;
        }
        
        .btn-info { 
            background: var(--accent-primary);
            color: white; 
        }
        
        .btn-info:hover:not(:disabled) { 
            background: var(--accent-hover);
        }
        
        .tab { 
            padding: 10px 16px; 
            cursor: pointer; 
            border-bottom: 1px solid transparent; 
            transition: all 0.2s ease;
            font-weight: 400;
            color: var(--text-secondary);
        }
        
        .tab:hover { 
            color: var(--text-primary);
        }
        
        .tab.active { 
            border-bottom-color: var(--accent-primary);
            color: var(--text-primary);
        }
        
        .message { 
            padding: 20px 0;
            margin-bottom: 0;
            word-wrap: break-word;
            border-bottom: 1px solid var(--border-color);
        }
        
        .message:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        
        .message-wrapper {
            max-width: 56rem;
            margin: 0 auto;
        }
        
        .message-user { 
            background: var(--message-user-bg);
        }
        
        .message-user .message-wrapper {
            display: flex;
            gap: 1rem;
            align-items: flex-start;
        }
        
        .message-assistant { 
            background: var(--message-assistant-bg);
        }
        
        .message-assistant .message-wrapper {
            display: flex;
            gap: 1rem;
            align-items: flex-start;
        }
        
        .message-avatar {
            width: 24px;
            height: 24px;
            border-radius: 2px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 12px;
        }
        
        .message-user .message-avatar {
            background: var(--accent-primary);
            color: white;
        }
        
        .message-assistant .message-avatar {
            background: #4ec9b0;
            color: white;
        }
        
        .message-body {
            flex: 1;
            min-width: 0;
        }
        
        .message-actions { 
            display: flex; 
            gap: 8px; 
            margin-top: 12px; 
        }
        
        /* Modal Overlay Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            animation: fadeIn 0.2s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .modal-dialog {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .modal-dialog.warning {
            border-top: 4px solid #cca700;
        }
        
        .modal-dialog.error {
            border-top: 4px solid #f14c4c;
        }
        
        .modal-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .modal-icon {
            font-size: 24px;
            line-height: 1;
        }
        
        .modal-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .modal-body {
            margin-bottom: 24px;
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }
        
        .terminal-card {
            background: var(--terminal-bg) !important;
            border: 1px solid var(--border-color) !important;
            box-shadow: none !important;
        }
        
        .terminal-card:hover {
            border-color: var(--border-color) !important;
            box-shadow: none !important;
        }
        
        .terminal { 
            background: var(--terminal-bg);
            border: 1px solid var(--border-color);
            border-radius: 0;
            padding: 16px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 14px;
            overflow-y: auto;
            color: var(--terminal-text);
        }

        
        .terminal-output { 
            overflow-y: auto; 
            overflow-x: hidden;
            padding: 32px;
            line-height: 1.6;
            font-size: 14px;
            background: #1e1e1e;
            word-wrap: break-word;
            flex: 1;
            min-height: 0;
            font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
        }
        
        .terminal-line { 
            color: #e0e0e0; 
            margin-bottom: 2px; 
            white-space: pre-wrap; 
            word-wrap: break-word; 
            word-break: break-word; 
            overflow-wrap: break-word;
            font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
            line-height: 1.6;
            padding-left: 16px; /* Indent output for better hierarchy */
        }
        
        /* ANSI color classes - optimized for readability on dark background */
        .ansi-black { color: var(--ansi-black); }
        .ansi-cyan { color: var(--ansi-cyan); font-weight: 500; }
        .ansi-green { color: var(--ansi-green); font-weight: 500; }
        .ansi-yellow { color: var(--ansi-yellow); font-weight: 500; }
        .ansi-red { color: var(--ansi-red); font-weight: 500; }
        .ansi-blue { color: var(--ansi-blue); font-weight: 500; }
        .ansi-magenta { color: var(--ansi-magenta); font-weight: 500; }
        .ansi-purple { color: var(--ansi-magenta); font-weight: 500; }
        .ansi-gray { color: var(--ansi-gray); }
        .ansi-white { color: var(--ansi-white); }
        .ansi-bold { font-weight: 700; }
        .ansi-dim { color: var(--ansi-gray); font-weight: 400; }
        .ansi-normal { font-weight: 400; opacity: 1; }
        
        .terminal-error { 
            color: var(--ansi-white); 
            font-weight: 700; 
        }
        
        .terminal-success { 
            color: var(--ansi-cyan); 
            font-weight: 600; 
        }
        
        .terminal-prompt { 
            color: var(--ansi-cyan); 
            font-weight: 700;
            margin-top: 24px;
            display: block;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 24px;
            padding-left: 0; /* Reset indent for prompt */
        }
        
        .terminal-input-line { 
            display: flex; 
            align-items: center; 
            gap: 12px; 
            padding: 16px;
            border-top: 1px solid #30363d;
            background: #0f1419;
            min-height: 60px;
        }
        
        .terminal-input { 
            background: transparent; 
            border: none; 
            color: #06b6d4; 
            flex: 1; 
            outline: none; 
            font-family: inherit; 
            font-size: 18px; 
        }
        
        .terminal-running { 
            opacity: 0.6; 
            pointer-events: none; 
        }
        
        .model-item { 
            padding: 16px; 
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            margin-bottom: 10px;
            transition: all 0.2s ease;
            box-shadow: var(--card-shadow);
        }
        
        .model-item:hover { 
            background: var(--bg-secondary);
            border-color: var(--accent-primary);
            box-shadow: 0 2px 8px rgba(0, 188, 212, 0.15);
        }
        
        .badge { 
            display: inline-block; 
            padding: 4px 12px; 
            border-radius: 6px; 
            font-size: 11px; 
            font-weight: 700;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .badge-success { 
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white; 
        }
        
        .badge-warning { 
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white; 
        }
        
        .badge-error { 
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white; 
        }
        
        .badge-info { 
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: white; 
        }
        
        .hidden { 
            display: none; 
        }
        
        input:focus, select:focus, textarea:focus { 
            outline: none; 
            border-color: #06b6d4;
            box-shadow: 0 0 0 3px rgba(6, 182, 212, 0.1);
        }
        
        .chat-container { 
            display: flex; 
            flex-direction: column; 
            height: calc(100vh - 220px);
            min-height: 600px;
        }
        
        .chat-messages { 
            flex: 1; 
            overflow-y: auto; 
            padding: 16px; 
        }
        
        .chat-input-area { 
            padding: 16px; 
            border-top: 1px solid rgba(51, 65, 85, 0.8);
            background: rgba(15, 23, 42, 0.5);
        }
        
        .scrollable { 
            overflow-y: auto; 
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            display: flex;
            flex-direction: column;
        }
        
        .scrollable::-webkit-scrollbar { 
            width: 10px; 
        }
        
        .scrollable::-webkit-scrollbar-track { 
            background: rgba(30, 41, 59, 0.5);
            border-radius: 5px;
        }
        
        .scrollable::-webkit-scrollbar-thumb { 
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
            border-radius: 5px; 
        }
        
        .scrollable::-webkit-scrollbar-thumb:hover { 
            background: linear-gradient(135deg, #475569 0%, #334155 100%);
        }
        
        .settings-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); 
            gap: 16px; 
        }
        
        .stat-card { 
            text-align: center; 
            padding: 20px;
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.8) 0%, rgba(51, 65, 85, 0.6) 100%);
            border-radius: 10px;
            transition: box-shadow 0.2s ease;
        }
        
        .stat-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .stat-value { 
            font-size: 32px; 
            font-weight: 700; 
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .stat-label { 
            font-size: 13px; 
            color: #94a3b8; 
            margin-top: 6px;
            font-weight: 500;
        }
        
        header {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.95) 0%, rgba(30, 41, 59, 0.95) 100%);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }
        
        nav {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.9) 0%, rgba(30, 41, 59, 0.9) 100%);
            backdrop-filter: blur(10px);
        }
        
        /* Code block styling */
        .message-content pre {
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 16px;
            margin: 12px 0;
            overflow-x: auto;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .message-content code {
            font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .message-content pre code {
            display: block;
            padding: 0;
            background: transparent;
            border: none;
        }
        
        .message-content :not(pre) > code {
            background: rgba(110, 118, 129, 0.4);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 13px;
            color: #e2e8f0;
        }
        
        /* Prose styling for markdown content */
        .message-content.prose {
            max-width: none;
        }
        
        .message-content.prose p {
            margin: 8px 0;
            line-height: 1.7;
        }
        
        .message-content.prose ul, 
        .message-content.prose ol {
            margin: 8px 0;
            padding-left: 24px;
        }
        
        .message-content.prose li {
            margin: 4px 0;
        }
        
        .message-content.prose h1,
        .message-content.prose h2,
        .message-content.prose h3,
        .message-content.prose h4 {
            margin: 16px 0 8px 0;
            font-weight: 600;
            color: #06b6d4;
        }
        
        .message-content.prose h1 { font-size: 1.5em; }
        .message-content.prose h2 { font-size: 1.3em; }
        .message-content.prose h3 { font-size: 1.1em; }
        
        .message-content.prose blockquote {
            border-left: 4px solid #06b6d4;
            padding-left: 16px;
            margin: 12px 0;
            color: #94a3b8;
            font-style: italic;
        }
        
        .message-content.prose a {
            color: #06b6d4;
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }
        
        .message-content.prose a:hover {
            border-bottom-color: #06b6d4;
        }
        
        .message-content.prose table {
            border-collapse: collapse;
            width: 100%;
            margin: 12px 0;
        }
        
        .message-content.prose th,
        .message-content.prose td {
            border: 1px solid #334155;
            padding: 8px 12px;
            text-align: left;
        }
        
        .message-content.prose th {
            background: rgba(6, 182, 212, 0.1);
            font-weight: 600;
            color: #06b6d4;
        }

        /* Theme toggle button */
        .theme-toggle {
            position: fixed;
            top: 16px;
            right: 16px;
            background: rgba(255, 255, 255, 0.8);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            transition: background 0.3s ease;
            z-index: 10000;
        }
        
        .theme-toggle:hover {
            background: rgba(255, 255, 255, 1);
        }
        
        .theme-toggle svg {
            width: 20px;
            height: 20px;
            stroke: #333;
        }
        
        [data-theme="dark"] .theme-toggle svg {
            stroke: #ccc;
        }

        .border-accent-hover:hover {
            border-color: var(--accent-primary) !important;
        }
        
        .app-nav {
            background: var(--nav-bg);
            border-bottom: 1px solid var(--border-color);
            padding: 0 24px;
            flex-shrink: 0;
        }

    </style>
</head>
<body class="antialiased">
    <button id="theme-toggle" class="theme-toggle" title="Toggle Theme">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="5"></circle>
            <line x1="12" y1="1" x2="12" y2="3"></line>
            <line x1="12" y1="21" x2="12" y2="23"></line>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
            <line x1="1" y1="12" x2="3" y2="12"></line>
            <line x1="21" y1="12" x2="23" y2="12"></line>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
        </svg>
    </button>

    <header class="app-header">
        <div class="flex items-center justify-between">
            <h1 class="text-xl font-bold text-accent">OffGrid LLM</h1>
            <div class="flex items-center gap-3">
                <span id="statusBadge" class="badge badge-success">Ready</span>
                <span class="text-xs text-secondary">v0.1.6</span>
            </div>
        </div>
    </header>

    <nav class="app-nav">
        <div class="flex gap-1">
            <button onclick="switchTab('chat')" id="tab-chat" class="tab active">Chat</button>
            <button onclick="switchTab('sessions')" id="tab-sessions" class="tab">Sessions</button>
            <button onclick="switchTab('models')" id="tab-models" class="tab">Models</button>
            <button onclick="switchTab('terminal')" id="tab-terminal" class="tab">Terminal</button>
        </div>
    </nav>

    <main class="flex-1 flex flex-col overflow-hidden">
        <!-- Chat Tab -->
        <div id="content-chat" class="h-full flex flex-col overflow-hidden">
            <div class="card flex-shrink-0">
                <div class="flex items-center gap-3 flex-wrap mb-3">
                    <select id="chatModel" class="flex-1 min-w-[200px] input-theme rounded px-3 py-2 text-sm" onchange="console.log('[INLINE] Dropdown changed to:', this.value); handleModelChange();">
                        <option value="">Loading...</option>
                    </select>
                    <select id="systemPrompt" onchange="applySystemPrompt()" class="flex-1 min-w-[200px] input-theme rounded px-3 py-2 text-sm">
                        <option value="">No System Prompt</option>
                        <option value="research">Research Assistant</option>
                        <option value="tutor">Study Tutor</option>
                        <option value="coder">Code Reviewer</option>
                        <option value="writer">Academic Writer</option>
                        <option value="custom">Custom Prompt...</option>
                    </select>
                </div>
                <div class="flex items-center gap-3 flex-wrap">
                    <div class="flex gap-2 flex-wrap">
                        <label class="flex items-center gap-2 text-xs">
                            <input type="checkbox" id="streamToggle" checked class="rounded">
                            <span>Stream</span>
                        </label>
                        <label class="flex items-center gap-2 text-xs">
                            <span>Temp:</span>
                            <input type="number" id="temperature" value="0.7" step="0.1" min="0" max="2" 
                                   class="w-16 input-theme rounded px-2 py-1 text-xs">
                        </label>
                        <label class="flex items-center gap-2 text-xs">
                            <span>Max:</span>
                            <input type="number" id="maxTokens" value="1000" step="100" min="100" max="4000" 
                                   class="w-20 input-theme rounded px-2 py-1 text-xs">
                        </label>
                    </div>
                    <div class="flex gap-2 ml-auto">
                        <button onclick="saveCurrentSession()" class="btn btn-info btn-sm">Save Session</button>
                        <button onclick="showExportOptions()" class="btn btn-info btn-sm">Export</button>
                        <button onclick="clearChat()" class="btn btn-secondary btn-sm">Clear</button>
                    </div>
                </div>
            </div>

            <div class="flex-1 flex flex-col overflow-hidden bg-primary">
                <div id="chatMessages" class="flex-1 scrollable px-4 py-4">
                    <div class="text-center text-secondary py-32">
                        <p class="text-xl font-medium">Start a conversation</p>
                        <p class="text-sm mt-2">Select a model and type your message below</p>
                    </div>
                </div>
                <div class="flex-shrink-0 bg-primary border-t border-theme">
                    <div class="max-w-3xl mx-auto py-4 px-4">
                        <div class="relative input-theme rounded-xl focus-within:border-theme transition-colors shadow-lg">
                            <textarea id="chatInput" placeholder="Message OffGrid LLM..." 
                               onkeydown="handleChatKeydown(event)"
                               oninput="autoResizeTextarea(this)"
                               rows="1"
                               style="max-height: 200px; min-height: 52px;"
                               class="w-full bg-transparent border-none px-4 py-3 pr-12 text-sm text-primary resize-none focus:outline-none"></textarea>
                            <button onclick="sendChat()" id="sendBtn" 
                                    class="absolute right-2 bottom-2 w-8 h-8 rounded-lg btn-primary disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center justify-center">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" class="text-white">
                                    <path d="M.5 1.163A1 1 0 0 1 1.97.28l12.868 6.837a1 1 0 0 1 0 1.766L1.969 15.72A1 1 0 0 1 .5 14.836V10.33a1 1 0 0 1 .816-.983L8.5 8 1.316 6.653A1 1 0 0 1 .5 5.67V1.163Z" fill="currentColor"/>
                                </svg>
                            </button>
                            <button onclick="stopGeneration()" id="stopBtn" 
                                    class="absolute right-2 bottom-2 w-8 h-8 rounded-lg bg-red-600 hover:bg-red-700 transition-colors items-center justify-center hidden">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" class="text-white">
                                    <rect x="3" y="3" width="10" height="10" rx="2" fill="currentColor"/>
                                </svg>
                            </button>
                        </div>
                        <div class="flex items-center justify-between mt-2 text-xs text-secondary px-1">
                            <div class="flex gap-3">
                                <span id="tokenCount">0 tokens</span>
                                <span>â€¢</span>
                                <span id="messageCount">0 messages</span>
                            </div>
                            <span id="statusBadge" class="text-xs font-medium">Ready</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Sessions Tab -->
        <div id="content-sessions" class="hidden h-full overflow-auto px-6 py-4">
            <div class="card max-w-5xl mx-auto">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="text-lg font-semibold">Saved Sessions</h3>
                    <button onclick="createNewSession()" class="btn btn-primary btn-sm">New Session</button>
                </div>
                <div class="mb-4">
                    <input type="text" id="sessionSearch" placeholder="Search sessions..." 
                           onkeyup="filterSessions()"
                           class="w-full input-theme rounded px-3 py-2 text-sm" />
                </div>
                <div id="sessionsList" class="space-y-2">
                    <p class="text-sm text-secondary text-center py-8">No saved sessions yet. Start chatting and click 'Save' to preserve your conversations.</p>
                </div>
            </div>
        </div>

        <!-- Models Tab -->
        <div id="content-models" class="hidden h-full overflow-auto px-6 py-4">
            <div class="max-w-5xl mx-auto space-y-4">
            
            <!-- USB Import/Export Section -->
            <div class="card">
                <h3 class="text-lg font-semibold mb-4">USB Model Transfer</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <h4 class="text-sm font-medium mb-2 text-accent">Import from USB</h4>
                        <p class="text-xs text-secondary mb-3">Load models from a USB drive prepared with OffGrid bundles</p>
                        <div class="flex gap-2">
                            <input type="text" id="usbImportPath" placeholder="/media/usb or /mnt/usb" 
                                   value="/media/usb"
                                   class="flex-1 input-theme rounded px-3 py-2 text-sm" />
                            <button onclick="importFromUSB()" class="btn btn-primary">Import</button>
                        </div>
                        <div id="usbImportStatus" class="mt-2 text-xs"></div>
                    </div>
                    <div>
                        <h4 class="text-sm font-medium mb-2 text-accent">Export to USB</h4>
                        <p class="text-xs text-secondary mb-3">Create a portable bundle of your models on USB</p>
                        <div class="flex gap-2">
                            <input type="text" id="usbExportPath" placeholder="/media/usb or /mnt/usb" 
                                   value="/media/usb"
                                   class="flex-1 input-theme rounded px-3 py-2 text-sm" />
                            <button onclick="exportToUSB()" class="btn btn-primary">Export</button>
                        </div>
                        <div id="usbExportStatus" class="mt-2 text-xs"></div>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h3 class="text-lg font-semibold mb-4">Search & Download Models</h3>
                <div class="flex gap-2 mb-4">
                    <input type="text" id="searchQuery" placeholder="Search models (e.g., llama, phi, mistral)..." 
                           class="flex-1 input-theme rounded px-3 py-2 text-sm" />
                    <button onclick="searchModels()" class="btn btn-primary">Search</button>
                </div>
                <div id="searchResults" class="space-y-2"></div>
            </div>

            <div class="card">
                <h3 class="text-lg font-semibold mb-4">Installed Models</h3>
                <div id="installedModels" class="space-y-2">
                    <p class="text-sm text-secondary">Loading...</p>
                </div>
            </div>
            </div>
        </div>

        <!-- Terminal Tab -->
        <div id="content-terminal" class="hidden h-full flex flex-col px-6 py-4">
            <div class="max-w-5xl mx-auto flex-1 flex flex-col gap-4 w-full min-h-0">
            <div class="flex-shrink-0">
                <div class="flex items-center gap-3 px-4 py-3 bg-secondary rounded-lg border border-theme">
                    <span class="text-xs font-bold text-secondary uppercase tracking-wider">Quick Commands:</span>
                    <div class="flex gap-2 flex-1">
                        <button onclick="runQuickCommand('offgrid list')" 
                                class="px-4 py-1.5 bg-[#1e1e1e] hover:bg-[#2d2d2d] text-[#00bcd4] hover:text-[#4FC1FF] rounded border border-[#333] font-mono text-xs transition-all duration-150 shadow-sm">
                            list
                        </button>
                        <button onclick="runQuickCommand('offgrid recommend')" 
                                class="px-4 py-1.5 bg-[#1e1e1e] hover:bg-[#2d2d2d] text-[#00bcd4] hover:text-[#4FC1FF] rounded border border-[#333] font-mono text-xs transition-all duration-150 shadow-sm">
                            recommend
                        </button>
                        <button onclick="runQuickCommand('offgrid catalog')" 
                                class="px-4 py-1.5 bg-[#1e1e1e] hover:bg-[#2d2d2d] text-[#00bcd4] hover:text-[#4FC1FF] rounded border border-[#333] font-mono text-xs transition-all duration-150 shadow-sm">
                            catalog
                        </button>
                        <button onclick="runQuickCommand('offgrid help')" 
                                class="px-4 py-1.5 bg-[#1e1e1e] hover:bg-[#2d2d2d] text-[#00bcd4] hover:text-[#4FC1FF] rounded border border-[#333] font-mono text-xs transition-all duration-150 shadow-sm">
                            help
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="card terminal-card flex-1 flex flex-col min-h-0">
                <div class="flex items-center justify-between mb-3 flex-shrink-0">
                    <h3 class="text-lg font-semibold">Terminal</h3>
                    <div class="flex gap-2">
                        <button onclick="killCommand()" id="killBtn" class="btn btn-danger btn-sm hidden">Kill</button>
                        <button onclick="clearTerminal()" class="btn btn-secondary btn-sm">Clear</button>
                    </div>
                </div>
                <div class="terminal-output scrollable flex-1 overflow-y-auto" id="terminalOutput">
                    <div class="terminal-line terminal-success">OffGrid Terminal v0.1.6</div>
                    <div class="terminal-line">Connected to real offgrid binary</div>
                    <div class="terminal-line">Type 'help' for available commands or 'offgrid --help' for all options</div>
                </div>
                <div class="terminal-input-line flex-shrink-0" id="terminalInputLine">
                    <span class="terminal-prompt">$</span>
                    <input type="text" id="terminalInput" placeholder="Enter command..." 
                           onkeydown="handleTerminalKeydown(event)"
                           class="terminal-input" autocomplete="off" />
                </div>
            </div>
            </div>
        </div>
    </main>

    <script>
        let currentModel = '';
        let messages = [];
        let isGenerating = false;
        let abortController = null;
        let commandHistory = [];
        let historyIndex = -1;
        let terminalRunning = false;
        let currentTerminalAbort = null;
        let terminalChatMode = false;
        let terminalChatModel = '';
        let terminalChatHistory = [];
        
        // Session management
        let sessions = JSON.parse(localStorage.getItem('offgrid_sessions') || '[]');
        let currentSessionId = null;
        let currentSystemPrompt = '';
        
        // System prompts for different use cases
        const systemPrompts = {
            research: "You are a knowledgeable research assistant. Help users understand complex topics, find relevant information, and think critically about academic questions. Provide detailed, well-sourced responses with references when possible.",
            tutor: "You are a patient and encouraging tutor. Break down complex concepts into simple explanations, use analogies and examples, ask questions to check understanding, and adapt your teaching style to the student's level.",
            coder: "You are an expert code reviewer and programming mentor. Provide detailed code reviews, suggest improvements for readability and performance, explain best practices, and help debug issues. Format all code with proper syntax highlighting.",
            writer: "You are an academic writing assistant. Help with essay structure, grammar, clarity, citation formats, and academic tone. Provide constructive feedback and suggestions for improvement.",
        };
        
        // Request throttling to prevent system overload
        let lastRequestTime = 0;
        let requestCooldown = 300; // Minimum 300ms between requests
        let pendingRequest = false;

        // Save messages to localStorage
        function saveMessages() {
            try {
                localStorage.setItem('offgrid_messages', JSON.stringify(messages));
                localStorage.setItem('offgrid_current_model', currentModel);
            } catch (e) {
                console.error('Failed to save messages:', e);
            }
        }

        // Load messages from localStorage
        function loadMessages() {
            try {
                const saved = localStorage.getItem('offgrid_messages');
                const savedModel = localStorage.getItem('offgrid_current_model');
                if (saved) {
                    messages = JSON.parse(saved);
                    if (savedModel) {
                        currentModel = savedModel;
                    }
                    // Restore messages to UI
                    const chatMessages = document.getElementById('chatMessages');
                    chatMessages.innerHTML = '';
                    messages.forEach(msg => {
                        if (msg.role === 'user' || msg.role === 'assistant') {
                            addChatMessage(msg.role, msg.content);
                        }
                    });
                    updateChatStats();
                }
            } catch (e) {
                console.error('Failed to load messages:', e);
            }
        }

        // Tab switching
        function switchTab(tab) {
            document.querySelectorAll('[id^="content-"]').forEach(el => el.classList.add('hidden'));
            document.querySelectorAll('.tab').forEach(el => el.classList.remove('active'));
            document.getElementById('content-' + tab).classList.remove('hidden');
            document.getElementById('tab-' + tab).classList.add('active');
            
            // Save current tab to localStorage
            localStorage.setItem('offgrid_active_tab', tab);
            
            if (tab === 'models') {
                loadInstalledModels();
                // Clear search input
                document.getElementById('searchQuery').value = '';
                document.getElementById('searchResults').innerHTML = '';
            }
            if (tab === 'sessions') {
                renderSessions();
            }
            if (tab === 'chat') {
                loadChatModels();
                updateChatStats();
            }
        }

        // Chat keyboard handler
        function handleChatKeydown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendChat();
            }
        }
        
        // Auto-resize textarea
        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 200) + 'px';
        }

        // Terminal keyboard handler
        function handleTerminalKeydown(event) {
            const input = event.target;
            
            if (event.key === 'Enter') {
                event.preventDefault();
                runCommand();
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    input.value = commandHistory[historyIndex] || '';
                }
            } else if (event.key === 'ArrowDown') {
                event.preventDefault();
                if (historyIndex > 0) {
                    historyIndex--;
                    input.value = commandHistory[historyIndex] || '';
                } else if (historyIndex === 0) {
                    historyIndex = -1;
                    input.value = '';
                }
            } else if (event.key === 'Tab') {
                event.preventDefault();
                autocompleteCommand(input);
            }
        }

        function autocompleteCommand(input) {
            const val = input.value;
            const commands = [
                'offgrid list',
                'offgrid recommend',
                'offgrid catalog',
                'offgrid download ',
                'offgrid download-hf ',
                'offgrid remove ',
                'offgrid search ',
                'offgrid run ',
                'offgrid serve',
                'offgrid --help',
                'offgrid --version',
                'help',
                'clear',
                'history'
            ];
            const match = commands.find(cmd => cmd.startsWith(val));
            if (match) {
                input.value = match;
            }
        }

        function updateChatStats() {
            document.getElementById('messageCount').textContent = `${messages.length} messages`;
            const totalTokens = messages.reduce((sum, m) => sum + (m.content?.length || 0), 0);
            document.getElementById('tokenCount').textContent = `~${Math.ceil(totalTokens / 4)} tokens`;
        }

        // Load models for chat
        async function loadChatModels() {
            try {
                // Force refresh models from filesystem
                try {
                    await fetch('/models/refresh', { method: 'POST' });
                } catch (e) {
                    console.warn('Failed to refresh models, using cached list:', e);
                }
                
                const resp = await fetch('/models');
                const data = await resp.json();
                const models = data.data || [];
                const select = document.getElementById('chatModel');
                
                // Remember the current selection before clearing
                const previousSelection = select.value || currentModel;
                
                select.innerHTML = '';
                
                if (models.length === 0) {
                    select.innerHTML = '<option value="">No models available</option>';
                    return;
                }
                
                // Sort models alphabetically by ID
                models.sort((a, b) => a.id.localeCompare(b.id));
                console.log('[LOAD MODELS] Sorted models:', models.map(m => m.id));
                
                models.forEach(m => {
                    const opt = document.createElement('option');
                    opt.value = m.id;
                    // Format display name: replace underscores and hyphens with spaces for readability
                    const displayName = m.id.replace(/_/g, ' ').replace(/-/g, ' ');
                    opt.textContent = displayName;
                    opt.title = m.id; // Show original name on hover
                    select.appendChild(opt);
                });
                
                // Restore previous selection, or auto-select first model if none selected
                if (previousSelection && models.some(m => m.id === previousSelection)) {
                    // Restore the previous selection
                    currentModel = previousSelection;
                    select.value = previousSelection;
                    console.log('[LOAD MODELS] Restored previous selection:', previousSelection);
                } else if (!currentModel && models.length > 0) {
                    // First time - select first model
                    currentModel = models[0].id;
                    select.value = currentModel;
                    console.log('[LOAD MODELS] Auto-selected first model:', currentModel);
                }

                // Add change handler after models are loaded
                select.onchange = null; // Clear any existing handler
                select.onchange = function(e) {
                    console.log('[DROPDOWN] Change event fired! Value:', e.target.value);
                    handleModelChange();
                };
                console.log('[LOAD MODELS] Event listener attached to dropdown via onchange');
            } catch (e) {
                console.error('Failed to load models:', e);
                document.getElementById('chatModel').innerHTML = '<option value="">Error loading models</option>';
            }
        }

        // Wait for model to be fully loaded and ready
        async function waitForModelReady(modelName) {
            console.log('[HEALTH CHECK] Waiting for model to be ready:', modelName);
            const maxAttempts = 60; // 60 seconds max wait
            const pollInterval = 1000; // Check every second
            
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                    console.log(`[HEALTH CHECK] Attempt ${attempt}/${maxAttempts}`);
                    
                    // Send a minimal test completion request to verify model is loaded
                    const testResponse = await fetch('/v1/chat/completions', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: modelName,
                            messages: [{ role: 'user', content: 'test' }],
                            stream: false,
                            max_tokens: 1,
                            temperature: 0.1
                        }),
                        signal: AbortSignal.timeout(5000) // 5 second timeout per attempt
                    });
                    
                    console.log('[HEALTH CHECK] Response status:', testResponse.status);
                    
                    // If we get 200, model is ready
                    if (testResponse.ok) {
                        console.log('[HEALTH CHECK] Model is ready!');
                        return true;
                    }
                    
                    // If we get 503 or 500, model is still loading
                    if (testResponse.status === 503 || testResponse.status === 500) {
                        const errorData = await testResponse.json().catch(() => ({}));
                        console.log('[HEALTH CHECK] Model loading:', errorData.error || 'Still initializing...');
                    }
                    
                    console.log(`[HEALTH CHECK] Not ready yet, waiting ${pollInterval}ms...`);
                    await new Promise(resolve => setTimeout(resolve, pollInterval));
                    
                } catch (error) {
                    console.log(`[HEALTH CHECK] Error on attempt ${attempt}:`, error.message);
                    // Network errors or timeouts are expected while loading
                    await new Promise(resolve => setTimeout(resolve, pollInterval));
                }
            }
            
            console.warn('[HEALTH CHECK] Timeout after 60s - model may not be ready');
            return false; // Return false if timeout
        }

        // Handle model dropdown change
        async function handleModelChange() {
            const select = document.getElementById('chatModel');
            const newModel = select.value;
            
            console.log('[MODEL CHANGE] Dropdown changed to:', newModel);
            console.log('[MODEL CHANGE] Current model:', currentModel);
            
            if (!newModel) {
                console.log('[MODEL CHANGE] No model selected, ignoring');
                return;
            }
            
            // Don't switch if already on this model
            if (currentModel === newModel) {
                console.log('[MODEL CHANGE] Already using this model');
                return;
            }
            
            const oldModel = currentModel;
            
            // If there are existing messages, ask user what to do
            console.log('[MODEL CHANGE] Current message count:', messages.length);
            if (messages.length > 0) {
                console.log('[MODEL CHANGE] Showing confirmation dialog...');
                showModal({
                    type: 'warning',
                    title: 'Clear Chat History?',
                    message: `Switching from <strong>${oldModel || 'no model'}</strong> to <strong>${newModel}</strong>.<br><br>Clear chat history? The new model won't have context from previous messages.`,
                    confirmText: 'Start Fresh',
                    cancelText: 'Keep History',
                    onConfirm: () => {
                        console.log('[MODEL CHANGE] User response: CLEAR');
                        console.log('[MODEL CHANGE] Clearing chat history');
                        clearChatSilent();
                    },
                    onCancel: () => {
                        console.log('[MODEL CHANGE] User response: KEEP');
                        console.log('[MODEL CHANGE] Keeping chat history');
                    }
                });
            } else {
                console.log('[MODEL CHANGE] No messages, skipping confirmation');
            }
            
            currentModel = newModel;
            console.log('[MODEL CHANGE] Switching from', oldModel, 'to', newModel);
            
            // Disable UI while loading model
            const chatInput = document.getElementById('chatInput');
            const sendBtn = document.getElementById('sendBtn');
            const statusBadge = document.getElementById('statusBadge');
            
            chatInput.disabled = true;
            sendBtn.disabled = true;
            statusBadge.className = 'text-xs font-medium text-yellow-400';
            
            // Show loading progress
            let loadingSeconds = 0;
            statusBadge.textContent = `Loading ${newModel}...`;
            const loadingInterval = setInterval(() => {
                loadingSeconds++;
                statusBadge.textContent = `Loading ${newModel}... ${loadingSeconds}s`;
            }, 1000);
            
            console.log('[MODEL CHANGE] Starting health check for', newModel);
            
            // Wait for model to be ready before allowing messages
            const isReady = await waitForModelReady(newModel);
            
            // Clear loading interval
            clearInterval(loadingInterval);
            
            if (isReady) {
                console.log('[MODEL CHANGE] Model ready - enabling UI');
                statusBadge.className = 'badge badge-success';
                statusBadge.textContent = `Ready (${newModel})`;
            } else {
                console.warn('[MODEL CHANGE] Model not confirmed ready - may have issues');
                statusBadge.className = 'badge badge-warning';
                statusBadge.textContent = `${newModel} (not confirmed)`;
            }
            
            // Re-enable UI
            chatInput.disabled = false;
            sendBtn.disabled = false;
            chatInput.focus();
            
            console.log('[MODEL CHANGE] Model switch complete - ready for messages');
        }

        // Modal dialog system
        function showModal({ type = 'info', title, message, confirmText = 'OK', cancelText = 'Cancel', onConfirm, onCancel }) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const iconMap = {
                warning: 'âš ï¸',
                error: 'âŒ',
                info: 'â„¹ï¸',
                success: 'âœ“'
            };
            
            overlay.innerHTML = `
                <div class="modal-dialog ${type}">
                    <div class="modal-header">
                        <span class="modal-icon">${iconMap[type] || iconMap.info}</span>
                        <h3 class="modal-title">${title}</h3>
                    </div>
                    <div class="modal-body">
                        ${message}
                    </div>
                    <div class="modal-actions">
                        ${cancelText ? `<button class="btn btn-secondary" data-action="cancel">${cancelText}</button>` : ''}
                        <button class="btn ${type === 'error' ? 'btn-danger' : 'btn-primary'}" data-action="confirm">${confirmText}</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Handle clicks
            overlay.addEventListener('click', (e) => {
                if (e.target.classList.contains('modal-overlay')) {
                    overlay.remove();
                    if (onCancel) onCancel();
                }
            });
            
            overlay.querySelector('[data-action="confirm"]')?.addEventListener('click', () => {
                overlay.remove();
                if (onConfirm) onConfirm();
            });
            
            overlay.querySelector('[data-action="cancel"]')?.addEventListener('click', () => {
                overlay.remove();
                if (onCancel) onCancel();
            });
        }

        // Clear chat
        function clearChat() {
            if (messages.length === 0) return;
            
            showModal({
                type: 'error',
                title: 'Clear All Messages?',
                message: `This will delete all <strong>${messages.length} messages</strong> in the conversation.`,
                confirmText: 'Clear Chat',
                cancelText: 'Cancel',
                onConfirm: () => {
                    messages = [];
                    const chatMessages = document.getElementById('chatMessages');
                    chatMessages.innerHTML = '';
                    updateChatStats();
                    saveMessages();
                }
            });
        }

        // Export chat with enhanced options
        function showExportOptions() {
            if (messages.length === 0) {
                showModal({
                    type: 'warning',
                    title: 'No Messages',
                    message: 'There are no messages to export yet.',
                    confirmText: 'OK',
                    cancelText: null
                });
                return;
            }
            const format = prompt('Export format:\n1. Markdown (recommended for research)\n2. Plain text\n3. JSON\n\nEnter 1, 2, or 3:', '1');
            if (!format) return;
            
            let content, mimeType, extension;
            const timestamp = new Date().toISOString().split('T')[0];
            const filename = `chat-${currentModel}-${timestamp}`;
            
            if (format === '1') {
                // Markdown format with code blocks
                content = `# Chat with ${currentModel}\n**Date:** ${new Date().toLocaleString()}\n**Messages:** ${messages.length}\n\n---\n\n`;
                messages.forEach(m => {
                    content += `## ${m.role === 'user' ? 'User' : 'Assistant'}\n\n`;
                    // Detect and format code blocks
                    const hasCode = m.content.includes('```');
                    content += hasCode ? m.content : m.content.replace(/`([^`]+)`/g, '`$1`');
                    content += '\n\n---\n\n';
                });
                mimeType = 'text/markdown';
                extension = 'md';
            } else if (format === '3') {
                // JSON format for programmatic access
                content = JSON.stringify({
                    model: currentModel,
                    timestamp: new Date().toISOString(),
                    messageCount: messages.length,
                    messages: messages
                }, null, 2);
                mimeType = 'application/json';
                extension = 'json';
            } else {
                // Plain text
                content = messages.map(m => `${m.role.toUpperCase()}: ${m.content}`).join('\n\n');
                mimeType = 'text/plain';
                extension = 'txt';
            }
            
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename}.${extension}`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // System prompt functions
        function applySystemPrompt() {
            const select = document.getElementById('systemPrompt');
            const value = select.value;
            
            if (value === 'custom') {
                const custom = prompt('Enter your custom system prompt:');
                if (custom) {
                    currentSystemPrompt = custom;
                    showModal({
                        type: 'success',
                        title: 'Success',
                        message: 'Custom prompt applied',
                        confirmText: 'OK'
                    });
                }
            } else if (value) {
                currentSystemPrompt = systemPrompts[value];
                showModal({
                    type: 'success',
                    title: 'Success',
                    message: `${select.options[select.selectedIndex].text} mode activated`,
                    confirmText: 'OK'
                });
            } else {
                currentSystemPrompt = '';
            }
        }

        // Session Management Functions
        function saveCurrentSession() {
            if (messages.length === 0) {
                showModal({
                    type: 'error',
                    title: 'Cannot Save',
                    message: 'No messages to save',
                    confirmText: 'OK'
                });
                return;
            }
            
            const title = prompt('Enter a title for this session:', `Chat ${new Date().toLocaleDateString()}`);
            if (!title) return;
            
            const session = {
                id: currentSessionId || Date.now(),
                title: title,
                model: currentModel,
                messages: [...messages],
                systemPrompt: currentSystemPrompt,
                timestamp: new Date().toISOString(),
                messageCount: messages.length
            };
            
            const existingIndex = sessions.findIndex(s => s.id === session.id);
            if (existingIndex >= 0) {
                sessions[existingIndex] = session;
            } else {
                sessions.unshift(session);
                currentSessionId = session.id;
            }
            
            localStorage.setItem('offgrid_sessions', JSON.stringify(sessions));
            showModal({
                type: 'success',
                title: 'Saved',
                message: `Session saved: "${title}"`,
                confirmText: 'OK'
            });
        }

        function renderSessions() {
            const container = document.getElementById('sessionsList');
            
            if (sessions.length === 0) {
                container.innerHTML = '<p class="text-sm text-secondary text-center py-8">No saved sessions yet. Start chatting and click \'Save\' to preserve your conversations.</p>';
                return;
            }
            
            container.innerHTML = sessions.map(session => `
                <div class="card border-accent-hover cursor-pointer" data-session-id="${session.id}">
                    <div class="flex items-start justify-between">
                        <div class="flex-1" onclick="loadSession(${session.id})">
                            <h4 class="font-semibold text-accent mb-1">${session.title}</h4>
                            <p class="text-xs text-secondary mb-2">
                                ${session.model} â€¢ ${session.messageCount} messages â€¢ ${new Date(session.timestamp).toLocaleString()}
                            </p>
                            <p class="text-xs text-secondary line-clamp-2">${session.messages[0]?.content.substring(0, 100)}...</p>
                        </div>
                        <button onclick="deleteSession(${session.id}); event.stopPropagation();" class="btn btn-danger btn-sm ml-2">Delete</button>
                    </div>
                </div>
            `).join('');
        }

        function loadSession(id) {
            const session = sessions.find(s => s.id === id);
            if (!session) return;
            
            if (messages.length > 0) {
                showModal({
                    type: 'warning',
                    title: 'Load Session?',
                    message: 'Current chat will be replaced. Continue?',
                    confirmText: 'Load Session',
                    cancelText: 'Cancel',
                    onConfirm: () => {
                        messages = [...session.messages];
                        currentModel = session.model;
                        currentSessionId = session.id;
                        currentSystemPrompt = session.systemPrompt || '';
                        
                        // Update UI
                        document.getElementById('chatModel').value = currentModel;
                        const chatMessages = document.getElementById('chatMessages');
                        chatMessages.innerHTML = '';
                        messages.forEach(m => {
                            addChatMessage(m.role, m.content);
                        });
                        
                        switchTab('chat');
                        showModal({
                            type: 'success',
                            title: 'Loaded',
                            message: `Session loaded: "${session.title}"`,
                            confirmText: 'OK'
                        });
                    }
                });
                return;
            }
            
            messages = [...session.messages];
            currentModel = session.model;
            currentSessionId = session.id;
            currentSystemPrompt = session.systemPrompt || '';
            
            // Update UI
            document.getElementById('chatModel').value = currentModel;
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.innerHTML = '';
            messages.forEach(m => {
                addChatMessage(m.role, m.content);
            });
            
            switchTab('chat');
        }

        function deleteSession(id) {
            showModal({
                type: 'error',
                title: 'Delete Session?',
                message: 'This action cannot be undone.',
                confirmText: 'Delete',
                cancelText: 'Cancel',
                onConfirm: () => {
                    sessions = sessions.filter(s => s.id !== id);
                    localStorage.setItem('offgrid_sessions', JSON.stringify(sessions));
                    
                    if (currentSessionId === id) {
                        currentSessionId = null;
                    }
                    
                    renderSessions();
                }
            });
        }

        function createNewSession() {
            if (messages.length > 0) {
                showModal({
                    type: 'warning',
                    title: 'Start New Session?',
                    message: 'Current chat will be cleared.',
                    confirmText: 'New Session',
                    cancelText: 'Cancel',
                    onConfirm: () => {
                        clearChatSilent();
                        currentSessionId = null;
                        switchTab('chat');
                        showModal({
                            type: 'success',
                            title: 'New Session',
                            message: 'New session started',
                            confirmText: 'OK'
                        });
                    }
                });
                return;
            }
            
            clearChatSilent();
            currentSessionId = null;
            switchTab('chat');
            showModal({
                type: 'success',
                title: 'New Session',
                message: 'New session started',
                confirmText: 'OK'
            });
        }

        function filterSessions() {
            const query = document.getElementById('sessionSearch').value.toLowerCase();
            const sessionCards = document.querySelectorAll('[data-session-id]');
            
            sessionCards.forEach(card => {
                const text = card.textContent.toLowerCase();
                card.style.display = text.includes(query) ? 'block' : 'none';
            });
        }

        function clearChatSilent() {
            messages = [];
            document.getElementById('chatMessages').innerHTML = `
                <div class="text-center text-secondary py-20">
                    <p>Start a conversation</p>
                    <p class="text-xs mt-2 text-secondary">Select a model and type below</p>
                </div>
            `;
            document.getElementById('chatInput').value = '';
            updateChatStats();
            saveMessages();
        }

        // Stop generation
        function stopGeneration() {
            console.log('[STOP] Stopping generation...');
            if (abortController) {
                abortController.abort();
                abortController = null;
            }
            resetChatState();
        }
        
        // Reset chat state (useful for debugging stuck states)
        function resetChatState() {
            console.log('[RESET STATE] Resetting all chat state flags');
            isGenerating = false;
            pendingRequest = false;
            const sendBtn = document.getElementById('sendBtn');
            const stopBtn = document.getElementById('stopBtn');
            const chatInput = document.getElementById('chatInput');
            const statusBadge = document.getElementById('statusBadge');
            
            if (sendBtn) sendBtn.disabled = false;
            if (stopBtn) stopBtn.classList.add('hidden');
            if (chatInput) chatInput.disabled = false;
            if (statusBadge) {
                statusBadge.className = 'badge badge-success';
                statusBadge.textContent = currentModel ? `Ready (${currentModel})` : 'Ready';
            }
            
            console.log('[RESET STATE] State reset complete');
        }
        
        // Make resetChatState globally accessible for debugging
        window.resetChatState = resetChatState;
        
        // Make handleModelChange globally accessible for manual testing
        window.handleModelChange = handleModelChange;
        window.testModelSwitch = function(modelName) {
            console.log('[TEST] Manually switching to:', modelName);
            const select = document.getElementById('chatModel');
            select.value = modelName;
            handleModelChange();
        };

        // Send chat message with streaming
        async function sendChat() {
            console.log('[SEND CHAT] Function called');
            console.log('[SEND CHAT] Flags - isGenerating:', isGenerating, 'pendingRequest:', pendingRequest);
            
            // Prevent rapid-fire requests
            if (isGenerating || pendingRequest) {
                console.warn('[SEND CHAT] Request already in progress, ignoring...');
                // If stuck, reset after 30 seconds
                const now = Date.now();
                if (lastRequestTime && (now - lastRequestTime) > 30000) {
                    console.warn('[SEND CHAT] Flags stuck for >30s, force resetting...');
                    isGenerating = false;
                    pendingRequest = false;
                } else {
                    return;
                }
            }
            
            const input = document.getElementById('chatInput');
            const msg = input.value.trim();
            console.log('[SEND CHAT] Message:', msg);
            if (!msg) return;
            
            // Throttle requests to prevent system overload
            const now = Date.now();
            const timeSinceLastRequest = now - lastRequestTime;
            if (timeSinceLastRequest < requestCooldown) {
                console.log(`[SEND CHAT] Throttling: Wait ${requestCooldown - timeSinceLastRequest}ms before next request`);
                return;
            }
            
            lastRequestTime = now;
            pendingRequest = true;
            console.log('[SEND CHAT] Set pendingRequest = true');

            const model = document.getElementById('chatModel').value;
            console.log('[SEND CHAT] Selected model from dropdown:', model);
            console.log('[SEND CHAT] Current model variable:', currentModel);
            console.log('[SEND CHAT] Dropdown element value:', document.getElementById('chatModel').value);
            
            if (!model) {
                console.log('[SEND CHAT] No model selected!');
                pendingRequest = false; // Clear flag
                const statusBadge = document.getElementById('statusBadge');
                statusBadge.className = 'badge badge-warning';
                statusBadge.textContent = 'Select Model';
                setTimeout(() => {
                    statusBadge.className = 'badge badge-success';
                    statusBadge.textContent = 'Ready';
                }, 3000);
                return;
            }

            // ALWAYS sync currentModel with dropdown before sending
            currentModel = model;
            console.log('[SEND CHAT] Synced currentModel to:', currentModel);

            const sendBtn = document.getElementById('sendBtn');
            const stopBtn = document.getElementById('stopBtn');
            const streamEnabled = document.getElementById('streamToggle').checked;
            const temperature = parseFloat(document.getElementById('temperature').value);
            const maxTokens = parseInt(document.getElementById('maxTokens').value);

            isGenerating = true;
            input.disabled = true;
            sendBtn.disabled = true;
            stopBtn.classList.remove('hidden');

            messages.push({ role: 'user', content: msg });
            addChatMessage('user', msg);
            input.value = '';
            updateChatStats();
            saveMessages();

            const statusBadge = document.getElementById('statusBadge');
            statusBadge.className = 'text-xs font-medium text-yellow-400';
            
            // Show loading indicator with elapsed time
            let loadingInterval;
            let elapsedSeconds = 0;
            statusBadge.textContent = 'Loading model...';
            loadingInterval = setInterval(() => {
                elapsedSeconds++;
                if (elapsedSeconds < 60) {
                    statusBadge.textContent = `Loading model... ${elapsedSeconds}s`;
                } else {
                    const mins = Math.floor(elapsedSeconds / 60);
                    const secs = elapsedSeconds % 60;
                    statusBadge.textContent = `Loading model... ${mins}m ${secs}s`;
                }
            }, 1000);

            abortController = new AbortController();
            const startTime = Date.now();

            // Prepare messages with system prompt if present
            let apiMessages = [...messages];
            if (currentSystemPrompt && currentSystemPrompt.trim()) {
                // Check if first message is already a system message
                if (apiMessages.length === 0 || apiMessages[0].role !== 'system') {
                    apiMessages = [{ role: 'system', content: currentSystemPrompt }, ...apiMessages];
                }
            }

            try {
                const requestPayload = {
                    model: model,
                    messages: apiMessages,
                    stream: streamEnabled,
                    temperature: temperature,
                    max_tokens: maxTokens
                };
                
                console.log('[SEND CHAT] REQUEST PAYLOAD:', JSON.stringify(requestPayload, null, 2));
                console.log('[SEND CHAT] Model being sent:', model);
                
                const response = await fetch('/v1/chat/completions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestPayload),
                    signal: abortController.signal
                });

                if (!response.ok) {
                    let errorDetails = '';
                    try {
                        const errorData = await response.json();
                        errorDetails = errorData.error?.message || JSON.stringify(errorData);
                    } catch (e) {
                        errorDetails = response.statusText;
                    }
                    throw new Error(`Server error (${response.status}): ${errorDetails}`);
                }

                if (streamEnabled) {
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let assistantMsg = '';
                    let msgDiv = null;

                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n').filter(line => line.trim() !== '');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                if (data === '[DONE]') continue;

                                try {
                                    const json = JSON.parse(data);
                                    const content = json.choices[0]?.delta?.content || '';
                                    if (content) {
                                        // First token received - model is loaded and generating
                                        if (loadingInterval) {
                                            clearInterval(loadingInterval);
                                            loadingInterval = null;
                                            statusBadge.textContent = 'Generating...';
                                        }
                                        
                                        assistantMsg += content;
                                        if (!msgDiv) {
                                            msgDiv = addChatMessage('assistant', '', startTime);
                                        }
                                        // Update streaming content with markdown rendering
                                        const contentDiv = msgDiv.querySelector('.message-content');
                                        contentDiv.innerHTML = marked.parse(assistantMsg);
                                        // Apply syntax highlighting to any new code blocks
                                        contentDiv.querySelectorAll('pre code').forEach((block) => {
                                            hljs.highlightElement(block);
                                        });
                                    }
                                } catch (e) {
                                    // Skip invalid JSON
                                }
                            }
                        }
                    }

                    if (assistantMsg) {
                        messages.push({ role: 'assistant', content: assistantMsg });
                        const elapsed = Date.now() - startTime;
                        msgDiv.querySelector('.time-badge').textContent = `${elapsed}ms`;
                        saveMessages();
                    }
                } else {
                    // Non-streaming mode - model is loaded when we get response
                    if (loadingInterval) {
                        clearInterval(loadingInterval);
                        loadingInterval = null;
                        statusBadge.textContent = 'Generating...';
                    }
                    
                    const result = await response.json();
                    const assistantMsg = result.choices[0]?.message?.content || '';
                    const elapsed = Date.now() - startTime;
                    if (assistantMsg) {
                        messages.push({ role: 'assistant', content: assistantMsg });
                        addChatMessage('assistant', assistantMsg, startTime);
                        saveMessages();
                    }
                }

                updateChatStats();
                if (loadingInterval) {
                    clearInterval(loadingInterval);
                    loadingInterval = null;
                }
                statusBadge.className = 'text-xs font-medium text-green-400';
                statusBadge.textContent = 'Ready';
            } catch (error) {
                if (loadingInterval) {
                    clearInterval(loadingInterval);
                    loadingInterval = null;
                }
                
                if (error.name === 'AbortError') {
                    addChatMessage('assistant', '[Generation stopped by user]', startTime);
                    statusBadge.className = 'text-xs font-medium text-green-400';
                    statusBadge.textContent = 'Ready';
                } else {
                    const errorMsg = error.message || 'Unknown error occurred';
                    console.error('Chat error:', error);
                    
                    // Better error messages for common issues
                    let userMessage = `âš  Error: ${errorMsg}`;
                    if (errorMsg.includes('503') || errorMsg.includes('Failed to load model')) {
                        userMessage = `âš  Model is taking longer than expected to load.\n\nThis can happen on slower systems. Please try again in a few moments.`;
                    } else if (errorMsg.includes('500')) {
                        userMessage = `âš  Server error occurred.\n\nThe model may still be loading. Please wait a moment and try again.`;
                    }
                    
                    addChatMessage('assistant', userMessage, startTime);
                    statusBadge.className = 'text-xs font-medium text-red-400';
                    statusBadge.textContent = 'Error';
                }
            } finally {
                if (loadingInterval) {
                    clearInterval(loadingInterval);
                }
                isGenerating = false;
                pendingRequest = false;
                console.log('[SEND CHAT] Cleaned up - pendingRequest = false, isGenerating = false');
                abortController = null;
                input.disabled = false;
                sendBtn.disabled = false;
                stopBtn.classList.add('hidden');
                input.focus();
            }
        }

        function addChatMessage(role, content, startTime) {
            const container = document.getElementById('chatMessages');
            if (container.querySelector('.text-center')) {
                container.innerHTML = '';
            }

            const div = document.createElement('div');
            div.className = 'message message-' + role;
            
            // Configure marked.js with syntax highlighting
            marked.setOptions({
                highlight: function(code, lang) {
                    if (lang && hljs.getLanguage(lang)) {
                        try {
                            return hljs.highlight(code, { language: lang }).value;
                        } catch (e) {
                            console.error('Highlight error:', e);
                        }
                    }
                    return hljs.highlightAuto(code).value;
                },
                breaks: true,
                gfm: true
            });

            // Parse markdown content
            const formattedContent = marked.parse(content);
            const avatar = role === 'user' ? 'U' : 'AI';
            const timestamp = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            const elapsed = startTime ? `${Date.now() - startTime}ms` : '';
            
            div.innerHTML = `
                <div class="message-wrapper">
                    <div class="message-avatar">${avatar}</div>
                    <div class="message-body">
                        <div class="flex items-center gap-2 mb-2">
                            <span class="text-xs font-medium text-secondary">${role === 'user' ? 'You' : 'Assistant'}</span>
                            <span class="text-xs text-secondary">${timestamp}</span>
                            ${elapsed ? `<span class="time-badge text-xs text-accent">${elapsed}</span>` : ''}
                        </div>
                        <div class="text-sm message-content prose prose-invert max-w-none">${formattedContent}</div>
                        ${role === 'assistant' ? `
                        <div class="message-actions mt-3">
                            <button onclick="copyMessage(this)" class="btn btn-secondary btn-sm">Copy</button>
                            <button onclick="regenerateMessage()" class="btn btn-info btn-sm">Regenerate</button>
                        </div>` : ''}
                    </div>
                </div>
            `;
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
            
            // Apply highlighting to all code blocks in this message
            div.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            return div;
        }

        function copyMessage(btn) {
            const content = btn.closest('.message').querySelector('.message-content').textContent;
            navigator.clipboard.writeText(content).then(() => {
                const original = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = original, 2000);
            });
        }

        function regenerateMessage() {
            if (messages.length < 2) return;
            messages.pop(); // Remove last assistant message
            const lastUserMsg = messages[messages.length - 1];
            messages.pop(); // Remove last user message
            document.getElementById('chatInput').value = lastUserMsg.content;
            sendChat();
        }

        // Search models
        async function searchModels() {
            const query = document.getElementById('searchQuery').value.trim();
            if (!query) {
                const results = document.getElementById('searchResults');
                results.innerHTML = '<p class="text-sm text-yellow-400">âš  Please enter a search query</p>';
                return;
            }

            const results = document.getElementById('searchResults');
            results.innerHTML = '<p class="text-sm text-secondary">ðŸ” Searching HuggingFace...</p>';

            try {
                // Add timeout to prevent hanging
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 35000); // 35 second timeout (backend has 30s)
                
                const resp = await fetch(`/v1/search?query=${encodeURIComponent(query)}`, {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (!resp.ok) {
                    throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
                }
                
                const data = await resp.json();
                
                if (data.error) {
                    throw new Error(typeof data.error === 'string' ? data.error : JSON.stringify(data.error));
                }
                
                const models = data.results || [];

                if (models.length === 0) {
                    results.innerHTML = '<p class="text-sm text-secondary">No models found. Try different keywords like "llama", "phi", "mistral".</p>';
                    return;
                }

                results.innerHTML = '';
                models.slice(0, 10).forEach(model => {
                    const div = document.createElement('div');
                    div.className = 'model-item';
                    const downloadCmd = model.download_command || `offgrid download-hf ${model.id}`;
                    const sizeInfo = model.size_gb ? `${model.size_gb} GB` : 'Size unknown';
                    const quantInfo = model.best_quant ? ` Â· ${model.best_quant}` : '';
                    const escapedCmd = downloadCmd.replace(/'/g, "\\'");
                    
                    div.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div class="flex-1">
                                <div class="font-semibold text-sm text-accent">${model.name || model.id}</div>
                                <div class="text-xs text-secondary mt-1">${sizeInfo}${quantInfo} Â· ${model.downloads || 0} downloads</div>
                            </div>
                            <button onclick="downloadModelWithCommand('${escapedCmd}')" class="btn btn-primary btn-sm">Download</button>
                        </div>
                    `;
                    results.appendChild(div);
                });
            } catch (error) {
                console.error('Search error:', error);
                
                // Provide helpful error message based on error type
                let errorHtml = '';
                if (error.name === 'AbortError' || error.message.includes('Timeout') || error.message.includes('exceeded')) {
                    errorHtml = `
                        <div class="text-sm">
                            <p class="text-red-400 mb-2">âš  Search timeout: HuggingFace API not responding</p>
                            <p class="text-secondary mb-3">This usually means no internet connection or HuggingFace is slow.</p>
                            <div class="text-xs text-secondary">
                                <p class="font-semibold text-accent mb-2">Try instead:</p>
                                <p class="mb-1">â€¢ Use the terminal: <span class="font-mono bg-secondary px-2 py-1 rounded">offgrid search llama</span></p>
                                <p class="mb-1">â€¢ Download directly: <span class="font-mono bg-secondary px-2 py-1 rounded">offgrid download-hf TheBloke/TinyLlama-1.1B-Chat-v1.0-GGUF</span></p>
                                <p>â€¢ Check offline catalog: <span class="font-mono bg-secondary px-2 py-1 rounded">offgrid catalog</span></p>
                            </div>
                        </div>
                    `;
                } else {
                    errorHtml = `
                        <div class="text-sm">
                            <p class="text-red-400 mb-2">Search error: ${error.message}</p>
                            <p class="text-secondary mb-2">Use the Terminal tab to search instead:</p>
                            <p class="text-xs font-mono bg-secondary px-2 py-1 rounded inline-block">offgrid search ${query}</p>
                        </div>
                    `;
                }
                results.innerHTML = errorHtml;
            }
        }

        // Download model with specific command
        async function downloadModelWithCommand(command) {
            // Switch to terminal tab and execute download command
            switchTab('terminal');
            document.getElementById('terminalInput').value = command;
            runCommand();
        }

        // Download model (fallback for installed models)
        async function downloadModel(modelName) {
            // Switch to terminal tab and execute download command
            switchTab('terminal');
            document.getElementById('terminalInput').value = `offgrid download ${modelName}`;
            runCommand();
        }

        // Load installed models
        async function loadInstalledModels() {
            const container = document.getElementById('installedModels');
            container.innerHTML = '<p class="text-sm text-secondary">Loading...</p>';

            try {
                // Force refresh models from filesystem
                try {
                    await fetch('/models/refresh', { method: 'POST' });
                } catch (e) {
                    console.warn('Failed to refresh models, using cached list:', e);
                }
                
                const resp = await fetch('/models');
                const data = await resp.json();
                const models = data.data || [];

                if (models.length === 0) {
                    container.innerHTML = '<p class="text-sm text-secondary">No models installed</p>';
                    return;
                }

                container.innerHTML = '';
                models.forEach(model => {
                    const div = document.createElement('div');
                    div.className = 'model-item';
                    const modelId = (model.id || '').replace(/'/g, "\\'");
                    // Format model name for better readability
                    const displayName = model.id.replace(/_/g, ' ').replace(/-/g, ' ');
                    div.innerHTML = `
                        <div class="flex justify-between items-center gap-3">
                            <div class="flex-1 min-w-0">
                                <div class="font-semibold text-sm text-accent break-words" title="${model.id}">${displayName}</div>
                                <div class="text-xs text-secondary font-mono mt-1">${model.id}</div>
                            </div>
                            <button onclick="removeModel('${modelId}')" class="btn btn-danger btn-sm flex-shrink-0">Remove</button>
                        </div>
                    `;
                    container.appendChild(div);
                });
            } catch (error) {
                container.innerHTML = '<p class="text-sm text-red-400">Failed to load models</p>';
            }
        }

        // Remove model
        async function removeModel(modelId) {
            showModal({
                type: 'error',
                title: 'Remove Model?',
                message: `Are you sure you want to remove <strong>${modelId}</strong>?<br><br>This will delete the model file from your system.`,
                confirmText: 'Remove',
                cancelText: 'Cancel',
                onConfirm: () => {
                    confirmRemoveModel(modelId);
                }
            });
        }

        // Execute the actual removal via terminal
        async function confirmRemoveModel(modelId) {
            try {
                // Clear saved model if it's the one being deleted
                if (currentModel === modelId) {
                    currentModel = '';
                    localStorage.removeItem('offgrid_current_model');
                }
                
                // Switch to terminal tab to show progress
                switchTab('terminal');
                
                // Execute remove command
                const input = document.getElementById('terminalInput');
                input.value = `offgrid remove ${modelId} --yes`;
                
                // Trigger the command
                const event = new KeyboardEvent('keydown', { key: 'Enter', code: 'Enter', keyCode: 13 });
                input.dispatchEvent(event);
                
                // Note: Model list refresh happens in handleOffgridCommand after command completes
            } catch (error) {
                showModal({
                    type: 'error',
                    title: 'Remove Failed',
                    message: `Failed to remove model: ${error.message}`,
                    confirmText: 'OK'
                });
            }
        }

        // USB Import/Export Functions
        async function importFromUSB() {
            const usbPath = document.getElementById('usbImportPath').value.trim();
            const statusDiv = document.getElementById('usbImportStatus');
            
            if (!usbPath) {
                statusDiv.innerHTML = '<span class="text-yellow-400">âš  Please enter a USB path</span>';
                return;
            }
            
            statusDiv.innerHTML = '<span class="text-accent">â³ Importing models from USB...</span>';
            
            try {
                const response = await fetch('/v1/usb/import', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: usbPath })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    const count = data.imported_count || 0;
                    statusDiv.innerHTML = `<span class="text-green-400">âœ“ Successfully imported ${count} model(s)</span>`;
                    loadInstalledModels(); // Refresh the models list
                } else {
                    const error = data.error || 'Import failed';
                    statusDiv.innerHTML = `<span class="text-red-400">âœ— ${error}</span>`;
                }
            } catch (error) {
                statusDiv.innerHTML = `<span class="text-red-400">âœ— Error: ${error.message}</span>`;
            }
        }
        
        async function exportToUSB() {
            const usbPath = document.getElementById('usbExportPath').value.trim();
            const statusDiv = document.getElementById('usbExportStatus');
            
            if (!usbPath) {
                statusDiv.innerHTML = '<span class="text-yellow-400">âš  Please enter a USB path</span>';
                return;
            }
            
            statusDiv.innerHTML = '<span class="text-accent">â³ Exporting models to USB...</span>';
            
            try {
                const response = await fetch('/v1/usb/export', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: usbPath })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    const count = data.exported_count || 0;
                    const size = data.total_size_gb || 0;
                    statusDiv.innerHTML = `<span class="text-green-400">âœ“ Exported ${count} model(s) (${size.toFixed(2)} GB)</span>`;
                } else {
                    const error = data.error || 'Export failed';
                    statusDiv.innerHTML = `<span class="text-red-400">âœ— ${error}</span>`;
                }
            } catch (error) {
                statusDiv.innerHTML = `<span class="text-red-400">âœ— Error: ${error.message}</span>`;
            }
        }

        // Terminal commands
        function clearTerminal() {
            terminalOutputBuffer = ''; // Clear any buffered output
            document.getElementById('terminalOutput').innerHTML = `
                <div class="terminal-line terminal-success">OffGrid Terminal v0.1.6</div>
                <div class="terminal-line">Connected to real offgrid binary</div>
                <div class="terminal-line">Type 'help' for available commands or 'offgrid --help' for all options</div>
            `;
        }

        function killCommand() {
            if (currentTerminalAbort) {
                currentTerminalAbort.abort();
                currentTerminalAbort = null;
            }
            terminalRunning = false;
            const inputLine = document.getElementById('terminalInputLine');
            inputLine.classList.remove('terminal-running');
            document.getElementById('terminalInput').disabled = false;
            document.getElementById('killBtn').classList.add('hidden');
            addTerminalOutput('Command killed', 'error');
        }

        function runQuickCommand(cmd) {
            document.getElementById('terminalInput').value = cmd;
            runCommand();
        }

        function runCommand() {
            const input = document.getElementById('terminalInput');
            const cmd = input.value.trim();
            if (!cmd) return;

            // Handle chat mode
            if (terminalChatMode) {
                // Prevent sending while already processing
                if (terminalRunning || pendingRequest) {
                    console.log('Terminal chat request already in progress');
                    return; // Silently ignore, don't show error
                }
                
                // Throttle terminal chat requests
                const now = Date.now();
                if (now - lastRequestTime < requestCooldown) {
                    console.log('Throttling terminal chat request');
                    return;
                }
                lastRequestTime = now;
                
                if (cmd === 'exit' || cmd === 'quit') {
                    addTerminalOutput(cmd, 'prompt');
                    addTerminalOutput('Exiting chat mode...', 'success');
                    terminalChatMode = false;
                    terminalChatModel = '';
                    terminalChatHistory = [];
                    input.value = '';
                    return;
                } else if (cmd === 'clear') {
                    clearTerminal();
                    addTerminalOutput(`Chat mode with ${terminalChatModel}`, 'success');
                    addTerminalOutput('Type your message or "exit" to quit');
                    addTerminalOutput('> ', 'success');
                    input.value = '';
                    return;
                }
                
                // Send message in chat mode - disable input while processing
                addTerminalOutput(cmd, 'prompt');
                input.value = '';
                input.disabled = true;
                terminalRunning = true;
                pendingRequest = true;
                sendTerminalChat(cmd);
                return;
            }

            if (terminalRunning) {
                addTerminalOutput('Command already running. Use Kill button to stop it.', 'error');
                return;
            }
            
            // Add to history
            if (commandHistory[0] !== cmd) {
                commandHistory.unshift(cmd);
                if (commandHistory.length > 50) commandHistory.pop();
            }
            historyIndex = -1;

            addTerminalOutput(cmd, 'prompt');
            input.value = '';

            const parts = cmd.split(' ').filter(p => p);
            const command = parts[0];
            const args = parts.slice(1);

            // Set running state
            terminalRunning = true;
            const inputLine = document.getElementById('terminalInputLine');
            inputLine.classList.add('terminal-running');
            input.disabled = true;
            document.getElementById('killBtn').classList.remove('hidden');

            switch (command) {
                case 'offgrid':
                    handleOffgridCommand(args);
                    break;
                case 'clear':
                    clearTerminal();
                    resetTerminalState();
                    break;
                case 'help':
                    showHelp();
                    resetTerminalState();
                    break;
                case 'history':
                    showHistory();
                    resetTerminalState();
                    break;
                default:
                    addTerminalOutput(`Unknown command: ${command}. Type 'help' for available commands`, 'error');
                    resetTerminalState();
            }
        }

        function resetTerminalState() {
            terminalRunning = false;
            const inputLine = document.getElementById('terminalInputLine');
            inputLine.classList.remove('terminal-running');
            document.getElementById('terminalInput').disabled = false;
            document.getElementById('killBtn').classList.add('hidden');
        }

        function showHelp() {
            const help = [
                'Available Commands:',
                '',
                'Terminal Commands:',
                '  clear      - Clear terminal screen',
                '  history    - Show command history',
                '  help       - Show this help',
                '',
                'OffGrid Commands (runs real offgrid binary):',
                '  offgrid list                - List installed models',
                '  offgrid search <query>      - Search for models to download',
                '  offgrid download <model>    - Download a model',
                '  offgrid remove <model>      - Remove an installed model',
                '  offgrid run <model>         - Load model and switch to Chat tab',
                '  offgrid info                - Show system information',
                '  offgrid doctor              - Run diagnostics',
                '  offgrid --help              - Show all offgrid commands',
                '  offgrid --version           - Show version',
                '',
                'Tips:',
                '  - Use arrow keys (â†‘/â†“) to navigate history',
                '  - Use Tab for command autocomplete',
                '  - Press Ctrl+C or click Kill to stop command',
                '  - For interactive chat, use "offgrid run <model>" or Chat tab'
            ];
            help.forEach(line => addTerminalOutput(line));
        }

        function showHistory() {
            if (commandHistory.length === 0) {
                addTerminalOutput('No command history');
                return;
            }
            addTerminalOutput('Command History:');
            commandHistory.slice(0, 10).forEach((cmd, i) => {
                addTerminalOutput(`  ${i + 1}. ${cmd}`);
            });
        }

        async function handleOffgridCommand(args) {
            if (args.length === 0) {
                addTerminalOutput('Usage: offgrid <command>', 'error');
                addTerminalOutput('Try: offgrid help');
                resetTerminalState();
                return;
            }

            // Create abort controller for this command
            currentTerminalAbort = new AbortController();
            
            try {
                // Execute real offgrid command via streaming endpoint for real-time output
                const resp = await fetch('/v1/terminal/exec/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        command: 'offgrid',
                        args: args
                    }),
                    signal: currentTerminalAbort?.signal
                });

                if (!resp.ok) {
                    addTerminalOutput(`Command failed: HTTP ${resp.status}`, 'error');
                    resetTerminalState();
                    return;
                }

                // Read streaming response
                const reader = resp.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let exitCode = 0;

                while (true) {
                    const {done, value} = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, {stream: true});
                    
                    // Process complete SSE events
                    const lines = buffer.split('\n\n');
                    buffer = lines.pop(); // Keep incomplete event in buffer

                    for (const event of lines) {
                        if (!event.trim()) continue;
                        
                        // Parse SSE format: "event: type\ndata: line1\ndata: line2\n..."
                        const eventLines = event.split('\n');
                        let eventType = '';
                        const dataLines = [];
                        
                        for (const eLine of eventLines) {
                            if (eLine.startsWith('event:')) {
                                eventType = eLine.substring(6).trim();
                            } else if (eLine.startsWith('data:')) {
                                dataLines.push(eLine.substring(5).trim());
                            }
                        }
                        
                        if (!eventType) continue;
                        
                        const data = dataLines.join('\n');
                        
                        if (eventType === 'output') {
                            // Display output in real-time
                            if (data) addTerminalRawOutput(data);
                        } else if (eventType === 'exit') {
                            exitCode = parseInt(data);
                        } else if (eventType === 'error') {
                            addTerminalOutput(`Error: ${data}`, 'error');
                        }
                    }
                }
                
                // Special handling for 'run' command - enable terminal chat mode
                const subcmd = args[0];
                if (subcmd === 'run' && args.length > 1 && exitCode === 0) {
                    const modelName = args.slice(1).join(' ');
                    
                    // Enable chat mode
                    terminalChatMode = true;
                    terminalChatModel = modelName;
                    terminalChatHistory = [];
                    addTerminalOutput('', 'normal');
                    addTerminalOutput('Chat mode enabled. Type your messages below.', 'success');
                    addTerminalOutput('Commands: "exit" to quit, "clear" to reset screen', 'success');
                    addTerminalOutput('> ', 'success');
                }

                if (exitCode !== 0) {
                    addTerminalOutput(`Command exited with code ${exitCode}`, 'error');
                }

                // Refresh UI after certain commands (only on success)
                if (['download', 'remove', 'delete'].includes(subcmd) && exitCode === 0) {
                    // Wait longer to ensure backend has updated
                    setTimeout(() => {
                        loadInstalledModels();
                        loadChatModels();
                    }, 2500);
                }

            } catch (error) {
                if (error.name === 'AbortError') {
                    addTerminalOutput('Command aborted', 'error');
                } else {
                    addTerminalOutput(`Error: ${error.message}`, 'error');
                }
            } finally {
                flushTerminalBuffer(); // Flush any remaining buffered output
                resetTerminalState();
                currentTerminalAbort = null;
            }
        }



        // Send chat message in terminal mode
        async function sendTerminalChat(message) {
            try {
                terminalChatHistory.push({ role: 'user', content: message });
                
                const resp = await fetch('/v1/chat/completions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: terminalChatModel,
                        messages: terminalChatHistory,
                        stream: false,
                        temperature: 0.7,
                        max_tokens: 2000
                    })
                });

                if (!resp.ok) {
                    let errorMsg = `HTTP ${resp.status}`;
                    try {
                        const errorData = await resp.json();
                        errorMsg = errorData.error?.message || errorMsg;
                    } catch (e) {
                        // Ignore JSON parse errors
                    }
                    addTerminalOutput(`Error: ${errorMsg}`, 'error');
                    terminalChatHistory.pop(); // Remove failed message
                    return;
                }

                const data = await resp.json();
                const assistantMsg = data.choices?.[0]?.message?.content || 'No response';
                const actualModel = data.model || terminalChatModel;
                
                terminalChatHistory.push({ role: 'assistant', content: assistantMsg });
                
                // Show model info if different from expected
                if (actualModel !== terminalChatModel) {
                    addTerminalOutput(`[Using model: ${actualModel}]`, 'error');
                }
                
                addTerminalOutput('', 'normal');
                addTerminalOutput(assistantMsg, 'success');
                addTerminalOutput('', 'normal');
                addTerminalOutput('> ', 'success');
                
            } catch (error) {
                addTerminalOutput(`Error: ${error.message}`, 'error');
                if (terminalChatHistory.length > 0 && terminalChatHistory[terminalChatHistory.length - 1].role === 'user') {
                    terminalChatHistory.pop(); // Remove failed message
                }
            } finally {
                // Re-enable input after processing
                terminalRunning = false;
                pendingRequest = false;
                document.getElementById('terminalInput').disabled = false;
                document.getElementById('terminalInput').focus();
            }
        }

        // Strip ANSI escape codes
        function stripAnsi(text) {
            // Strip all ANSI escape codes (colors, cursor movement, etc.)
            return text.replace(/\x1b\[[0-9;]*[a-zA-Z]/g, '');
        }

        // Parse ANSI color codes and convert to HTML with CSS classes
        function parseAnsiColors(text) {
            // Map of ANSI codes to CSS classes
            const colorMap = {
                // Basic 16 colors
                '30': 'ansi-black',
                '31': 'ansi-red',
                '32': 'ansi-green',
                '33': 'ansi-yellow',
                '34': 'ansi-blue',
                '35': 'ansi-magenta',
                '36': 'ansi-cyan',
                '37': 'ansi-white',
                '90': 'ansi-gray',
                
                // 256-color palette (extended colors used in offgrid)
                '38;5;45': 'ansi-cyan',      // Bright cyan - headers
                '38;5;78': 'ansi-green',     // Bright green
                '38;5;141': 'ansi-purple',   // Purple - command names
                '38;5;196': 'ansi-red',      // Bright red - errors
                '38;5;226': 'ansi-yellow',   // Bright yellow
                '38;5;240': 'ansi-gray',     // Gray - dim text
                
                // Text styles
                '1': 'ansi-bold',            // Bold
                '2': 'ansi-dim',             // Dim/faint
                '22': 'ansi-normal',         // Normal intensity
            };
            
            let result = '';
            let currentClasses = new Set();
            let lastIndex = 0;
            
            // First, clean up any malformed ANSI sequences (missing escape char)
            // Replace [<codes>m with proper \x1b[<codes>m if not already escaped
            text = text.replace(/(?<!\x1b)\[([0-9;]+)m/g, '\x1b[$1m');
            
            // Match ANSI escape sequences: ESC [ <codes> m
            const ansiRegex = /\x1b\[([0-9;]+)m/g;
            let match;
            
            while ((match = ansiRegex.exec(text)) !== null) {
                // Add text before this escape code (escape HTML entities but preserve UTF-8)
                const textChunk = text.substring(lastIndex, match.index);
                result += textChunk
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                lastIndex = match.index + match[0].length;
                
                const codes = match[1].split(';');
                
                for (const code of codes) {
                    if (code === '0') {
                        // Reset - close all open spans and clear classes
                        if (currentClasses.size > 0) {
                            result += '</span>';
                            currentClasses.clear();
                        }
                    } else {
                        const cssClass = colorMap[code] || colorMap[codes.join(';')];
                        if (cssClass) {
                            // Close previous span if exists
                            if (currentClasses.size > 0) {
                                result += '</span>';
                            }
                            // Add new class and open new span
                            currentClasses.add(cssClass);
                            result += `<span class="${Array.from(currentClasses).join(' ')}">`;
                        }
                    }
                }
            }
            
            // Add remaining text (escape HTML but preserve UTF-8)
            const remainingText = text.substring(lastIndex);
            result += remainingText
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            
            // Close any remaining open spans
            if (currentClasses.size > 0) {
                result += '</span>';
            }
            
            return result;
        }

        function addTerminalOutput(text, type = 'normal') {
            const terminal = document.getElementById('terminalOutput');
            const line = document.createElement('div');
            line.className = 'terminal-line';
            
            if (type === 'prompt') {
                line.className = 'terminal-line terminal-prompt';
                line.textContent = '$ ' + text;
            } else if (type === 'error') {
                line.className = 'terminal-line terminal-error';
                line.textContent = text;
            } else if (type === 'success') {
                line.className = 'terminal-line terminal-success';
                line.textContent = text;
            } else if (type === 'raw') {
                // Raw output with ANSI colors
                line.innerHTML = parseAnsiColors(text);
            } else {
                // Normal output - preserve whitespace
                line.textContent = text;
            }
            
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
        }

        // Buffer for incomplete ANSI sequences across chunks
        let terminalOutputBuffer = '';

        function addTerminalRawOutput(text) {
            const terminal = document.getElementById('terminalOutput');
            
            // Combine with any buffered text from previous chunk
            text = terminalOutputBuffer + text;
            
            // Split by newlines
            const lines = text.split('\n');
            
            // Keep the last line (might be incomplete) in buffer
            terminalOutputBuffer = lines.pop() || '';
            
            // Process complete lines
            lines.forEach((lineText) => {
                const line = document.createElement('div');
                line.className = 'terminal-line';
                line.innerHTML = parseAnsiColors(lineText);
                terminal.appendChild(line);
            });
            
            terminal.scrollTop = terminal.scrollHeight;
        }
        
        // Flush any remaining buffer content (call this when command completes)
        function flushTerminalBuffer() {
            if (terminalOutputBuffer) {
                const terminal = document.getElementById('terminalOutput');
                const line = document.createElement('div');
                line.className = 'terminal-line';
                line.innerHTML = parseAnsiColors(terminalOutputBuffer);
                terminal.appendChild(line);
                terminalOutputBuffer = '';
                terminal.scrollTop = terminal.scrollHeight;
            }
        }

        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            // Restore active tab
            const savedTab = localStorage.getItem('offgrid_active_tab');
            if (savedTab && document.getElementById('tab-' + savedTab)) {
                switchTab(savedTab);
            } else {
                switchTab('chat');
            }
            
            // Load saved messages
            loadMessages();
            
            // Load chat models
            loadChatModels();
        });

        // Theme Toggle Logic
        const themeToggleBtn = document.getElementById('theme-toggle');
        const htmlElement = document.documentElement;
        
        // Check for saved theme preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        
        // Set initial theme
        if (savedTheme === 'dark' || (!savedTheme && systemTheme === 'dark')) {
            htmlElement.setAttribute('data-theme', 'dark');
        } else {
            htmlElement.removeAttribute('data-theme');
        }
        
        themeToggleBtn.addEventListener('click', () => {
            if (htmlElement.getAttribute('data-theme') === 'dark') {
                htmlElement.removeAttribute('data-theme');
                localStorage.setItem('theme', 'light');
            } else {
                htmlElement.setAttribute('data-theme', 'dark');
                localStorage.setItem('theme', 'dark');
            }
        });
    </script>
</body>
</html>
