<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>OffGrid LLM</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
    <!-- Marked.js for Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Terminal Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Light Theme - Clean & Crisp */
            --bg-primary: #ffffff;
            --bg-secondary: #f9fafb; /* Gray 50 - Very subtle gray */
            --bg-tertiary: #f3f4f6; /* Gray 100 */
            --text-primary: #111827; /* Gray 900 */
            --text-secondary: #6b7280; /* Gray 500 */
            --accent-primary: #06b6d4; /* Cyan 500 */
            --accent-hover: #0891b2; /* Cyan 600 */
            --accent-primary-alpha: rgba(6, 182, 212, 0.1);
            --border-color: #e5e7eb; /* Gray 200 */
            --card-bg: #ffffff;
            --card-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            --input-bg: #ffffff;
            --input-border: #d1d5db; /* Gray 300 */
            --code-bg: #f9fafb;
            --code-inline-bg: #f3f4f6;
            --header-bg: rgba(255, 255, 255, 0.9);
            --nav-bg: #f9fafb;
            --message-user-bg: #f3f4f6; /* Gray 100 - Neutral for user */
            --message-assistant-bg: transparent;
            --scrollbar-track: transparent;
            --scrollbar-thumb: #d1d5db;
            --scrollbar-thumb-hover: #9ca3af;
            --terminal-bg: #111827; /* Gray 900 */
            --terminal-text: #e5e7eb;
            --success-color: #10b981; /* Emerald 500 */
            
            /* ANSI Colors */
            --ansi-black: #374151;
            --ansi-cyan: #06b6d4;
            --ansi-green: #10b981;
            --ansi-yellow: #f59e0b;
            --ansi-red: #ef4444;
            --ansi-blue: #3b82f6;
            --ansi-magenta: #d946ef;
            --ansi-white: #f9fafb;
            --ansi-gray: #9ca3af;
        }

        [data-theme="dark"] {
            /* Dark Theme - True Neutral (No Blue Tint) */
            --bg-primary: #0a0a0a; /* Neutral 950 - True Black/Gray */
            --bg-secondary: #171717; /* Neutral 900 */
            --bg-tertiary: #262626; /* Neutral 800 */
            --text-primary: #fafafa; /* Neutral 50 */
            --text-secondary: #a3a3a3; /* Neutral 400 */
            --accent-primary: #22d3ee; /* Cyan 400 */
            --accent-hover: #67e8f9; /* Cyan 300 */
            --accent-primary-alpha: rgba(34, 211, 238, 0.15);
            --border-color: #262626;
            --card-bg: #171717;
            --card-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5), 0 2px 4px -1px rgba(0, 0, 0, 0.3);
            --input-bg: #171717;
            --input-border: #404040;
            --code-bg: #000000;
            --code-inline-bg: rgba(255, 255, 255, 0.08);
            --header-bg: rgba(10, 10, 10, 0.9);
            --nav-bg: #171717;
            --message-user-bg: #262626; /* Neutral 800 */
            --message-assistant-bg: transparent;
            --scrollbar-track: transparent;
            --scrollbar-thumb: #404040;
            --scrollbar-thumb-hover: #525252;
            --terminal-bg: #000000;
            --terminal-text: #e5e5e5;
            --success-color: #34d399;
        }

        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif;
        }
        
        body { 
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: row; /* Changed to row for sidebar layout */
            overflow: hidden;
            transition: background 0.3s ease, color 0.3s ease;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Sidebar Navigation */
        .sidebar {
            width: 260px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            padding: 24px 16px;
            z-index: 20;
            height: 100%;
        }

        .sidebar-header {
            margin-bottom: 24px;
            padding: 0 12px;
        }

        .sidebar-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 12px;
            letter-spacing: -0.02em;
        }

        .sidebar-nav {
            display: flex;
            flex-direction: column;
            gap: 2px;
            flex: 1;
            overflow-y: auto;
        }

        .nav-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 12px;
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            border: none;
        }

        .nav-item:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .nav-item.active {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-weight: 600;
        }
        
        .nav-item.active .nav-icon {
            color: var(--accent-primary);
        }

        .nav-icon {
            width: 18px;
            height: 18px;
            stroke-width: 2px;
            color: inherit;
        }

        .sidebar-footer {
            margin-top: auto;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-left: 12px;
            padding-right: 12px;
        }

        /* Main Content Area */
        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--bg-primary);
            position: relative;
        }

        .text-accent { color: var(--accent-primary); }
        .text-secondary { color: var(--text-secondary); }
        .bg-primary { background: var(--bg-primary); }
        .bg-secondary { background: var(--bg-secondary); }
        .border-theme { border-color: var(--border-color); }
        
        .input-theme {
            background: var(--input-bg);
            border: 1px solid var(--input-border);
            color: var(--text-primary);
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        
        .input-theme:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px var(--accent-primary-alpha);
            outline: none;
        }

        .card { 
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 24px;
            box-shadow: var(--card-shadow);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .card:hover {
            border-color: var(--accent-primary);
            transform: translateY(-2px);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border: none;
            font-size: 14px;
            font-weight: 500;
            outline: none;
            color: white;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn:hover:not(:disabled) {
            opacity: 1;
            transform: translateY(-1px);
            filter: brightness(1.1);
        }
        
        .btn:active:not(:disabled) {
            transform: translateY(0);
        }
        
        .btn-sm { 
            padding: 4px 12px; 
            font-size: 12px; 
        }
        
        .btn:disabled { 
            opacity: 0.5; 
            cursor: not-allowed;
        }
        
        .btn-primary { 
            background: var(--accent-primary);
            color: white; 
        }
        
        .btn-primary:hover:not(:disabled) { 
            background: var(--accent-hover);
        }
        
        .btn-secondary { 
            background: var(--bg-tertiary);
            color: var(--text-primary); 
            border: 1px solid var(--border-color);
        }
        
        .btn-secondary:hover:not(:disabled) { 
            background: var(--bg-secondary);
        }
        
        .btn-danger { 
            background: #f14c4c;
            color: white; 
        }
        
        .btn-danger:hover:not(:disabled) { 
            background: #d63b3b;
        }
        
        .btn-info { 
            background: var(--accent-primary);
            color: white; 
        }
        
        .btn-info:hover:not(:disabled) { 
            background: var(--accent-hover);
        }
        
        .tab { 
            padding: 10px 16px; 
            cursor: pointer; 
            border-bottom: 1px solid transparent; 
            transition: all 0.2s ease;
            font-weight: 400;
            color: var(--text-secondary);
        }
        
        .tab:hover { 
            color: var(--text-primary);
        }
        
        .tab.active { 
            border-bottom-color: var(--accent-primary);
            color: var(--text-primary);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message { 
            padding: 24px 0;
            margin-bottom: 0;
            word-wrap: break-word;
            border-bottom: 1px solid transparent;
            animation: fadeIn 0.3s ease-out forwards;
        }
        
        .message:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        
        .message-wrapper {
            max-width: 56rem;
            margin: 0 auto;
            padding: 0 1rem;
        }
        
        .message-user { 
            background: var(--message-user-bg);
        }
        
        .message-user .message-wrapper {
            display: flex;
            gap: 1.5rem;
            align-items: flex-start;
        }
        
        .message-assistant { 
            background: var(--message-assistant-bg);
        }
        
        .message-assistant .message-wrapper {
            display: flex;
            gap: 1.5rem;
            align-items: flex-start;
        }
        
        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .message-user .message-avatar {
            background: var(--accent-primary);
            color: white;
        }
        
        .message-assistant .message-avatar {
            background: linear-gradient(135deg, #14b8a6 0%, #0d9488 100%);
            color: white;
        }
        
        .message-body {
            flex: 1;
            min-width: 0;
            line-height: 1.6;
            font-size: 15px;
        }
        
        .message-actions { 
            display: flex; 
            gap: 8px; 
            margin-top: 12px; 
        }
        
        /* Modal Overlay Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            animation: fadeIn 0.2s ease;
        }
        
        .modal-dialog {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 32px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            animation: slideIn 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }
        
        @keyframes slideIn {
            from { transform: translateY(20px) scale(0.95); opacity: 0; }
            to { transform: translateY(0) scale(1); opacity: 1; }
        }
        
        .modal-dialog.warning {
            border-top: 4px solid #cca700;
        }
        
        .modal-dialog.error {
            border-top: 4px solid #f14c4c;
        }
        
        .modal-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .modal-icon {
            font-size: 24px;
            line-height: 1;
        }
        
        .modal-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .modal-body {
            margin-bottom: 24px;
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }
        
        .terminal-card {
            background: #0d1117 !important;
            border: 1px solid #21262d !important;
            box-shadow: none !important;
            border-radius: 8px;
        }
        
        .terminal-card:hover {
            border-color: #30363d !important;
            box-shadow: none !important;
        }
        
        .terminal { 
            background: #0d1117;
            border: 1px solid #21262d;
            border-radius: 6px;
            padding: 16px;
            font-family: 'JetBrains Mono', 'SF Mono', 'Consolas', monospace;
            font-size: 13px;
            overflow-y: auto;
            color: #c9d1d9;
        }

        
        .terminal-output { 
            overflow-y: auto; 
            overflow-x: hidden;
            padding: 20px 24px;
            line-height: 1.5;
            font-size: 14px;
            background: #0d1117;
            flex: 1;
            min-height: 0;
            font-family: Consolas, Monaco, 'Courier New', monospace;
        }
        
        .terminal-line { 
            color: #c9d1d9; 
            margin-bottom: 0; 
            white-space: pre;
            font-family: Consolas, Monaco, 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            padding: 0;
        }
        
        .terminal-line:empty {
            height: 0.5em;
        }
        
        /* Command output grouping */
        .terminal-command-group {
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        }
        
        .terminal-command-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        /* Markdown styles for terminal */
        .terminal-line p { margin-bottom: 0.5em; }
        .terminal-line p:last-child { margin-bottom: 0; }
        .terminal-line pre { background: #2d2d2d; padding: 8px; border-radius: 4px; overflow-x: auto; margin: 0.5em 0; }
        .terminal-line code { background: rgba(255,255,255,0.1); padding: 2px 4px; border-radius: 3px; font-family: inherit; }
        .terminal-line pre code { background: transparent; padding: 0; }
        .terminal-line ul, .terminal-line ol { margin-left: 1.5em; margin-bottom: 0.5em; }
        .terminal-line li { margin-bottom: 0.2em; }
        .terminal-line h1, .terminal-line h2, .terminal-line h3 { font-weight: bold; margin-top: 1em; margin-bottom: 0.5em; color: var(--ansi-cyan); }
        .terminal-line a { color: var(--ansi-blue); text-decoration: underline; }
        
        /* ANSI color classes - GitHub dark theme inspired */
        .ansi-black { color: #484f58; }
        .ansi-cyan { color: #56d4dd; }
        .ansi-green { color: #7ee787; }
        .ansi-yellow { color: #e3b341; }
        .ansi-red { color: #f85149; }
        .ansi-blue { color: #58a6ff; }
        .ansi-magenta { color: #bc8cff; }
        .ansi-purple { color: #bc8cff; }
        .ansi-gray { color: #8b949e; }
        .ansi-white { color: #c9d1d9; }
        .ansi-bold { font-weight: bold; }
        .ansi-dim { color: #6e7681; }
        .ansi-normal { font-weight: normal; }
        
        .terminal-error { 
            color: #f85149;
            font-weight: 500; 
        }
        
        .terminal-success { 
            color: #58a6ff; 
            font-weight: 500; 
        }
        
        .terminal-prompt { 
            color: #7ee787;
            font-weight: 600;
            margin-top: 16px;
            margin-bottom: 4px;
            display: block;
            padding-left: 0;
            font-family: inherit;
        }
        
        .terminal-prompt::before {
            content: '❯ ';
            color: #7ee787;
        }
        
        /* Section headers in output */
        .terminal-section-header {
            color: #58a6ff;
            font-weight: 600;
            margin-top: 12px;
            margin-bottom: 4px;
            border-bottom: 1px solid rgba(88, 166, 255, 0.2);
            padding-bottom: 4px;
        }
        
        /* Table-like output formatting */
        .terminal-table-row {
            display: flex;
            gap: 16px;
            padding: 2px 0;
        }
        
        .terminal-table-row .label {
            color: #8b949e;
            min-width: 120px;
        }
        
        .terminal-table-row .value {
            color: #c9d1d9;
        }
        
        /* Progress bar styling */
        .terminal-progress {
            background: #21262d;
            border-radius: 4px;
            padding: 8px 12px;
            margin: 4px 0;
        }
        
        .terminal-progress-bar {
            height: 4px;
            background: #30363d;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 6px;
        }
        
        .terminal-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #238636, #2ea043);
            transition: width 0.2s ease;
        }
        
        .terminal-input-line { 
            display: flex; 
            align-items: center; 
            gap: 8px; 
            padding: 12px 24px 20px 24px;
            border-top: 1px solid #21262d;
            background: #0d1117;
            min-height: auto;
        }

        .terminal-input-line .terminal-prompt {
            margin: 0;
            padding: 0;
            border: none;
            font-size: 13px;
            color: #7ee787;
        }
        
        .terminal-input-line .terminal-prompt::before {
            content: '';
        }
        
        .terminal-input { 
            background: transparent; 
            border: none; 
            color: #c9d1d9; 
            flex: 1; 
            outline: none; 
            box-shadow: none !important;
            font-family: 'Consolas', 'Monaco', 'Courier New', Courier, monospace;
            font-size: 14px; 
        }
        
        .terminal-running { 
            opacity: 0.6; 
            pointer-events: none; 
        }
        
        .model-item { 
            padding: 16px; 
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            margin-bottom: 10px;
            transition: all 0.2s ease;
            box-shadow: var(--card-shadow);
        }
        
        .model-item:hover { 
            background: var(--bg-secondary);
            border-color: var(--accent-primary);
            box-shadow: 0 2px 8px rgba(0, 188, 212, 0.15);
        }
        
        .badge { 
            display: inline-block; 
            padding: 4px 12px; 
            border-radius: 6px; 
            font-size: 11px; 
            font-weight: 700;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .badge-success { 
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white; 
        }
        
        .badge-warning { 
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white; 
        }
        
        .badge-error { 
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white; 
        }
        
        .badge-info { 
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: white; 
        }
        
        .hidden { 
            display: none; 
        }
        
        input:focus, select:focus, textarea:focus { 
            outline: none; 
            border-color: #06b6d4;
            box-shadow: 0 0 0 3px rgba(6, 182, 212, 0.1);
        }
        
        .chat-container { 
            display: flex; 
            flex-direction: column; 
            height: calc(100vh - 220px);
            min-height: 600px;
        }
        
        .chat-messages { 
            flex: 1; 
            overflow-y: auto; 
            padding: 16px; 
        }
        
        .chat-input-area { 
            padding: 16px; 
            border-top: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }
        
        .scrollable { 
            overflow-y: auto; 
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            display: flex;
            flex-direction: column;
        }
        
        .scrollable::-webkit-scrollbar { 
            width: 10px; 
        }
        
        .scrollable::-webkit-scrollbar-track { 
            background: transparent;
            border-radius: 5px;
        }
        
        .scrollable::-webkit-scrollbar-thumb { 
            background: var(--scrollbar-thumb);
            border-radius: 5px; 
        }
        
        .scrollable::-webkit-scrollbar-thumb:hover { 
            background: var(--scrollbar-thumb-hover);
        }
        
        .settings-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); 
            gap: 16px; 
        }
        
        .stat-card { 
            text-align: center; 
            padding: 20px;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            transition: box-shadow 0.2s ease;
        }
        
        .stat-card:hover {
            box-shadow: var(--card-shadow);
            border-color: var(--accent-primary);
        }
        
        .stat-value { 
            font-size: 32px; 
            font-weight: 700; 
            color: var(--accent-primary);
        }
        
        /* Thinking indicator animation */
        .thinking-indicator .thinking-dots {
            display: flex;
            gap: 4px;
        }
        
        .thinking-indicator .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent-primary);
            animation: thinking-bounce 1.4s infinite ease-in-out both;
        }
        
        .thinking-indicator .dot:nth-child(1) {
            animation-delay: -0.32s;
        }
        
        .thinking-indicator .dot:nth-child(2) {
            animation-delay: -0.16s;
        }
        
        @keyframes thinking-bounce {
            0%, 80%, 100% {
                transform: scale(0);
                opacity: 0.5;
            }
            40% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        .thinking-text {
            animation: thinking-pulse 1.5s ease-in-out infinite;
        }
        
        @keyframes thinking-pulse {
            0%, 100% {
                opacity: 0.6;
            }
            50% {
                opacity: 1;
            }
        }
        
        .stat-label { 
            font-size: 13px; 
            color: var(--text-secondary); 
            margin-top: 6px;
            font-weight: 500;
        }
        
        header {
            background: var(--header-bg);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
        }
        
        nav {
            background: transparent;
        }
        
        /* Code block styling */
        .message-content pre {
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 16px;
            margin: 12px 0;
            overflow-x: auto;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .message-content code {
            font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .message-content pre code {
            display: block;
            padding: 0;
            background: transparent;
            border: none;
        }
        
        .message-content :not(pre) > code {
            background: rgba(110, 118, 129, 0.4);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 13px;
            color: #e2e8f0;
        }
        
        /* Prose styling for markdown content */
        .message-content.prose {
            max-width: none;
        }
        
        .message-content.prose p {
            margin: 8px 0;
            line-height: 1.7;
        }
        
        .message-content.prose ul, 
        .message-content.prose ol {
            margin: 8px 0;
            padding-left: 24px;
        }
        
        .message-content.prose li {
            margin: 4px 0;
        }
        
        .message-content.prose h1,
        .message-content.prose h2,
        .message-content.prose h3,
        .message-content.prose h4 {
            margin: 16px 0 8px 0;
            font-weight: 600;
            color: #06b6d4;
        }
        
        .message-content.prose h1 { font-size: 1.5em; }
        .message-content.prose h2 { font-size: 1.3em; }
        .message-content.prose h3 { font-size: 1.1em; }
        
        .message-content.prose blockquote {
            border-left: 4px solid #06b6d4;
            padding-left: 16px;
            margin: 12px 0;
            color: #94a3b8;
            font-style: italic;
        }
        
        .message-content.prose a {
            color: #06b6d4;
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }
        
        .message-content.prose a:hover {
            border-bottom-color: #06b6d4;
        }
        
        .message-content.prose table {
            border-collapse: collapse;
            width: 100%;
            margin: 12px 0;
        }
        
        .message-content.prose th,
        .message-content.prose td {
            border: 1px solid #334155;
            padding: 8px 12px;
            text-align: left;
        }
        
        .message-content.prose th {
            background: rgba(6, 182, 212, 0.1);
            font-weight: 600;
            color: #06b6d4;
        }

        /* Theme toggle button */
        .theme-toggle {
            position: fixed;
            top: 16px;
            right: 16px;
            background: rgba(255, 255, 255, 0.8);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            transition: background 0.3s ease;
            z-index: 10000;
        }
        
        .theme-toggle:hover {
            background: rgba(255, 255, 255, 1);
        }
        
        .theme-toggle svg {
            width: 20px;
            height: 20px;
            stroke: #333;
        }
        
        [data-theme="dark"] .theme-toggle svg {
            stroke: #ccc;
        }

        .border-accent-hover:hover {
            border-color: var(--accent-primary) !important;
        }
        
        .app-nav {
            background: var(--nav-bg);
            border-bottom: 1px solid var(--border-color);
            padding: 0 24px;
            flex-shrink: 0;
        }

    </style>
</head>
<body class="antialiased">
    <!-- Sidebar Navigation -->
    <aside class="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-title">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-accent">
                    <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
                </svg>
                <span>OffGrid</span>
            </div>
        </div>
        
        <nav class="sidebar-nav">
            <button onclick="switchTab('chat')" id="tab-chat" class="nav-item active">
                <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                Chat
            </button>
            <button onclick="switchTab('knowledge')" id="tab-knowledge" class="nav-item">
                <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path><line x1="12" y1="6" x2="12" y2="12"></line><line x1="9" y1="9" x2="15" y2="9"></line></svg>
                Knowledge
            </button>
            <button onclick="switchTab('benchmark')" id="tab-benchmark" class="nav-item">
                <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line></svg>
                Benchmark
            </button>
            <button onclick="switchTab('models')" id="tab-models" class="nav-item">
                <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>
                Models
            </button>
            <button onclick="switchTab('terminal')" id="tab-terminal" class="nav-item">
                <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line></svg>
                Terminal
            </button>
        </nav>

        <div class="sidebar-footer">
            <div class="flex items-center gap-2">
                <span id="statusBadge" class="badge badge-success">Ready</span>
                <span class="text-xs text-secondary">v0.2..0</span>
            </div>
            <button id="theme-toggle" class="p-2 rounded-lg hover:bg-tertiary transition-colors text-secondary hover:text-primary" title="Toggle Theme">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="5"></circle>
                    <line x1="12" y1="1" x2="12" y2="3"></line>
                    <line x1="12" y1="21" x2="12" y2="23"></line>
                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                    <line x1="1" y1="12" x2="3" y2="12"></line>
                    <line x1="21" y1="12" x2="23" y2="12"></line>
                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                </svg>
            </button>
        </div>
    </aside>

    <main class="flex-1 flex flex-col overflow-hidden">
        <!-- Chat Tab -->
        <div id="content-chat" class="h-full flex flex-col overflow-hidden">
            <div class="p-4 border-b border-theme bg-primary/50 backdrop-blur-sm z-10">
                <div class="flex items-center gap-3 flex-wrap mb-3">
                    <select id="chatModel" class="flex-1 min-w-[200px] input-theme rounded px-3 py-2 text-sm" onchange="console.log('[INLINE] Dropdown changed to:', this.value); handleModelChange();">
                        <option value="">Loading...</option>
                    </select>
                    <select id="systemPrompt" onchange="applySystemPrompt()" class="flex-1 min-w-[200px] input-theme rounded px-3 py-2 text-sm">
                        <option value="">No System Prompt</option>
                        <option value="research">Research Assistant</option>
                        <option value="tutor">Study Tutor</option>
                        <option value="coder">Code Reviewer</option>
                        <option value="writer">Academic Writer</option>
                        <option value="custom">Custom Prompt...</option>
                    </select>
                </div>
                <div class="flex items-center gap-3 flex-wrap">
                    <div class="flex gap-2 flex-wrap">
                        <label class="flex items-center gap-2 text-xs">
                            <input type="checkbox" id="streamToggle" checked class="rounded">
                            <span>Stream</span>
                        </label>
                        <label class="flex items-center gap-2 text-xs" title="Enable to use RAG knowledge base for answers">
                            <input type="checkbox" id="useKnowledgeBase" class="rounded accent-emerald-500">
                            <span class="flex items-center gap-1">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-emerald-400">
                                    <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
                                    <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
                                </svg>
                                Knowledge Base
                            </span>
                        </label>
                        <label class="flex items-center gap-2 text-xs">
                            <span>Temp:</span>
                            <input type="number" id="temperature" value="0.7" step="0.1" min="0" max="2" 
                                   class="w-16 input-theme rounded px-2 py-1 text-xs">
                        </label>
                        <label class="flex items-center gap-2 text-xs">
                            <span>Max:</span>
                            <input type="number" id="maxTokens" value="1000" step="100" min="100" max="4000" 
                                   class="w-20 input-theme rounded px-2 py-1 text-xs">
                        </label>
                    </div>
                    <div class="flex gap-2 ml-auto">
                        <button onclick="toggleSessionsPanel()" class="btn btn-secondary btn-sm flex items-center gap-1" title="View saved sessions">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>
                            Sessions
                        </button>
                        <button onclick="saveCurrentSession()" class="btn btn-info btn-sm">Save Session</button>
                        <button onclick="showExportOptions()" class="btn btn-info btn-sm">Export</button>
                        <button onclick="newChat()" class="btn btn-secondary btn-sm">New Chat</button>
                    </div>
                </div>
            </div>

            <div class="flex-1 flex overflow-hidden bg-primary">
                <!-- Sessions Panel (collapsible) -->
                <div id="sessionsPanel" class="hidden w-72 border-r border-theme bg-secondary overflow-hidden flex-shrink-0 flex flex-col">
                    <div class="p-3 border-b border-theme flex items-center justify-between">
                        <h3 class="text-sm font-semibold">Saved Sessions</h3>
                        <div class="flex items-center gap-1">
                            <button onclick="createNewSession()" class="btn btn-primary btn-sm text-xs px-2 py-1">New</button>
                            <button onclick="toggleSessionsPanel()" class="p-1 hover:bg-white/10 rounded">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                            </button>
                        </div>
                    </div>
                    <div class="p-2">
                        <input type="text" id="sessionSearch" placeholder="Search sessions..." 
                               onkeyup="filterSessions()"
                               class="w-full input-theme rounded px-2 py-1.5 text-xs" />
                    </div>
                    <div id="sessionsList" class="flex-1 overflow-auto px-2 pb-2 space-y-1">
                        <p class="text-xs text-secondary text-center py-4">No saved sessions yet.</p>
                    </div>
                </div>
                
                <!-- Main Chat Area -->
                <div class="flex-1 flex flex-col overflow-hidden">
                    <div id="chatMessages" class="flex-1 scrollable px-4 py-4">
                        <div class="text-center text-secondary py-32">
                            <p class="text-xl font-medium">Start a conversation</p>
                            <p class="text-sm mt-2">Select a model and type your message below</p>
                        </div>
                    </div>
                <div class="flex-shrink-0 bg-primary border-t border-theme">
                    <div class="max-w-3xl mx-auto py-4 px-4">
                        <div class="relative input-theme rounded-xl focus-within:border-theme transition-colors shadow-lg flex flex-col">
                            <!-- Image Preview Area -->
                            <div id="imagePreview" class="hidden px-4 pt-3 pb-1 border-b border-white/5">
                                <div class="flex items-center justify-between mb-2 text-xs text-secondary">
                                    <span id="imageAttachmentCount">0 attachments</span>
                                    <button type="button" onclick="clearAllImages()" class="text-red-300 hover:text-red-200">Clear all</button>
                                </div>
                                <div id="imagePreviewList" class="flex flex-wrap gap-3"></div>
                            </div>

                            <div class="flex items-end w-full">
                                <!-- Image Upload Button -->
                                <button id="imageUploadBtn" onclick="document.getElementById('imageInput').click()" 
                                        class="ml-3 mb-3 w-8 h-8 rounded-lg text-secondary hover:text-primary hover:bg-white/10 transition-colors flex items-center justify-center hidden"
                                        title="Upload Image">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                        <circle cx="8.5" cy="8.5" r="1.5"/>
                                        <polyline points="21 15 16 10 5 21"/>
                                    </svg>
                                </button>
                                <input type="file" id="imageInput" accept="image/*" multiple class="hidden" onchange="handleImageUpload(event)">

                                <div class="flex-1 relative">
                                    <textarea id="chatInput" placeholder="Message OffGrid LLM..." 
                                    onkeydown="handleChatKeydown(event)"
                                    oninput="autoResizeTextarea(this)"
                                    rows="1"
                                    style="max-height: 200px; min-height: 52px;"
                                    class="w-full bg-transparent border-none px-4 py-3 pr-12 text-sm text-primary resize-none focus:outline-none"></textarea>
                                    
                                    <button onclick="sendChat()" id="sendBtn" 
                                            class="absolute right-2 bottom-2 w-8 h-8 rounded-lg btn-primary disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center justify-center">
                                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" class="text-white">
                                            <path d="M.5 1.163A1 1 0 0 1 1.97.28l12.868 6.837a1 1 0 0 1 0 1.766L1.969 15.72A1 1 0 0 1 .5 14.836V10.33a1 1 0 0 1 .816-.983L8.5 8 1.316 6.653A1 1 0 0 1 .5 5.67V1.163Z" fill="currentColor"/>
                                        </svg>
                                    </button>
                                    <button onclick="stopGeneration()" id="stopBtn" 
                                            class="absolute right-2 bottom-2 w-8 h-8 rounded-lg bg-red-600 hover:bg-red-700 transition-colors items-center justify-center hidden">
                                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" class="text-white">
                                            <rect x="3" y="3" width="10" height="10" rx="2" fill="currentColor"/>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="flex items-center justify-between mt-2 text-xs text-secondary px-1">
                            <div class="flex gap-3">
                                <span id="tokenCount">0 tokens</span>
                                <span>•</span>
                                <span id="messageCount">0 messages</span>
                                <span id="ragIndicator" class="hidden">•</span>
                                <span id="ragIndicatorText" class="hidden text-emerald-400 flex items-center gap-1">
                                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
                                        <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
                                    </svg>
                                    RAG Active
                                </span>
                            </div>
                            <span id="statusBadge" class="text-xs font-medium">Ready</span>
                        </div>
                    </div>
                </div>
                </div>
            </div>
        </div>

        <!-- Knowledge Base (RAG) Tab -->
        <div id="content-knowledge" class="hidden h-full overflow-auto px-6 py-4">
            <div class="max-w-5xl mx-auto space-y-4">
                <!-- RAG Status Card -->
                <div class="card">
                    <div class="flex items-center justify-between mb-4">
                        <div>
                            <h3 class="text-lg font-semibold">Knowledge Base</h3>
                            <p class="text-xs text-secondary">Upload documents for AI-powered Q&A with RAG (Retrieval Augmented Generation)</p>
                        </div>
                        <div id="ragStatusBadge" class="badge badge-secondary">Disabled</div>
                    </div>
                    
                    <!-- Embedding Model Selection - simplified -->
                    <div class="flex items-center gap-3 mb-4">
                        <label class="text-sm font-medium whitespace-nowrap">Embedding Model:</label>
                        <select id="ragEmbeddingModel" onchange="onEmbeddingModelChange()" class="flex-1 input-theme rounded px-3 py-2 text-sm max-w-xs">
                            <option value="">Select model to enable...</option>
                        </select>
                        <button onclick="disableRAG()" id="ragDisableBtn" class="btn btn-secondary btn-sm hidden">
                            Disable
                        </button>
                    </div>

                    <!-- RAG Stats -->
                    <div id="ragStats" class="grid grid-cols-3 gap-4">
                        <div class="text-center p-3 bg-tertiary rounded-lg">
                            <div class="text-2xl font-bold text-accent" id="ragDocCount">0</div>
                            <div class="text-xs text-secondary">Documents</div>
                        </div>
                        <div class="text-center p-3 bg-tertiary rounded-lg">
                            <div class="text-2xl font-bold text-accent" id="ragChunkCount">0</div>
                            <div class="text-xs text-secondary">Chunks</div>
                        </div>
                        <div class="text-center p-3 bg-tertiary rounded-lg">
                            <div class="text-2xl font-bold text-accent" id="ragEmbeddingCount">0</div>
                            <div class="text-xs text-secondary">Embeddings</div>
                        </div>
                    </div>
                </div>

                <!-- Upload Documents Card -->
                <div class="card">
                    <h4 class="font-semibold mb-3">Add Documents</h4>
                    
                    <!-- Drag & Drop Zone -->
                    <div id="ragDropZone" 
                         class="border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-8 text-center hover:border-accent transition-colors cursor-pointer"
                         ondrop="handleRAGDrop(event)" 
                         ondragover="handleRAGDragOver(event)"
                         ondragleave="handleRAGDragLeave(event)"
                         onclick="document.getElementById('ragFileInput').click()">
                        <svg class="w-12 h-12 mx-auto mb-3 text-secondary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                        </svg>
                        <p class="text-secondary mb-1">Drag & drop files here or click to browse</p>
                        <p class="text-xs text-secondary">Supports: .txt, .md, .json, .csv, .html</p>
                        <input type="file" id="ragFileInput" accept=".txt,.md,.markdown,.json,.csv,.html,.htm" multiple class="hidden" onchange="handleRAGFileSelect(event)">
                    </div>

                    <!-- Or paste text -->
                    <div class="mt-4">
                        <label class="block text-sm font-medium mb-2">Or paste text directly:</label>
                        <textarea id="ragTextInput" 
                                  rows="4" 
                                  class="w-full input-theme rounded-lg px-3 py-2 text-sm font-mono"
                                  placeholder="Paste your text content here..."></textarea>
                        <div class="flex items-center gap-2 mt-2">
                            <input type="text" id="ragTextName" 
                                   class="flex-1 input-theme rounded px-3 py-2 text-sm" 
                                   placeholder="Document name (e.g., 'meeting-notes.txt')">
                            <button onclick="ingestRAGText()" class="btn btn-primary">Add Text</button>
                        </div>
                    </div>
                </div>

                <!-- Documents List Card -->
                <div class="card">
                    <div class="flex items-center justify-between mb-3">
                        <h4 class="font-semibold">Your Documents</h4>
                        <button onclick="refreshRAGDocuments()" class="btn btn-secondary btn-sm">Refresh</button>
                    </div>
                    <div id="ragDocumentsList" class="space-y-2">
                        <p class="text-secondary text-sm">No documents uploaded yet.</p>
                    </div>
                </div>

                <!-- Search Test Card -->
                <div class="card">
                    <h4 class="font-semibold mb-3">Search Knowledge Base</h4>
                    <p class="text-xs text-secondary mb-3">Search your documents to find relevant content.</p>
                    <div class="flex gap-2">
                        <input type="text" id="ragSearchQuery" 
                               class="flex-1 input-theme rounded px-3 py-2 text-sm" 
                               placeholder="Enter a search query..."
                               onkeypress="if(event.key==='Enter')searchRAGDocuments()">
                        <button onclick="searchRAGDocuments()" class="btn btn-primary">Search</button>
                    </div>
                    <div id="ragSearchResults" class="mt-4 space-y-2"></div>
                </div>

                <!-- Developer Tools - Collapsible -->
                <div class="card">
                    <div class="flex items-center justify-between cursor-pointer" onclick="toggleDevTools()">
                        <div class="flex items-center gap-2">
                            <svg class="w-4 h-4 text-secondary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                            </svg>
                            <span class="text-sm font-medium text-secondary">Developer Tools</span>
                        </div>
                        <svg id="devToolsIcon" class="w-4 h-4 text-secondary transition-transform" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"></polyline></svg>
                    </div>
                    
                    <div id="devToolsContent" class="hidden mt-4 pt-4 border-t border-theme space-y-4">
                        <div>
                            <h5 class="text-sm font-medium mb-2">Test Embeddings</h5>
                            <p class="text-xs text-secondary mb-3">Generate vector embeddings from text to test your embedding model.</p>
                        </div>
                        
                        <!-- Model Selection -->
                        <div>
                            <label class="text-xs text-secondary block mb-1">Embedding Model</label>
                            <select id="embeddingModel" class="w-full input-theme rounded px-3 py-2 text-sm">
                                <option value="">Loading...</option>
                            </select>
                        </div>
                        
                        <!-- Text Input -->
                        <div>
                            <label class="text-xs text-secondary block mb-1">Input Text</label>
                            <textarea id="embeddingInput" 
                                      placeholder="Enter text to generate embeddings..."
                                      rows="3"
                                      class="w-full input-theme rounded px-3 py-2 text-sm font-mono resize-y"></textarea>
                        </div>
                        
                        <!-- Actions -->
                        <div class="flex gap-2">
                            <button onclick="generateEmbedding()" id="generateEmbeddingBtn" class="btn btn-secondary btn-sm">
                                Generate
                            </button>
                            <button onclick="clearEmbedding()" class="btn btn-secondary btn-sm">Clear</button>
                        </div>
                        
                        <!-- Results -->
                        <div id="embeddingResults" class="hidden">
                            <div class="border-t border-theme pt-3">
                                <div class="flex items-center justify-between mb-2">
                                    <span class="text-xs text-secondary">Output</span>
                                    <button onclick="copyEmbedding()" class="text-xs text-accent hover:underline">Copy Vector</button>
                                </div>
                                
                                <!-- Stats -->
                                <div class="grid grid-cols-3 gap-2 mb-2 text-xs">
                                    <div class="bg-secondary rounded px-2 py-1">
                                        <div class="text-secondary">Dims</div>
                                        <div id="embeddingDimensions" class="font-semibold text-accent">-</div>
                                    </div>
                                    <div class="bg-secondary rounded px-2 py-1">
                                        <div class="text-secondary">Tokens</div>
                                        <div id="embeddingTokens" class="font-semibold text-accent">-</div>
                                    </div>
                                    <div class="bg-secondary rounded px-2 py-1">
                                        <div class="text-secondary">Time</div>
                                        <div id="embeddingTime" class="font-semibold text-accent">-</div>
                                    </div>
                                </div>
                                
                                <!-- Vector Output -->
                                <div id="embeddingVector" 
                                     class="bg-tertiary rounded px-2 py-1 text-xs font-mono overflow-x-auto max-h-24 overflow-y-auto"
                                     style="white-space: pre-wrap; word-break: break-all;"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Benchmark Tab -->
        <div id="content-benchmark" class="hidden h-full overflow-auto px-6 py-4">
            <div class="max-w-5xl mx-auto space-y-4">
                <!-- Benchmark Header -->
                <div class="card">
                    <div class="flex items-center justify-between mb-4">
                        <div>
                            <h3 class="text-lg font-semibold">Model Benchmarks</h3>
                            <p class="text-xs text-secondary">Compare model performance on your hardware</p>
                        </div>
                        <button onclick="runBenchmark()" id="benchmarkRunBtn" class="btn btn-primary">
                            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            Run Benchmark
                        </button>
                    </div>

                    <!-- Benchmark Settings -->
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                        <div>
                            <label class="block text-sm font-medium mb-1">Select Model</label>
                            <select id="benchmarkModel" class="w-full input-theme rounded px-3 py-2 text-sm">
                                <option value="">Choose a model...</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-1">Prompt Length</label>
                            <select id="benchmarkPromptLength" class="w-full input-theme rounded px-3 py-2 text-sm">
                                <option value="short">Short (~50 tokens)</option>
                                <option value="medium" selected>Medium (~200 tokens)</option>
                                <option value="long">Long (~500 tokens)</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-1">Output Tokens</label>
                            <select id="benchmarkOutputTokens" class="w-full input-theme rounded px-3 py-2 text-sm">
                                <option value="50">50 tokens</option>
                                <option value="100" selected>100 tokens</option>
                                <option value="200">200 tokens</option>
                                <option value="500">500 tokens</option>
                            </select>
                        </div>
                    </div>

                    <!-- Progress Bar -->
                    <div id="benchmarkProgress" class="hidden mb-4">
                        <div class="flex items-center justify-between mb-1">
                            <span class="text-sm" id="benchmarkStatus">Running...</span>
                            <span class="text-sm text-secondary" id="benchmarkPercent">0%</span>
                        </div>
                        <div class="w-full bg-tertiary rounded-full h-2">
                            <div id="benchmarkProgressBar" class="bg-accent h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                        </div>
                    </div>
                </div>

                <!-- Live Metrics Card -->
                <div class="card">
                    <h4 class="font-semibold mb-4">Current Run Metrics</h4>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                        <div class="text-center p-4 bg-tertiary rounded-lg">
                            <div class="text-3xl font-bold text-accent" id="benchLiveTokensPerSec">--</div>
                            <div class="text-xs text-secondary">Tokens/sec</div>
                        </div>
                        <div class="text-center p-4 bg-tertiary rounded-lg">
                            <div class="text-3xl font-bold text-accent" id="benchLiveTimeToFirst">--</div>
                            <div class="text-xs text-secondary">Time to First Token (ms)</div>
                        </div>
                        <div class="text-center p-4 bg-tertiary rounded-lg">
                            <div class="text-3xl font-bold text-accent" id="benchLiveTotalTime">--</div>
                            <div class="text-xs text-secondary">Total Time (s)</div>
                        </div>
                        <div class="text-center p-4 bg-tertiary rounded-lg">
                            <div class="text-3xl font-bold text-accent" id="benchLiveMemory">--</div>
                            <div class="text-xs text-secondary">Memory Usage (GB)</div>
                        </div>
                    </div>
                </div>

                <!-- Benchmark History Card -->
                <div class="card">
                    <div class="flex items-center justify-between mb-4">
                        <h4 class="font-semibold">Benchmark History</h4>
                        <button onclick="clearBenchmarkHistory()" class="btn btn-secondary btn-sm">Clear History</button>
                    </div>
                    
                    <!-- Comparison Chart -->
                    <div class="mb-4">
                        <div id="benchmarkChart" class="space-y-3">
                            <p class="text-secondary text-sm text-center py-4">Run benchmarks to see comparison charts</p>
                        </div>
                    </div>

                    <!-- History Table -->
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm">
                            <thead>
                                <tr class="border-b border-theme">
                                    <th class="text-left py-2 px-3">Model</th>
                                    <th class="text-right py-2 px-3">Tokens/sec</th>
                                    <th class="text-right py-2 px-3">TTFT (ms)</th>
                                    <th class="text-right py-2 px-3">Total (s)</th>
                                    <th class="text-right py-2 px-3">Memory (GB)</th>
                                    <th class="text-right py-2 px-3">Date</th>
                                </tr>
                            </thead>
                            <tbody id="benchmarkHistoryTable">
                                <tr>
                                    <td colspan="6" class="text-center py-4 text-secondary">No benchmarks yet</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Hardware Info Card -->
                <div class="card">
                    <h4 class="font-semibold mb-3">System Information</h4>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                        <div>
                            <div class="text-secondary">CPU</div>
                            <div id="sysInfoCPU" class="font-medium">Detecting...</div>
                        </div>
                        <div>
                            <div class="text-secondary">RAM</div>
                            <div id="sysInfoRAM" class="font-medium">Detecting...</div>
                        </div>
                        <div>
                            <div class="text-secondary">GPU</div>
                            <div id="sysInfoGPU" class="font-medium">Detecting...</div>
                        </div>
                        <div>
                            <div class="text-secondary">Backend</div>
                            <div id="sysInfoBackend" class="font-medium">llama.cpp</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Models Tab -->
        <div id="content-models" class="hidden h-full overflow-auto px-6 py-4">
            <div class="max-w-5xl mx-auto space-y-4">
            
            <!-- USB Import/Export Section -->
            <div class="card">
                <h3 class="text-lg font-semibold mb-4">USB Model Transfer</h3>
                <p class="text-xs text-secondary mb-4">Transfer models to/from USB drives for offline deployment</p>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- Import Section -->
                    <div class="border border-theme rounded-lg p-4">
                        <h4 class="text-sm font-medium mb-2 text-accent flex items-center gap-2">
                            Import from USB
                        </h4>
                        <p class="text-xs text-secondary mb-3">Load models from a USB drive with OffGrid packages</p>
                        
                        <div class="space-y-3">
                            <div>
                                <label class="text-xs text-secondary block mb-1">USB Path:</label>
                                <div class="flex gap-2">
                                    <input type="text" id="usbImportPath" 
                                           placeholder="/media/usb or D:\"
                                           value="/media/usb"
                                           class="flex-1 input-theme rounded px-3 py-2 text-sm font-mono" />
                                    <button onclick="browseForPath('import')" class="btn btn-secondary px-3" title="Browse for folder">
                                        Browse
                                    </button>
                                </div>
                            </div>
                            
                            <div class="flex gap-2">
                                <button onclick="scanUSB()" class="btn btn-secondary flex-1">
                                    Scan
                                </button>
                                <button onclick="importFromUSB()" class="btn btn-primary flex-1">
                                    Import All
                                </button>
                            </div>
                            
                            <div id="usbScanResults" class="text-xs"></div>
                            <div id="usbImportStatus" class="text-xs"></div>
                            <div id="usbImportProgress" class="hidden">
                                <div class="w-full bg-gray-700 rounded-full h-2 mb-1">
                                    <div id="usbImportProgressBar" class="bg-accent h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                                </div>
                                <div id="usbImportProgressText" class="text-xs text-secondary"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Export Section -->
                    <div class="border border-theme rounded-lg p-4">
                        <h4 class="text-sm font-medium mb-2 text-accent flex items-center gap-2">
                            Export to USB
                        </h4>
                        <p class="text-xs text-secondary mb-3">Create a portable bundle of all your models</p>
                        
                        <div class="space-y-3">
                            <div>
                                <label class="text-xs text-secondary block mb-1">USB Path:</label>
                                <div class="flex gap-2">
                                    <input type="text" id="usbExportPath" 
                                           placeholder="/media/usb or D:\"
                                           value="/media/usb"
                                           class="flex-1 input-theme rounded px-3 py-2 text-sm font-mono" />
                                    <button onclick="browseForPath('export')" class="btn btn-secondary px-3" title="Browse for folder">
                                        Browse
                                    </button>
                                </div>
                            </div>
                            
                            <button onclick="exportToUSB()" class="btn btn-primary w-full">
                                Export All Models
                            </button>
                            
                            <div id="usbExportStatus" class="text-xs"></div>
                            <div id="usbExportProgress" class="hidden">
                                <div class="w-full bg-gray-700 rounded-full h-2 mb-1">
                                    <div id="usbExportProgressBar" class="bg-accent h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                                </div>
                                <div id="usbExportProgressText" class="text-xs text-secondary"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Common USB Paths Helper -->
                <div class="mt-4 p-3 bg-secondary rounded text-xs">
                    <span class="font-medium text-accent">Common USB mount points:</span>
                    <div class="mt-1 space-y-1 text-secondary">
                        <div><span class="font-mono">Linux:</span> /media/username/device or /mnt/usb</div>
                        <div><span class="font-mono">macOS:</span> /Volumes/device</div>
                        <div><span class="font-mono">Windows:</span> D:\\ E:\\ F:\\</div>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h3 class="text-lg font-semibold mb-4">Search & Download Models</h3>
                <div class="flex gap-2 mb-4">
                    <input type="text" id="searchQuery" placeholder="Search models (e.g., llama, phi, mistral)..." 
                           class="flex-1 input-theme rounded px-3 py-2 text-sm" />
                    <button onclick="searchModels()" class="btn btn-primary">Search</button>
                </div>
                <div id="searchResults" class="space-y-2"></div>
            </div>

            <div class="card">
                <h3 class="text-lg font-semibold mb-4">Installed Models</h3>
                <div id="installedModels" class="space-y-2">
                    <p class="text-sm text-secondary">Loading...</p>
                </div>
            </div>
            </div>
        </div>

        <!-- Terminal Tab -->
        <div id="content-terminal" class="hidden h-full flex flex-col px-6 py-4">
            <div class="max-w-5xl mx-auto flex-1 flex flex-col gap-4 w-full min-h-0">
            <div class="flex-shrink-0">
                <div class="flex items-center gap-3 px-4 py-3 bg-secondary rounded-lg border border-theme">
                    <span class="text-xs font-bold text-secondary uppercase tracking-wider">Quick Commands:</span>
                    <div class="flex gap-2 flex-1">
                        <button onclick="runQuickCommand('offgrid list')" 
                                class="px-4 py-1.5 bg-[#1e1e1e] hover:bg-[#2d2d2d] text-[#00bcd4] hover:text-[#4FC1FF] rounded border border-[#333] font-mono text-xs transition-all duration-150 shadow-sm">
                            list
                        </button>
                        <button onclick="runQuickCommand('offgrid recommend')" 
                                class="px-4 py-1.5 bg-[#1e1e1e] hover:bg-[#2d2d2d] text-[#00bcd4] hover:text-[#4FC1FF] rounded border border-[#333] font-mono text-xs transition-all duration-150 shadow-sm">
                            recommend
                        </button>
                        <button onclick="runQuickCommand('offgrid help')" 
                                class="px-4 py-1.5 bg-[#1e1e1e] hover:bg-[#2d2d2d] text-[#00bcd4] hover:text-[#4FC1FF] rounded border border-[#333] font-mono text-xs transition-all duration-150 shadow-sm">
                            help
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="card terminal-card flex-1 flex flex-col min-h-0">
                <div class="flex items-center justify-between mb-3 flex-shrink-0">
                    <h3 class="text-lg font-semibold">Terminal</h3>
                    <div class="flex gap-2">
                        <button onclick="killCommand()" id="killBtn" class="btn btn-danger btn-sm hidden">Kill</button>
                        <button onclick="clearTerminal()" class="btn btn-secondary btn-sm">Clear</button>
                    </div>
                </div>
                <div class="terminal-output scrollable flex-1 overflow-y-auto" id="terminalOutput">
                    <div class="terminal-line terminal-success">OffGrid Terminal v0.2..0</div>
                    <div class="terminal-line">Connected to real offgrid binary</div>
                    <div class="terminal-line">Type 'help' for available commands or 'offgrid --help' for all options</div>
                </div>
                <div class="terminal-input-line flex-shrink-0" id="terminalInputLine">
                    <span class="terminal-prompt">$</span>
                    <input type="text" id="terminalInput" placeholder="Enter command..." 
                           onkeydown="handleTerminalKeydown(event)"
                           class="terminal-input" autocomplete="off" />
                </div>
            </div>
            </div>
        </div>
    </main>

    <script>
        let currentModel = '';
        let messages = [];
        let isGenerating = false;
        let abortController = null;
        let commandHistory = [];
        let historyIndex = -1;
        let terminalRunning = false;
        let currentTerminalAbort = null;
        let terminalChatMode = false;
        let terminalChatModel = '';
        let terminalChatHistory = [];
        
        // Session management
        let sessions = JSON.parse(localStorage.getItem('offgrid_sessions') || '[]');
        let currentSessionId = null;
        let currentSystemPrompt = '';
        
        // System prompts for different use cases
        const systemPrompts = {
            research: "You are a knowledgeable research assistant. Help users understand complex topics, find relevant information, and think critically about academic questions. Provide detailed, well-sourced responses with references when possible.",
            tutor: "You are a patient and encouraging tutor. Break down complex concepts into simple explanations, use analogies and examples, ask questions to check understanding, and adapt your teaching style to the student's level.",
            coder: "You are an expert code reviewer and programming mentor. Provide detailed code reviews, suggest improvements for readability and performance, explain best practices, and help debug issues. Format all code with proper syntax highlighting.",
            writer: "You are an academic writing assistant. Help with essay structure, grammar, clarity, citation formats, and academic tone. Provide constructive feedback and suggestions for improvement.",
        };
        
        // Request throttling to prevent system overload
        let lastRequestTime = 0;
        let requestCooldown = 300; // Minimum 300ms between requests
        let pendingRequest = false;

        // Save messages to localStorage
        function saveMessages() {
            try {
                localStorage.setItem('offgrid_messages', JSON.stringify(messages));
                localStorage.setItem('offgrid_current_model', currentModel);
            } catch (e) {
                console.error('Failed to save messages:', e);
            }
        }

        function normalizeMessageContent(rawContent) {
            if (Array.isArray(rawContent)) {
                const textParts = rawContent
                    .filter(part => part?.type === 'text')
                    .map(part => part.text || '');
                const imageParts = rawContent
                    .filter(part => part?.type === 'image_url' && part.image_url?.url)
                    .map(part => part.image_url.url);
                return {
                    text: textParts.join('\n\n').trim(),
                    images: imageParts
                };
            }

            if (typeof rawContent === 'string') {
                return { text: rawContent, images: [] };
            }

            if (rawContent && typeof rawContent === 'object') {
                if (typeof rawContent.text === 'string') {
                    return { text: rawContent.text, images: [] };
                }
            }

            return { text: rawContent ? String(rawContent) : '', images: [] };
        }

        function escapeAttribute(value) {
            return (value || '').replace(/"/g, '&quot;');
        }

        function modelSupportsVision(modelInfo, fallbackId = '') {
            const hasCapability = Array.isArray(modelInfo?.capabilities) && modelInfo.capabilities.includes('vision');
            if (hasCapability || modelInfo?.type === 'vlm') {
                return true;
            }

            const tags = Array.isArray(modelInfo?.tags) ? modelInfo.tags : [];
            if (tags.some(tag => ['vision', 'vlm', 'multimodal', 'image'].includes(tag?.toLowerCase?.() || tag))) {
                return true;
            }

            const identifier = (fallbackId || modelInfo?.id || '').toLowerCase();
            const keywords = ['llava', 'bakllava', 'vision', 'yi-vl', 'vlm', 'qwen', 'moondream', 'minicpm', 'minicpm-v', 'pixtral'];
            return keywords.some(keyword => identifier.includes(keyword));
        }

        async function buildAPIError(response) {
            let payload = null;
            try {
                payload = await response.json();
            } catch (e) {
                // Ignore JSON parse errors
            }

            const message = payload?.error?.message || `Server error (${response.status})`;
            const code = payload?.error?.code || null;
            const err = new Error(message);
            err.code = code;
            err.status = response.status;
            err.payload = payload;
            return err;
        }

        // Load messages from localStorage
        function loadMessages() {
            try {
                const saved = localStorage.getItem('offgrid_messages');
                const savedModel = localStorage.getItem('offgrid_current_model');
                const chatMessages = document.getElementById('chatMessages');
                
                if (saved) {
                    messages = JSON.parse(saved);
                    if (savedModel) {
                        currentModel = savedModel;
                    }
                    // Only render if there are actual messages
                    if (messages.length > 0) {
                        chatMessages.innerHTML = '';
                        messages.forEach(msg => {
                            if (msg.role === 'user' || msg.role === 'assistant') {
                                const { text, images } = normalizeMessageContent(msg.content);
                                addChatMessage(msg.role, text, images);
                            }
                        });
                    }
                    // If empty array, leave the initial placeholder
                    updateChatStats();
                }
                // If no saved messages, leave the initial placeholder
            } catch (e) {
                console.error('Failed to load messages:', e);
            }
        }

        // Tab switching
        function switchTab(tab) {
            document.querySelectorAll('[id^="content-"]').forEach(el => el.classList.add('hidden'));
            document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
            document.getElementById('content-' + tab).classList.remove('hidden');
            document.getElementById('tab-' + tab).classList.add('active');
            
            // Save current tab to localStorage
            localStorage.setItem('offgrid_active_tab', tab);
            
            if (tab === 'models') {
                loadInstalledModels();
                // Clear search input
                document.getElementById('searchQuery').value = '';
                document.getElementById('searchResults').innerHTML = '';
            }
            if (tab === 'chat') {
                loadChatModels();
                updateChatStats();
                renderSessions(); // Load sessions panel within chat
            }
            if (tab === 'knowledge') {
                loadRAGStatus();
                loadRAGEmbeddingModels();
                refreshRAGDocuments();
                loadEmbeddingModels(); // Load embedding models for embeddings section
            }
            if (tab === 'benchmark') {
                loadBenchmarkModels();
                loadSystemInfo();
                renderBenchmarkHistory();
            }
        }

        // Chat keyboard handler
        function handleChatKeydown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendChat();
            }
        }
        
        // Auto-resize textarea
        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 200) + 'px';
        }

        // Terminal keyboard handler
        function handleTerminalKeydown(event) {
            const input = event.target;
            
            if (event.key === 'Enter') {
                event.preventDefault();
                runCommand();
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    input.value = commandHistory[historyIndex] || '';
                }
            } else if (event.key === 'ArrowDown') {
                event.preventDefault();
                if (historyIndex > 0) {
                    historyIndex--;
                    input.value = commandHistory[historyIndex] || '';
                } else if (historyIndex === 0) {
                    historyIndex = -1;
                    input.value = '';
                }
            } else if (event.key === 'Tab') {
                event.preventDefault();
                autocompleteCommand(input);
            }
        }

        function autocompleteCommand(input) {
            const val = input.value;
            const commands = [
                'offgrid list',
                'offgrid recommend',
                'offgrid download ',
                'offgrid download-hf ',
                'offgrid remove ',
                'offgrid search ',
                'offgrid run ',
                'offgrid serve',
                'offgrid --help',
                'offgrid --version',
                'help',
                'clear',
                'history'
            ];
            const match = commands.find(cmd => cmd.startsWith(val));
            if (match) {
                input.value = match;
            }
        }

        function updateChatStats() {
            document.getElementById('messageCount').textContent = `${messages.length} messages`;
            const totalTokens = messages.reduce((sum, m) => sum + (m.content?.length || 0), 0);
            document.getElementById('tokenCount').textContent = `~${Math.ceil(totalTokens / 4)} tokens`;
        }

        // Load models for chat
        async function loadChatModels() {
            try {
                // Force refresh models from filesystem
                try {
                    await fetch('/models/refresh', { method: 'POST' });
                } catch (e) {
                    console.warn('Failed to refresh models, using cached list:', e);
                }
                
                const resp = await fetch('/models');
                const data = await resp.json();
                const models = data.data || [];
                
                // Load all models - both LLM and embedding models
                // We'll detect type and route to correct API when sending
                
                const select = document.getElementById('chatModel');
                
                // Remember the current selection before clearing
                const previousSelection = select.value || currentModel;
                
                select.innerHTML = '';
                
                if (models.length === 0) {
                    select.innerHTML = '<option value="">No LLM models available</option>';
                    return;
                }
                
                // Sort models alphabetically by ID
                models.sort((a, b) => a.id.localeCompare(b.id));
                console.log('[LOAD MODELS] Sorted LLM models:', models.map(m => m.id));
                
                models.forEach(m => {
                    const opt = document.createElement('option');
                    opt.value = m.id;
                    // Format display name: replace underscores and hyphens with spaces for readability
                    const displayName = m.id.replace(/_/g, ' ').replace(/-/g, ' ');
                    opt.textContent = displayName;
                    opt.title = m.id; // Show original name on hover
                    select.appendChild(opt);
                });
                
                // Restore previous selection, or auto-select first model if none selected
                if (previousSelection && models.some(m => m.id === previousSelection)) {
                    // Restore the previous selection
                    currentModel = previousSelection;
                    select.value = previousSelection;
                    console.log('[LOAD MODELS] Restored previous selection:', previousSelection);
                } else if (!currentModel && models.length > 0) {
                    // First time - select first model
                    currentModel = models[0].id;
                    select.value = currentModel;
                    console.log('[LOAD MODELS] Auto-selected first model:', currentModel);
                }

                // Add change handler after models are loaded
                select.onchange = null; // Clear any existing handler
                select.onchange = function(e) {
                    console.log('[DROPDOWN] Change event fired! Value:', e.target.value);
                    handleModelChange();
                };
                console.log('[LOAD MODELS] Event listener attached to dropdown via onchange');
            } catch (e) {
                console.error('Failed to load models:', e);
                document.getElementById('chatModel').innerHTML = '<option value="">Error loading models</option>';
            }
        }

        // Load embedding models
        async function loadEmbeddingModels() {
            try {
                // Force refresh models from filesystem
                try {
                    await fetch('/models/refresh', { method: 'POST' });
                } catch (e) {
                    console.warn('Failed to refresh models, using cached list:', e);
                }
                
                const resp = await fetch('/models');
                const data = await resp.json();
                const allModels = data.data || [];
                
                // Filter only embedding models
                const models = allModels.filter(m => {
                    return m.type === 'embedding' || m.tags?.includes('embedding');
                });
                
                const select = document.getElementById('embeddingModel');
                select.innerHTML = '';
                
                if (models.length === 0) {
                    select.innerHTML = '<option value="">No embedding models available</option>';
                    return;
                }
                
                // Sort models alphabetically by ID
                models.sort((a, b) => a.id.localeCompare(b.id));
                console.log('[LOAD EMBEDDING MODELS] Sorted models:', models.map(m => m.id));
                
                models.forEach(m => {
                    const opt = document.createElement('option');
                    opt.value = m.id;
                    const displayName = m.id.replace(/_/g, ' ').replace(/-/g, ' ');
                    opt.textContent = displayName;
                    opt.title = m.id;
                    select.appendChild(opt);
                });
                
                // Auto-select first model
                if (models.length > 0) {
                    select.value = models[0].id;
                }
            } catch (e) {
               
                console.error('Failed to load embedding models:', e);
                document.getElementById('embeddingModel').innerHTML = '<option value="">Error loading models</option>';
            }
        }

        // Generate embedding
        let currentEmbeddingData = null;
        
        async function generateEmbedding() {
            const model = document.getElementById('embeddingModel').value;
            const input = document.getElementById('embeddingInput').value.trim();
            const btn = document.getElementById('generateEmbeddingBtn');
            
            if (!model) {
                showModal({
                    type: 'warning',
                    title: 'Selection Required',
                    message: 'Please select an embedding model',
                    confirmText: 'OK'
                });
                return;
            }
            
            if (!input) {
                showModal({
                    type: 'warning',
                    title: 'Input Required',
                    message: 'Please enter text to embed',
                    confirmText: 'OK'
                });
                return;
            }
            
            btn.disabled = true;
            btn.textContent = 'Generating...';
            
            const startTime = Date.now();
            
            try {
                const response = await fetch('/v1/embeddings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: model,
                        input: input
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to generate embedding');
                }
                
                const data = await response.json();
                const endTime = Date.now();
                const timeMs = endTime - startTime;
                
                // Store the full embedding data
                currentEmbeddingData = data.data[0].embedding;
                
                // Display results
                displayEmbeddingResults(data, timeMs);
                
            } catch (error) {
                console.error('Embedding error:', error);
                showModal({
                    type: 'error',
                    title: 'Embedding Failed',
                    message: 'Failed to generate embedding: ' + error.message,
                    confirmText: 'OK'
                });
            } finally {
                btn.disabled = false;
                btn.textContent = 'Generate Embedding';
            }
        }
        
        function displayEmbeddingResults(data, timeMs) {
            const resultsDiv = document.getElementById('embeddingResults');
            const embedding = data.data[0].embedding;
            const dimensions = embedding.length;
            
            // Show results section
            resultsDiv.classList.remove('hidden');
            
            // Update stats
            document.getElementById('embeddingDimensions').textContent = dimensions;
            document.getElementById('embeddingTokens').textContent = data.usage?.prompt_tokens || '-';
            document.getElementById('embeddingTime').textContent = timeMs + 'ms';
            
            // Display first 100 values
            const preview = embedding.slice(0, 100);
            const previewText = '[' + preview.map(v => v.toFixed(6)).join(', ') + 
                              (dimensions > 100 ? ', ...' : '') + ']';
            document.getElementById('embeddingVector').textContent = previewText;
            
            // Store full vector for later display
            const fullText = '[' + embedding.map(v => v.toFixed(6)).join(', ') + ']';
            document.getElementById('embeddingVectorFull').textContent = fullText;
            
            // Reset toggle button
            document.getElementById('toggleVectorBtn').textContent = 'Show Full Vector';
            document.getElementById('fullVectorContainer').classList.add('hidden');
        }
        
        function toggleFullVector() {
            const container = document.getElementById('fullVectorContainer');
            const btn = document.getElementById('toggleVectorBtn');
            
            if (container.classList.contains('hidden')) {
                container.classList.remove('hidden');
                btn.textContent = 'Hide Full Vector';
            } else {
                container.classList.add('hidden');
                btn.textContent = 'Show Full Vector';
            }
        }
        
        function copyEmbedding() {
            if (!currentEmbeddingData) {
                showModal({
                    type: 'warning',
                    title: 'No Data',
                    message: 'No embedding to copy',
                    confirmText: 'OK'
                });
                return;
            }
            
            const text = '[' + currentEmbeddingData.map(v => v.toFixed(6)).join(', ') + ']';
            
            navigator.clipboard.writeText(text).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                showModal({
                    type: 'error',
                    title: 'Copy Failed',
                    message: 'Failed to copy to clipboard',
                    confirmText: 'OK'
                });
            });
        }
        
        function clearEmbedding() {
            document.getElementById('embeddingInput').value = '';
            document.getElementById('embeddingResults').classList.add('hidden');
            currentEmbeddingData = null;
        }

        // Wait for model to be fully loaded and ready
        async function waitForModelReady(modelName) {
            console.log('[HEALTH CHECK] Waiting for model to be ready:', modelName);
            const maxAttempts = 60; // 60 seconds max wait
            const pollInterval = 1000; // Check every second
            
            // Check if this is an embedding model
            const resp = await fetch('/models');
            const data = await resp.json();
            const modelInfo = data.data.find(m => m.id === modelName);
            // Check type from metadata, or fallback to name heuristics if metadata missing
            const isEmbeddingModel = modelInfo?.type === 'embedding' || 
                                   modelName.toLowerCase().includes('embed') || 
                                   modelName.toLowerCase().includes('bge') ||
                                   modelName.toLowerCase().includes('nomic');
            console.log('[HEALTH CHECK] Model type:', modelInfo?.type, 'Is embedding:', isEmbeddingModel);
            
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                    console.log(`[HEALTH CHECK] Attempt ${attempt}/${maxAttempts}`);
                    
                    let testResponse;
                    if (isEmbeddingModel) {
                        // For embedding models, use embeddings endpoint
                        testResponse = await fetch('/v1/embeddings', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                model: modelName,
                                input: 'test'
                            }),
                            signal: AbortSignal.timeout(5000)
                        });
                    } else {
                        // For LLM models, use chat completions endpoint
                        testResponse = await fetch('/v1/chat/completions', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                model: modelName,
                                messages: [{ role: 'user', content: 'test' }],
                                stream: false,
                                max_tokens: 1,
                                temperature: 0.1
                            }),
                            signal: AbortSignal.timeout(5000)
                        });
                    }
                    
                    console.log('[HEALTH CHECK] Response status:', testResponse.status);
                    
                    // If we get 200, model is ready
                    if (testResponse.ok) {
                        console.log('[HEALTH CHECK] Model is ready!');
                        return true;
                    }
                    
                    // If we get 503 or 500, model is still loading
                    if (testResponse.status === 503 || testResponse.status === 500) {
                        const errorData = await testResponse.json().catch(() => ({}));
                        console.log('[HEALTH CHECK] Model loading:', errorData.error || 'Still initializing...');
                    }
                    
                    console.log(`[HEALTH CHECK] Not ready yet, waiting ${pollInterval}ms...`);
                    await new Promise(resolve => setTimeout(resolve, pollInterval));
                    
                } catch (error) {
                    console.log(`[HEALTH CHECK] Error on attempt ${attempt}:`, error.message);
                    // Network errors or timeouts are expected while loading
                    await new Promise(resolve => setTimeout(resolve, pollInterval));
                }
            }
            
            console.warn('[HEALTH CHECK] Timeout after 60s - model may not be ready');
            return false; // Return false if timeout
        }

        // Handle model dropdown change
        async function handleModelChange() {
            const select = document.getElementById('chatModel');
            const newModel = select.value;
            
            console.log('[MODEL CHANGE] Dropdown changed to:', newModel);
            console.log('[MODEL CHANGE] Current model:', currentModel);
            
            if (!newModel) {
                console.log('[MODEL CHANGE] No model selected, ignoring');
                return;
            }
            
            // Don't switch if already on this model
            if (currentModel === newModel) {
                console.log('[MODEL CHANGE] Already using this model');
                return;
            }
            
            const oldModel = currentModel;
            
            // If there are existing messages, ask user what to do
            console.log('[MODEL CHANGE] Current message count:', messages.length);
            if (messages.length > 0) {
                console.log('[MODEL CHANGE] Showing confirmation dialog...');
                showModal({
                    type: 'warning',
                    title: 'Clear Chat History?',
                    message: `Switching from <strong>${oldModel || 'no model'}</strong> to <strong>${newModel}</strong>.<br><br>Clear chat history? The new model won't have context from previous messages.`,
                    confirmText: 'Start Fresh',
                    cancelText: 'Keep History',
                    onConfirm: () => {
                        console.log('[MODEL CHANGE] User response: CLEAR');
                        console.log('[MODEL CHANGE] Clearing chat history');
                        clearChatSilent();
                    },
                    onCancel: () => {
                        console.log('[MODEL CHANGE] User response: KEEP');
                        console.log('[MODEL CHANGE] Keeping chat history');
                    }
                });
            } else {
                console.log('[MODEL CHANGE] No messages, skipping confirmation');
            }
            
            currentModel = newModel;
            console.log('[MODEL CHANGE] Switching from', oldModel, 'to', newModel);

            // Check if VLM and toggle upload button
            try {
                const resp = await fetch('/models');
                const data = await resp.json();
                const modelInfo = data.data.find(m => m.id === newModel);
                const isVLM = modelSupportsVision(modelInfo, newModel);
                
                const imageUploadBtn = document.getElementById('imageUploadBtn');
                if (imageUploadBtn) {
                    if (isVLM) {
                        imageUploadBtn.classList.remove('hidden');
                    } else {
                        imageUploadBtn.classList.add('hidden');
                        clearAllImages(); // Clear any pending image if switching away from VLM
                    }
                }
            } catch (e) {
                console.error('Error checking model type:', e);
            }
            
            // Disable UI while loading model
            const chatInput = document.getElementById('chatInput');
            const sendBtn = document.getElementById('sendBtn');
            const statusBadge = document.getElementById('statusBadge');
            
            chatInput.disabled = true;
            sendBtn.disabled = true;
            statusBadge.className = 'text-xs font-medium text-yellow-400';
            
            // Show loading progress
            let loadingSeconds = 0;
            statusBadge.textContent = `Loading ${newModel}...`;
            const loadingInterval = setInterval(() => {
                loadingSeconds++;
                statusBadge.textContent = `Loading ${newModel}... ${loadingSeconds}s`;
            }, 1000);
            
            console.log('[MODEL CHANGE] Starting health check for', newModel);
            
            // Wait for model to be ready before allowing messages
            const isReady = await waitForModelReady(newModel);
            
            // Clear loading interval
            clearInterval(loadingInterval);
            
            if (isReady) {
                console.log('[MODEL CHANGE] Model ready - enabling UI');
                statusBadge.className = 'badge badge-success';
                statusBadge.textContent = `Ready (${newModel})`;
            } else {
                console.warn('[MODEL CHANGE] Model not confirmed ready - may have issues');
                statusBadge.className = 'badge badge-warning';
                statusBadge.textContent = `${newModel} (not confirmed)`;
            }
            
            // Re-enable UI
            chatInput.disabled = false;
            sendBtn.disabled = false;
            chatInput.focus();
            
            console.log('[MODEL CHANGE] Model switch complete - ready for messages');
        }

        // Modal dialog system
        function showModal({ type = 'info', title, message, confirmText = 'OK', cancelText, onConfirm, onCancel }) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const icon = type === 'error' ? 
                '<div class="w-12 h-12 rounded-full bg-red-100 text-red-500 flex items-center justify-center mb-4 mx-auto"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></div>' :
                type === 'warning' ?
                '<div class="w-12 h-12 rounded-full bg-yellow-100 text-yellow-500 flex items-center justify-center mb-4 mx-auto"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></div>' :
                '<div class="w-12 h-12 rounded-full bg-blue-100 text-blue-500 flex items-center justify-center mb-4 mx-auto"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>';

            const cancelButton = cancelText ? `<button class="btn btn-secondary" data-action="cancel">${cancelText}</button>` : '';
            
            overlay.innerHTML = `
                <div class="modal-dialog ${type}">
                    ${icon}
                    <h3 class="text-lg font-bold mb-2 text-center" style="color: var(--text-primary)">${title}</h3>
                    <p class="text-center mb-4" style="color: var(--text-secondary)">${message}</p>
                    <div class="flex justify-center gap-3">
                        ${cancelButton}
                        <button class="btn ${type === 'error' ? 'btn-danger' : 'btn-primary'}" data-action="confirm">${confirmText}</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Handle clicks
            overlay.addEventListener('click', (e) => {
                if (e.target.classList.contains('modal-overlay')) {
                    overlay.remove();
                    if (onCancel) onCancel();
                }
            });
            
            overlay.querySelector('[data-action="confirm"]')?.addEventListener('click', () => {
                overlay.remove();
                if (onConfirm) onConfirm();
            });
            
            overlay.querySelector('[data-action="cancel"]')?.addEventListener('click', () => {
                overlay.remove();
                if (onCancel) onCancel();
            });
        }

        // Simple alert dialog (replaces browser alert)
        function showAlert(message, type = 'info', title = null) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            // Auto-detect type from message content
            if (!title) {
                if (type === 'error' || message.toLowerCase().includes('failed') || message.toLowerCase().includes('error')) {
                    type = 'error';
                    title = 'Error';
                } else if (message.toLowerCase().includes('success') || message.toLowerCase().includes('added') || message.toLowerCase().includes('deleted')) {
                    type = 'success';
                    title = 'Success';
                } else if (message.toLowerCase().includes('please') || message.toLowerCase().includes('select') || message.toLowerCase().includes('enter')) {
                    type = 'warning';
                    title = 'Notice';
                } else {
                    title = 'Info';
                }
            }
            
            const icon = type === 'error' ? 
                '<div class="w-12 h-12 rounded-full bg-red-500/20 text-red-400 flex items-center justify-center mb-4 mx-auto"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg></div>' :
                type === 'warning' ?
                '<div class="w-12 h-12 rounded-full bg-yellow-500/20 text-yellow-400 flex items-center justify-center mb-4 mx-auto"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></div>' :
                type === 'success' ?
                '<div class="w-12 h-12 rounded-full bg-green-500/20 text-green-400 flex items-center justify-center mb-4 mx-auto"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg></div>' :
                '<div class="w-12 h-12 rounded-full bg-blue-500/20 text-blue-400 flex items-center justify-center mb-4 mx-auto"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>';

            overlay.innerHTML = `
                <div class="modal-dialog ${type}">
                    ${icon}
                    <h3 class="text-lg font-bold mb-2 text-center" style="color: var(--text-primary)">${title}</h3>
                    <p class="text-center mb-6" style="color: var(--text-secondary)">${message}</p>
                    <div class="flex justify-center">
                        <button class="btn btn-primary px-8" data-action="ok">OK</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Focus the OK button
            overlay.querySelector('[data-action="ok"]').focus();
            
            // Handle clicks
            overlay.addEventListener('click', (e) => {
                if (e.target.classList.contains('modal-overlay') || e.target.dataset.action === 'ok') {
                    overlay.remove();
                }
            });
            
            // Handle Enter/Escape keys
            const handleKey = (e) => {
                if (e.key === 'Enter' || e.key === 'Escape') {
                    overlay.remove();
                    document.removeEventListener('keydown', handleKey);
                }
            };
            document.addEventListener('keydown', handleKey);
        }

        // Confirmation dialog system (replaces native confirm())
        function showConfirm(message, onConfirm, options = {}) {
            const title = options.title || 'Confirm';
            const confirmText = options.confirmText || 'OK';
            const cancelText = options.cancelText || 'Cancel';
            const type = options.type || 'info';
            
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            // Icon based on type
            const icons = {
                error: '<div class="w-12 h-12 rounded-full bg-red-500/20 text-red-400 flex items-center justify-center mb-4 mx-auto"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg></div>',
                warning: '<div class="w-12 h-12 rounded-full bg-yellow-500/20 text-yellow-400 flex items-center justify-center mb-4 mx-auto"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></div>',
                success: '<div class="w-12 h-12 rounded-full bg-green-500/20 text-green-400 flex items-center justify-center mb-4 mx-auto"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg></div>',
                info: '<div class="w-12 h-12 rounded-full bg-blue-500/20 text-blue-400 flex items-center justify-center mb-4 mx-auto"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>'
            };
            const icon = icons[type] || icons.info;
            
            // Button style based on type
            const btnStyles = {
                error: 'bg-red-600 hover:bg-red-700 text-white',
                warning: 'bg-yellow-600 hover:bg-yellow-700 text-white',
                success: 'bg-green-600 hover:bg-green-700 text-white',
                info: 'bg-blue-600 hover:bg-blue-700 text-white'
            };
            const btnStyle = btnStyles[type] || btnStyles.info;

            overlay.innerHTML = `
                <div class="modal-dialog ${type}">
                    ${icon}
                    <h3 class="text-lg font-bold mb-2 text-center" style="color: var(--text-primary)">${title}</h3>
                    <p class="text-center mb-6" style="color: var(--text-secondary)">${message}</p>
                    <div class="flex justify-center gap-3">
                        <button class="btn btn-secondary px-6" data-action="cancel">${cancelText}</button>
                        <button class="btn px-6 ${btnStyle}" data-action="confirm">${confirmText}</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Focus the confirm button
            overlay.querySelector('[data-action="confirm"]').focus();
            
            // Handle clicks
            overlay.addEventListener('click', (e) => {
                if (e.target.classList.contains('modal-overlay') || e.target.dataset.action === 'cancel') {
                    overlay.remove();
                } else if (e.target.dataset.action === 'confirm') {
                    overlay.remove();
                    if (onConfirm) onConfirm();
                }
            });
            
            // Handle Enter/Escape keys
            const handleKey = (e) => {
                if (e.key === 'Escape') {
                    overlay.remove();
                    document.removeEventListener('keydown', handleKey);
                } else if (e.key === 'Enter') {
                    overlay.remove();
                    document.removeEventListener('keydown', handleKey);
                    if (onConfirm) onConfirm();
                }
            };
            document.addEventListener('keydown', handleKey);
        }

        // Prompt dialog system
        function showPrompt({ title, message, defaultValue = '', placeholder = '', confirmText = 'OK', cancelText = 'Cancel', onConfirm, onCancel }) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            overlay.innerHTML = `
                <div class="modal-dialog">
                    <h3 class="text-lg font-bold mb-2 text-center" style="color: var(--text-primary)">${title}</h3>
                    <p class="text-center mb-4" style="color: var(--text-secondary)">${message}</p>
                    <input type="text" class="input-theme w-full p-2 mb-6" value="${defaultValue}" placeholder="${placeholder}" id="promptInput">
                    <div class="flex justify-center gap-3">
                        <button class="btn btn-secondary" data-action="cancel">${cancelText}</button>
                        <button class="btn btn-primary" data-action="confirm">${confirmText}</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            const input = overlay.querySelector('#promptInput');
            input.focus();
            // Select all text if there is a default value
            if (defaultValue) input.select();

            // Handle Enter key
            input.addEventListener('keyup', (e) => {
                if (e.key === 'Enter') {
                    const value = input.value;
                    overlay.remove();
                    if (onConfirm) onConfirm(value);
                }
            });
            
            // Handle clicks
            overlay.addEventListener('click', (e) => {
                if (e.target.classList.contains('modal-overlay')) {
                    overlay.remove();
                    if (onCancel) onCancel();
                }
            });
            
            overlay.querySelector('[data-action="confirm"]')?.addEventListener('click', () => {
                const value = input.value;
                overlay.remove();
                if (onConfirm) onConfirm(value);
            });
            
            overlay.querySelector('[data-action="cancel"]')?.addEventListener('click', () => {
                overlay.remove();
                if (onCancel) onCancel();
            });
        }

        // New chat - offer to save current session first
        function newChat() {
            if (messages.length === 0) {
                // No messages, just reset
                resetChatUI();
                return;
            }
            
            // Show custom 3-button dialog
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            const msgCount = messages.length;
            
            overlay.innerHTML = `
                <div class="modal-dialog warning" style="max-width: 480px;">
                    <div class="w-12 h-12 rounded-full bg-yellow-500/20 text-yellow-400 flex items-center justify-center mb-4 mx-auto">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                            <line x1="12" y1="9" x2="12" y2="13"></line>
                            <line x1="12" y1="17" x2="12.01" y2="17"></line>
                        </svg>
                    </div>
                    <h3 class="text-lg font-bold mb-2 text-center" style="color: var(--text-primary)">Start New Chat?</h3>
                    <p class="text-center mb-4" style="color: var(--text-secondary)">You have <strong>${msgCount} messages</strong> in the current conversation.</p>
                    <div class="flex gap-2 justify-center">
                        <button class="btn btn-secondary" data-action="cancel">Cancel</button>
                        <button class="btn btn-primary" data-action="save-new">Save & New</button>
                        <button class="btn btn-secondary" data-action="new">New Chat</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Handle clicks
            overlay.addEventListener('click', (e) => {
                if (e.target.classList.contains('modal-overlay')) {
                    overlay.remove();
                }
            });
            
            overlay.querySelector('[data-action="save-new"]')?.addEventListener('click', () => {
                overlay.remove();
                // Save with callback to reset after save completes
                saveSessionAndThen(() => {
                    resetChatUI();
                });
            });
            
            overlay.querySelector('[data-action="new"]')?.addEventListener('click', () => {
                overlay.remove();
                resetChatUI();
            });
            
            overlay.querySelector('[data-action="cancel"]')?.addEventListener('click', () => {
                overlay.remove();
            });
        }
        
        // Save session with a callback after completion
        function saveSessionAndThen(onComplete) {
            if (messages.length === 0) {
                if (onComplete) onComplete();
                return;
            }
            
            // Copy messages before any reset happens
            const messagesToSave = [...messages];
            const modelToSave = currentModel;
            const systemPromptToSave = currentSystemPrompt;
            const sessionIdToSave = currentSessionId;
            
            showPrompt({
                title: 'Save Session',
                message: 'Enter a title for this session:',
                defaultValue: `Chat ${new Date().toLocaleDateString()}`,
                confirmText: 'Save',
                onConfirm: (title) => {
                    if (!title) {
                        if (onComplete) onComplete();
                        return;
                    }
                    
                    const session = {
                        id: sessionIdToSave || Date.now(),
                        title: title,
                        model: modelToSave,
                        messages: messagesToSave,
                        systemPrompt: systemPromptToSave,
                        timestamp: new Date().toISOString(),
                        messageCount: messagesToSave.length
                    };
                    
                    const existingIndex = sessions.findIndex(s => s.id === session.id);
                    if (existingIndex >= 0) {
                        sessions[existingIndex] = session;
                    } else {
                        sessions.unshift(session);
                    }
                    
                    localStorage.setItem('offgrid_sessions', JSON.stringify(sessions));
                    renderSessionsList();
                    
                    if (onComplete) onComplete();
                },
                onCancel: () => {
                    // User cancelled save, don't proceed with new chat
                }
            });
        }

        // Reset chat UI to initial state
        function resetChatUI() {
            messages = [];
            currentSessionId = null;
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.innerHTML = `
                <div class="text-center text-secondary py-32">
                    <p class="text-xl font-medium">Start a conversation</p>
                    <p class="text-sm mt-2">Select a model and type your message below</p>
                </div>
            `;
            document.getElementById('chatInput').value = '';
            updateChatStats();
            saveMessages();
        }

        // Clear chat (legacy, now redirects to newChat)
        function clearChat() {
            newChat();
        }

        // Export chat with enhanced options
        function showExportOptions() {
            if (messages.length === 0) {
                showModal({
                    type: 'warning',
                    title: 'No Messages',
                    message: 'There are no messages to export yet.',
                    confirmText: 'OK',
                    cancelText: null
                });
                return;
            }
            
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            overlay.innerHTML = `
                <div class="modal-dialog">
                    <h3 class="text-lg font-bold mb-4 text-center" style="color: var(--text-primary)">Export Chat</h3>
                    <p class="text-center mb-6" style="color: var(--text-secondary)">Choose a format for your export:</p>
                    <div class="flex flex-col gap-3">
                        <button class="btn btn-secondary w-full justify-start p-4" data-format="1">
                            <div class="text-left">
                                <div class="font-bold text-base mb-1" style="color: var(--text-primary)">Markdown</div>
                                <div class="text-xs opacity-70" style="color: var(--text-secondary)">Best for research & reading</div>
                            </div>
                        </button>
                        <button class="btn btn-secondary w-full justify-start p-4" data-format="2">
                            <div class="text-left">
                                <div class="font-bold text-base mb-1" style="color: var(--text-primary)">Plain Text</div>
                                <div class="text-xs opacity-70" style="color: var(--text-secondary)">Simple text file</div>
                            </div>
                        </button>
                        <button class="btn btn-secondary w-full justify-start p-4" data-format="3">
                            <div class="text-left">
                                <div class="font-bold text-base mb-1" style="color: var(--text-primary)">JSON</div>
                                <div class="text-xs opacity-70" style="color: var(--text-secondary)">For programmatic use</div>
                            </div>
                        </button>
                    </div>
                    <div class="flex justify-center mt-6">
                        <button class="btn btn-secondary" data-action="cancel">Cancel</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            const handleExport = (format) => {
                overlay.remove();
                processExport(format);
            };

            overlay.querySelectorAll('[data-format]').forEach(btn => {
                btn.addEventListener('click', () => handleExport(btn.dataset.format));
            });
            
            overlay.querySelector('[data-action="cancel"]').addEventListener('click', () => {
                overlay.remove();
            });
            
            overlay.addEventListener('click', (e) => {
                if (e.target.classList.contains('modal-overlay')) {
                    overlay.remove();
                }
            });
        }

        function processExport(format) {
            if (!format) return;
            
            let content, mimeType, extension;
            const timestamp = new Date().toISOString().split('T')[0];
            const filename = `chat-${currentModel}-${timestamp}`;
            
            if (format === '1') {
                // Markdown format with code blocks
                content = `# Chat with ${currentModel}\n**Date:** ${new Date().toLocaleString()}\n**Messages:** ${messages.length}\n\n---\n\n`;
                messages.forEach(m => {
                    content += `## ${m.role === 'user' ? 'User' : 'Assistant'}\n\n`;
                    // Detect and format code blocks
                    const hasCode = m.content.includes('```');
                    content += hasCode ? m.content : m.content.replace(/`([^`]+)`/g, '`$1`');
                    content += '\n\n---\n\n';
                });
                mimeType = 'text/markdown';
                extension = 'md';
            } else if (format === '3') {
                // JSON format for programmatic access
                content = JSON.stringify({
                    model: currentModel,
                    timestamp: new Date().toISOString(),
                    messageCount: messages.length,
                    messages: messages
                }, null, 2);
                mimeType = 'application/json';
                extension = 'json';
            } else {
                // Plain text
                content = messages.map(m => `${m.role.toUpperCase()}: ${m.content}`).join('\n\n');
                mimeType = 'text/plain';
                extension = 'txt';
            }
            
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename}.${extension}`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // System prompt functions
        function applySystemPrompt() {
            const select = document.getElementById('systemPrompt');
            const value = select.value;
            
            if (value === 'custom') {
                showPrompt({
                    title: 'Custom System Prompt',
                    message: 'Enter your custom system prompt:',
                    placeholder: 'You are a helpful assistant...',
                    confirmText: 'Apply',
                    onConfirm: (custom) => {
                        if (custom) {
                            currentSystemPrompt = custom;
                            showModal({
                                type: 'success',
                                title: 'Success',
                                message: 'Custom prompt applied',
                                confirmText: 'OK'
                            });
                        }
                    },
                    onCancel: () => {
                        select.value = ''; // Reset selection
                    }
                });
            } else if (value) {
                currentSystemPrompt = systemPrompts[value];
                showModal({
                    type: 'success',
                    title: 'Success',
                    message: `${select.options[select.selectedIndex].text} mode activated`,
                    confirmText: 'OK'
                });
            } else {
                currentSystemPrompt = '';
            }
        }

        // Session Management Functions
        function saveCurrentSession() {
            if (messages.length === 0) {
                showModal({
                    type: 'error',
                    title: 'Cannot Save',
                    message: 'No messages to save',
                    confirmText: 'OK'
                });
                return;
            }
            
            showPrompt({
                title: 'Save Session',
                message: 'Enter a title for this session:',
                defaultValue: `Chat ${new Date().toLocaleDateString()}`,
                confirmText: 'Save',
                onConfirm: (title) => {
                    if (!title) return;
                    
                    const session = {
                        id: currentSessionId || Date.now(),
                        title: title,
                        model: currentModel,
                        messages: [...messages],
                        systemPrompt: currentSystemPrompt,
                        timestamp: new Date().toISOString(),
                        messageCount: messages.length
                    };
                    
                    const existingIndex = sessions.findIndex(s => s.id === session.id);
                    if (existingIndex >= 0) {
                        sessions[existingIndex] = session;
                    } else {
                        sessions.unshift(session);
                        currentSessionId = session.id;
                    }
                    
                    localStorage.setItem('offgrid_sessions', JSON.stringify(sessions));
                    showModal({
                        type: 'success',
                        title: 'Saved',
                        message: 'Session saved successfully',
                        confirmText: 'OK'
                    });
                    renderSessionsList();
                }
            });
        }

        // Toggle sessions panel in chat tab
        function toggleSessionsPanel() {
            const panel = document.getElementById('sessionsPanel');
            panel.classList.toggle('hidden');
            if (!panel.classList.contains('hidden')) {
                renderSessions();
            }
        }

        // Toggle embeddings section in knowledge tab
        function toggleEmbeddingsSection() {
            const content = document.getElementById('embeddingsContent');
            const icon = document.getElementById('embeddingsSectionIcon');
            content.classList.toggle('hidden');
            icon.style.transform = content.classList.contains('hidden') ? '' : 'rotate(180deg)';
        }

        function renderSessions() {
            const container = document.getElementById('sessionsList');
            
            if (sessions.length === 0) {
                container.innerHTML = '<p class="text-xs text-secondary text-center py-4">No saved sessions yet.</p>';
                return;
            }
            
            container.innerHTML = sessions.map(session => `
                <div class="p-2 rounded bg-tertiary hover:bg-white/5 cursor-pointer transition-colors group" data-session-id="${session.id}">
                    <div class="flex items-start justify-between gap-2">
                        <div class="flex-1 min-w-0" onclick="loadSession(${session.id})">
                            <h4 class="font-medium text-sm text-accent truncate">${session.title}</h4>
                            <p class="text-xs text-secondary mt-0.5">
                                ${session.messageCount} messages • ${new Date(session.timestamp).toLocaleDateString()}
                            </p>
                        </div>
                        <button onclick="deleteSession(${session.id}); event.stopPropagation();" 
                                class="opacity-0 group-hover:opacity-100 p-1 hover:bg-red-500/20 rounded text-red-400 transition-opacity"
                                title="Delete session">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                        </button>
                    </div>
                </div>
            `).join('');
        }

        function loadSession(id) {
            const session = sessions.find(s => s.id === id);
            if (!session) return;
            
            if (messages.length > 0) {
                showModal({
                    type: 'warning',
                    title: 'Load Session?',
                    message: 'Current chat will be replaced. Continue?',
                    confirmText: 'Load Session',
                    cancelText: 'Cancel',
                    onConfirm: () => {
                        messages = [...session.messages];
                        currentModel = session.model;
                        currentSessionId = session.id;
                        currentSystemPrompt = session.systemPrompt || '';
                        
                        // Update UI
                        document.getElementById('chatModel').value = currentModel;
                        const chatMessages = document.getElementById('chatMessages');
                        chatMessages.innerHTML = '';
                        messages.forEach(m => {
                            const { text, images } = normalizeMessageContent(m.content);
                            addChatMessage(m.role, text, images);
                        });
                        
                        // Close sessions panel after loading
                        document.getElementById('sessionsPanel').classList.add('hidden');
                        switchTab('chat');
                        showModal({
                            type: 'success',
                            title: 'Loaded',
                            message: `Session loaded: "${session.title}"`,
                            confirmText: 'OK'
                        });
                    }
                });
                return;
            }
            
            messages = [...session.messages];
            currentModel = session.model;
            currentSessionId = session.id;
            currentSystemPrompt = session.systemPrompt || '';
            
            // Update UI
            document.getElementById('chatModel').value = currentModel;
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.innerHTML = '';
            messages.forEach(m => {
                const { text, images } = normalizeMessageContent(m.content);
                addChatMessage(m.role, text, images);
            });
            
            // Close sessions panel after loading
            document.getElementById('sessionsPanel').classList.add('hidden');
            switchTab('chat');
        }

        function deleteSession(id) {
            showModal({
                type: 'error',
                title: 'Delete Session?',
                message: `This action cannot be undone.`,
                confirmText: 'Delete',
                cancelText: 'Cancel',
                onConfirm: () => {
                    sessions = sessions.filter(s => s.id !== id);
                    localStorage.setItem('offgrid_sessions', JSON.stringify(sessions));
                    
                    if (currentSessionId === id) {
                        currentSessionId = null;
                    }
                    
                    renderSessions();
                }
            });
        }

        function createNewSession() {
            if (messages.length > 0) {
                showModal({
                    type: 'warning',
                    title: 'Start New Session?',
                    message: 'Current chat will be cleared.',
                    confirmText: 'New Session',
                    cancelText: 'Cancel',
                    onConfirm: () => {
                        clearChatSilent();
                        currentSessionId = null;
                        switchTab('chat');
                        showModal({
                            type: 'success',
                            title: 'New Session',
                            message: 'New session started',
                            confirmText: 'OK'
                        });
                    }
                });
                return;
            }
            
            clearChatSilent();
            currentSessionId = null;
            switchTab('chat');
            showModal({
                type: 'success',
                title: 'New Session',
                message: 'New session started',
                confirmText: 'OK'
            });
        }

        function filterSessions() {
            const query = document.getElementById('sessionSearch').value.toLowerCase();
            const sessionCards = document.querySelectorAll('[data-session-id]');
            
            sessionCards.forEach(card => {
                const text = card.textContent.toLowerCase();
                card.style.display = text.includes(query) ? 'block' : 'none';
            });
        }

        function clearChatSilent() {
            messages = [];
            document.getElementById('chatMessages').innerHTML = `
                <div class="text-center text-secondary py-20">
                    <p>Start a conversation</p>
                    <p class="text-xs mt-2 text-secondary">Select a model and type below</p>
                </div>
            `;
            document.getElementById('chatInput').value = '';
            updateChatStats();
            saveMessages();
        }

        // Stop generation
        function stopGeneration() {
            console.log('[STOP] Stopping generation...');
            if (abortController) {
                abortController.abort();
                abortController = null;
            }
            resetChatState();
        }
        
        // Reset chat state (useful for debugging stuck states)
        function resetChatState() {
            console.log('[RESET STATE] Resetting all chat state flags');
            isGenerating = false;
            pendingRequest = false;
            const sendBtn = document.getElementById('sendBtn');
            const stopBtn = document.getElementById('stopBtn');
            const chatInput = document.getElementById('chatInput');
            const statusBadge = document.getElementById('statusBadge');
            
            if (sendBtn) sendBtn.disabled = false;
            if (stopBtn) stopBtn.classList.add('hidden');
            if (chatInput) chatInput.disabled = false;
            if (statusBadge) {
                statusBadge.className = 'badge badge-success';
                statusBadge.textContent = currentModel ? `Ready (${currentModel})` : 'Ready';
            }
            
            console.log('[RESET STATE] State reset complete');
        }
        
        // Make resetChatState globally accessible for debugging
        window.resetChatState = resetChatState;
        
        // Make handleModelChange globally accessible for manual testing
        window.handleModelChange = handleModelChange;
        window.testModelSwitch = function(modelName) {
            console.log('[TEST] Manually switching to:', modelName);
            const select = document.getElementById('chatModel');
            select.value = modelName;
            handleModelChange();
        };

        // Image handling
        const MAX_IMAGE_ATTACHMENTS = 5;
        let imageAttachments = [];
        let nextImageAttachmentId = 1;

        function handleImageUpload(event) {
            const files = Array.from(event.target.files || []);
            if (!files.length) return;

            const remainingSlots = MAX_IMAGE_ATTACHMENTS - imageAttachments.length;
            if (remainingSlots <= 0) {
                showToast(`Maximum of ${MAX_IMAGE_ATTACHMENTS} images reached`, 'error');
                event.target.value = '';
                return;
            }

            const filesToProcess = files.slice(0, remainingSlots);
            if (files.length > filesToProcess.length) {
                showToast(`Only ${remainingSlots} more image${remainingSlots === 1 ? '' : 's'} allowed`, 'warning');
            }

            filesToProcess.forEach(file => {
                if (file.size > 10 * 1024 * 1024) {
                    showToast(`${file.name} is larger than 10MB`, 'error');
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(e) {
                    // Convert to JPEG to ensure compatibility with llama.cpp (stb_image)
                    const img = new Image();
                    img.onload = function() {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        // Fill white background for transparent images (PNG/WebP)
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(img, 0, 0);
                        
                        // Convert to JPEG
                        const jpegUrl = canvas.toDataURL('image/jpeg', 0.95);
                        
                        imageAttachments.push({
                            id: nextImageAttachmentId++,
                            name: file.name.replace(/\.[^/.]+$/, "") + ".jpg",
                            url: jpegUrl
                        });
                        updateImagePreview();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });

            // Reset input so same files can be selected again
            event.target.value = '';
        }

        function updateImagePreview() {
            const preview = document.getElementById('imagePreview');
            const list = document.getElementById('imagePreviewList');
            const countLabel = document.getElementById('imageAttachmentCount');

            if (!preview || !list || !countLabel) return;

            list.innerHTML = '';

            if (imageAttachments.length === 0) {
                preview.classList.add('hidden');
                countLabel.textContent = '0 attachments';
                return;
            }

            preview.classList.remove('hidden');
            countLabel.textContent = `${imageAttachments.length} attachment${imageAttachments.length === 1 ? '' : 's'}`;

            imageAttachments.forEach(att => {
                const wrapper = document.createElement('div');
                wrapper.className = 'relative group';
                const altText = escapeAttribute(att.name || 'Attachment');
                const imageUrl = escapeAttribute(att.url);
                wrapper.innerHTML = `
                    <img src="${imageUrl}" alt="${altText}" class="h-24 w-24 object-cover rounded-lg border border-white/10 shadow-sm">
                    <button type="button" onclick="removeImageAttachment(${att.id})" class="absolute -top-2 -right-2 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs hover:bg-red-600 shadow-md opacity-0 group-hover:opacity-100 transition-opacity">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                    </button>`;
                list.appendChild(wrapper);
            });
        }

        function removeImageAttachment(id) {
            imageAttachments = imageAttachments.filter(att => att.id !== id);
            updateImagePreview();
        }

        function clearAllImages() {
            imageAttachments = [];
            updateImagePreview();
        }

        // Send chat message with streaming
        async function sendChat() {
            console.log('[SEND CHAT] Function called');
            console.log('[SEND CHAT] Flags - isGenerating:', isGenerating, 'pendingRequest:', pendingRequest);
            
            const input = document.getElementById('chatInput');
            const msg = input.value.trim();

            if (!msg && imageAttachments.length === 0) {
                return;
            }

            // Prevent rapid-fire requests
            if (isGenerating || pendingRequest) {
                console.warn('[SEND CHAT] Request already in progress, ignoring...');
                // If stuck, reset after 30 seconds
                const now = Date.now();
                if (lastRequestTime && (now - lastRequestTime) > 30000) {
                    console.warn('[SEND CHAT] Flags stuck for >30s, force resetting...');
                    isGenerating = false;
                    pendingRequest = false;
                } else {
                    return;
                }
            }
            
            lastRequestTime = Date.now();
            pendingRequest = true;
            console.log('[SEND CHAT] Set pendingRequest = true');

            const model = document.getElementById('chatModel').value;
            console.log('[SEND CHAT] Selected model from dropdown:', model);
            console.log('[SEND CHAT] Current model variable:', currentModel);
            console.log('[SEND CHAT] Dropdown element value:', document.getElementById('chatModel').value);
            
            // Check if this is an embedding model
            const resp = await fetch('/models');
            const data = await resp.json();
            console.log('[SEND CHAT] ALL MODELS DATA:', JSON.stringify(data.data, null, 2));
            const modelInfo = data.data.find(m => m.id === model);
            console.log('[SEND CHAT] Found model info:', JSON.stringify(modelInfo, null, 2));
            // Check type from metadata, or fallback to name heuristics if metadata missing
            const isEmbeddingModel = modelInfo?.type === 'embedding' || 
                                   model.toLowerCase().includes('embed') || 
                                   model.toLowerCase().includes('bge') ||
                                   model.toLowerCase().includes('nomic');
            console.log('[SEND CHAT] Model type:', modelInfo?.type, 'Is embedding:', isEmbeddingModel);
            const supportsVision = modelSupportsVision(modelInfo, model);
            console.log('[SEND CHAT] Supports vision:', supportsVision);
            
            if (!model) {
                console.log('[SEND CHAT] No model selected!');
                pendingRequest = false; // Clear flag
                const statusBadge = document.getElementById('statusBadge');
                statusBadge.className = 'badge badge-warning';
                statusBadge.textContent = 'Select Model';
                setTimeout(() => {
                    statusBadge.className = 'badge badge-success';
                    statusBadge.textContent = 'Ready';
                }, 3000);
                return;
            }

            // ALWAYS sync currentModel with dropdown before sending
            currentModel = model;
            console.log('[SEND CHAT] Synced currentModel to:', currentModel);

            const sendBtn = document.getElementById('sendBtn');
            const stopBtn = document.getElementById('stopBtn');
            const streamEnabled = document.getElementById('streamToggle').checked;
            const temperature = parseFloat(document.getElementById('temperature').value);
            const maxTokens = parseInt(document.getElementById('maxTokens').value);

            isGenerating = true;
            input.disabled = true;
            sendBtn.disabled = true;
            stopBtn.classList.remove('hidden');

            // Handle VLM content
            let messageContent = msg;
            let inlineImages = [];
            if (imageAttachments.length > 0) {
                if (!supportsVision) {
                    showToast('Selected model does not support image input', 'error');
                    pendingRequest = false;
                    isGenerating = false;
                    input.disabled = false;
                    sendBtn.disabled = false;
                    stopBtn.classList.add('hidden');
                    return;
                }
                inlineImages = imageAttachments.map(att => att.url);
                messageContent = [
                    { type: "text", text: msg },
                    ...inlineImages.map(url => {
                        // Convert WebP to JPEG if needed, or just strip the prefix if llama-server expects raw base64
                        // But standard OpenAI API expects data URI.
                        // The issue is likely that llama-server's stb_image doesn't support WebP.
                        // We should convert to JPEG/PNG before sending.
                        // For now, let's try to ensure it's a format stb_image supports (JPEG/PNG).
                        return {
                            type: "image_url",
                            image_url: { url }
                        };
                    })
                ];
            }

            messages.push({ role: 'user', content: messageContent });
            addChatMessage('user', msg, inlineImages);
            
            // Clear image attachments after adding to chat
            clearAllImages();
            
            input.value = '';
            updateChatStats();
            saveMessages();
            scrollToBottom();

            // Show thinking indicator immediately after user message
            const thinkingIndicator = addThinkingIndicator();

            const statusBadge = document.getElementById('statusBadge');
            statusBadge.className = 'text-xs font-medium text-yellow-400';
            
            // Show loading indicator with elapsed time
            let loadingInterval;
            let elapsedSeconds = 0;
            statusBadge.textContent = 'Loading model...';
            loadingInterval = setInterval(() => {
                elapsedSeconds++;
                if (elapsedSeconds < 60) {
                    statusBadge.textContent = `Loading model... ${elapsedSeconds}s`;
                } else {
                    const mins = Math.floor(elapsedSeconds / 60);
                    const secs = elapsedSeconds % 60;
                    statusBadge.textContent = `Loading model... ${mins}m ${secs}s`;
                }
            }, 1000);

            abortController = new AbortController();
            const startTime = Date.now();

            // Prepare messages with system prompt if present
            let apiMessages = [...messages];
            if (currentSystemPrompt && currentSystemPrompt.trim()) {
                // Check if first message is already a system message
                if (apiMessages.length === 0 || apiMessages[0].role !== 'system') {
                    apiMessages = [{ role: 'system', content: currentSystemPrompt }, ...apiMessages];
                }
            }

            try {
                // If it's an embedding model, use embeddings API
                if (isEmbeddingModel) {
                    console.log('[SEND CHAT] Routing to embeddings API for embedding model');
                    const embeddingResponse = await fetch('/v1/embeddings', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ model: model, input: msg }),
                        signal: abortController.signal
                    });
                    
                    if (!embeddingResponse.ok) {
                        let errorDetails = '';
                        try {
                            const errorData = await embeddingResponse.json();
                            errorDetails = errorData.error?.message || JSON.stringify(errorData);
                        } catch (e) {
                            errorDetails = embeddingResponse.statusText;
                        }
                        throw new Error(`Server error (${embeddingResponse.status}): ${errorDetails}`);
                    }
                    
                    const embeddingData = await embeddingResponse.json();
                    const embedding = embeddingData.data[0].embedding;
                    const dimensions = embedding.length;
                    
                    // Remove thinking indicator
                    if (thinkingIndicator) {
                        thinkingIndicator.remove();
                    }
                    
                    // Display embedding result as a message
                    const embeddingText = `**Embedding Generated**\n\n` +
                        `**Dimensions:** ${dimensions}\n` +
                        `**First 10 values:** [${embedding.slice(0, 10).map(v => v.toFixed(4)).join(', ')}...]\n\n` +
                        `<details>\n<summary>View full embedding vector (${dimensions} dimensions)</summary>\n\n\`\`\`json\n${JSON.stringify(embedding, null, 2)}\n\`\`\`\n</details>`;
                    
                    addChatMessage('assistant', embeddingText, null, startTime);
                    updateChatStats();
                    saveMessages();
                    
                    if (loadingInterval) clearInterval(loadingInterval);
                    statusBadge.className = 'text-xs font-medium text-green-400';
                    statusBadge.textContent = 'Ready';
                    isGenerating = false;
                    pendingRequest = false;
                    input.disabled = false;
                    sendBtn.disabled = false;
                    stopBtn.classList.add('hidden');
                    scrollToBottom();
                    return;
                }
                
                const requestPayload = {
                    model: model,
                    messages: apiMessages,
                    stream: streamEnabled,
                    temperature: temperature,
                    max_tokens: maxTokens,
                    use_knowledge_base: document.getElementById('useKnowledgeBase').checked
                };
                
                console.log('[SEND CHAT] REQUEST PAYLOAD:', JSON.stringify(requestPayload, null, 2));
                console.log('[SEND CHAT] Model being sent:', model);
                console.log('[SEND CHAT] Knowledge Base enabled:', document.getElementById('useKnowledgeBase').checked);
                
                const response = await fetch('/v1/chat/completions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestPayload),
                    signal: abortController.signal
                });

                if (!response.ok) {
                    throw await buildAPIError(response);
                }

                if (streamEnabled) {
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let assistantMsg = '';
                    let msgDiv = null;
                    let firstTokenReceived = false;

                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n').filter(line => line.trim() !== '');

                        for (const line of lines) {
                            if (!line.startsWith('data: ')) continue;
                            const data = line.slice(6);
                            if (data === '[DONE]') continue;

                            try {
                                const json = JSON.parse(data);

                                if (json.error) {
                                    const streamError = new Error(json.error.message || 'Stream error');
                                    streamError.code = json.error.code || json.error.type || null;
                                    throw streamError;
                                }

                                const content = json.choices?.[0]?.delta?.content || '';
                                if (content) {
                                    // Remove thinking indicator on first token
                                    if (!firstTokenReceived && thinkingIndicator) {
                                        thinkingIndicator.remove();
                                        firstTokenReceived = true;
                                    }
                                    
                                    if (loadingInterval) {
                                        clearInterval(loadingInterval);
                                        loadingInterval = null;
                    statusBadge.textContent = 'Generating...';
                                    }
                                    
                                    assistantMsg += content;
                                    if (!msgDiv) {
                                        msgDiv = addChatMessage('assistant', '', null, startTime);
                                    }
                                    const contentDiv = msgDiv.querySelector('.message-content');
                                    contentDiv.innerHTML = marked.parse(assistantMsg);
                                    contentDiv.querySelectorAll('pre code').forEach((block) => {
                                        hljs.highlightElement(block);
                                    });
                                    scrollToBottom();
                                }
                            } catch (streamErr) {
                                if (streamErr instanceof SyntaxError) {
                                    continue; // Wait for more data
                                }
                                throw streamErr;
                            }
                        }
                    }

                    // Remove thinking indicator if still present
                    if (thinkingIndicator) {
                        thinkingIndicator.remove();
                    }

                    if (assistantMsg) {
                        messages.push({ role: 'assistant', content: assistantMsg });
                        const elapsed = Date.now() - startTime;
                        msgDiv.querySelector('.time-badge').textContent = `${elapsed}ms`;
                        saveMessages();
                    }
                } else {
                    // Non-streaming mode
                    // Model is loaded when we get response
                    if (loadingInterval) {
                        clearInterval(loadingInterval);
                        loadingInterval = null;
                        statusBadge.textContent = 'Generating...';
                    }
                    
                    const result = await response.json();
                    
                    // Remove thinking indicator
                    if (thinkingIndicator) {
                        thinkingIndicator.remove();
                    }
                    
                    const assistantMsg = result.choices[0]?.message?.content || 'No response';
                    const elapsed = Date.now() - startTime;
                    if (assistantMsg) {
                        messages.push({ role: 'assistant', content: assistantMsg });
                        addChatMessage('assistant', assistantMsg, null, startTime);
                        saveMessages();
                        scrollToBottom();
                    }
                }

                updateChatStats();
                if (loadingInterval) {
                    clearInterval(loadingInterval);
                    loadingInterval = null;
                }
                statusBadge.className = 'text-xs font-medium text-green-400';
                statusBadge.textContent = 'Ready';
            } catch (error) {
                if (loadingInterval) {
                    clearInterval(loadingInterval);
                    loadingInterval = null;
                }
                
                // Remove thinking indicator on error
                if (thinkingIndicator) {
                    thinkingIndicator.remove();
                }
                
                if (error.name === 'AbortError') {
                    addChatMessage('assistant', '[Generation stopped by user]', null, startTime);
                    statusBadge.className = 'text-xs font-medium text-green-400';
                    statusBadge.textContent = 'Ready';
                } else {
                    const errorMsg = error.message || 'Unknown error occurred';
                    console.error('Chat error:', error);
                    
                    // Better error messages for common issues
                    let userMessage = `⚠ Error: ${errorMsg}`;
                    if (error.code === 'missing_mmproj') {
                        userMessage = '⚠ This vision model is missing its mmproj adapter. Download the matching .mmproj file, place it next to the GGUF, reload the model, and try again.';
                    } else if (errorMsg.includes('503') || errorMsg.includes('Failed to load model')) {
                        userMessage = `⚠ Model is taking longer than expected to load.\n\nThis can happen on slower systems. Please try again in a few moments.`;
                    } else if (errorMsg.includes('500')) {
                        userMessage = `⚠ Server error occurred.\n\nThe model may still be loading. Please wait a moment and try again.`;
                    }
                    
                    addChatMessage('assistant', userMessage, null, startTime);
                    statusBadge.className = 'text-xs font-medium text-red-400';
                    statusBadge.textContent = 'Error';
                }
            } finally {
                if (loadingInterval) {
                    clearInterval(loadingInterval);
                }
                isGenerating = false;
                pendingRequest = false;
                console.log('[SEND CHAT] Cleaned up - pendingRequest = false, isGenerating = false');
                abortController = null;
                input.disabled = false;
                sendBtn.disabled = false;
                stopBtn.classList.add('hidden');
                input.focus();
            }
        }

        // Add thinking indicator
        function addThinkingIndicator() {
            const container = document.getElementById('chatMessages');
            const div = document.createElement('div');
            div.className = 'message message-assistant thinking-indicator';
            
            div.innerHTML = `
                <div class="message-wrapper">
                    <div class="message-avatar">AI</div>
                    <div class="message-body">
                        <div class="flex items-center gap-2 mb-2">
                            <span class="text-xs font-medium text-secondary">Assistant</span>
                        </div>
                        <div class="flex items-center gap-2 text-sm text-secondary">
                            <div class="thinking-dots">
                                <span class="dot"></span>
                                <span class="dot"></span>
                                <span class="dot"></span>
                            </div>
                            <span class="thinking-text">Thinking...</span>
                        </div>
                    </div>
                </div>
            `;
            container.appendChild(div);
            scrollToBottom();
            return div;
        }

        // Add thinking indicator
        function addThinkingIndicator() {
            const container = document.getElementById('chatMessages');
            const div = document.createElement('div');
            div.className = 'message message-assistant thinking-indicator';
            
            div.innerHTML = `
                <div class="message-wrapper">
                    <div class="message-avatar">AI</div>
                    <div class="message-body">
                        <div class="flex items-center gap-2 mb-2">
                            <span class="text-xs font-medium text-secondary">Assistant</span>
                        </div>
                        <div class="flex items-center gap-2 text-sm text-secondary">
                            <div class="thinking-dots">
                                <span class="dot"></span>
                                <span class="dot"></span>
                                <span class="dot"></span>
                            </div>
                            <span class="thinking-text">Thinking...</span>
                        </div>
                    </div>
                </div>
            `;
            container.appendChild(div);
            scrollToBottom();
            return div;
        }

        // Helper function to smoothly scroll chat to bottom
        function scrollToBottom() {
            const container = document.getElementById('chatMessages');
            if (container) {
                container.scrollTop = container.scrollHeight;
            }
        }

        function addChatMessage(role, content, images = null, startTime = null) {
            const container = document.getElementById('chatMessages');
            if (container.querySelector('.text-center')) {
                container.innerHTML = '';
            }

            const div = document.createElement('div');
            div.className = 'message message-' + role;
            
            // Configure marked.js with syntax highlighting
            marked.setOptions({
                highlight: function(code, lang) {
                    if (lang && hljs.getLanguage(lang)) {
                        try {
                            return hljs.highlight(code, { language: lang }).value;
                        } catch (e) {
                            console.error('Highlight error:', e);
                        }
                    }
                    return hljs.highlightAuto(code).value;
                },
                breaks: true,
                gfm: true
            });

            // Parse markdown content
            const formattedContent = marked.parse(content);
            const avatar = role === 'user' ? 'U' : 'AI';
            const timestamp = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            const elapsed = startTime ? `${Date.now() - startTime}ms` : '';
            
            const attachmentList = Array.isArray(images) ? images : (images ? [images] : []);
            let imageHtml = '';
            if (attachmentList.length) {
                const imageItems = attachmentList.map(url => {
                    const safeUrl = escapeAttribute(url);
                    return `<img src="${safeUrl}" class="max-h-64 rounded-lg border border-theme shadow-md object-cover">`;
                }).join('');
                imageHtml = `<div class="flex flex-wrap gap-3 mb-3">${imageItems}</div>`;
            }
            
            div.innerHTML = `
                <div class="message-wrapper">
                    <div class="message-avatar">${avatar}</div>
                    <div class="message-body">
                        <div class="flex items-center gap-2 mb-2">
                            <span class="text-xs font-medium text-secondary">${role === 'user' ? 'You' : 'Assistant'}</span>
                            <span class="text-xs text-secondary">${timestamp}</span>
                            ${elapsed ? `<span class="time-badge text-xs text-accent">${elapsed}</span>` : ''}
                        </div>
                        ${imageHtml}
                        <div class="text-sm message-content prose prose-invert max-w-none">${formattedContent}</div>
                        ${role === 'assistant' ? `
                        <div class="message-actions mt-3">
                            <button onclick="copyMessage(this)" class="btn btn-secondary btn-sm">Copy</button>
                            <button onclick="regenerateMessage()" class="btn btn-info btn-sm">Regenerate</button>
                        </div>` : ''}
                    </div>
                </div>
            `;
            container.appendChild(div);
            scrollToBottom();
            
            // Apply highlighting to all code blocks in this message
            div.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            return div;
        }

        function copyMessage(btn) {
            const content = btn.closest('.message').querySelector('.message-content').textContent;
            navigator.clipboard.writeText(content).then(() => {
                const original = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = original, 2000);
            });
        }

        function regenerateMessage() {
            if (messages.length < 2) return;
            messages.pop(); // Remove last assistant message
            const lastUserMsg = messages[messages.length - 1];
            messages.pop(); // Remove last user message
            document.getElementById('chatInput').value = lastUserMsg.content;
            sendChat();
        }

        // Search models
        async function searchModels() {
            const query = document.getElementById('searchQuery').value.trim();
            if (!query) {
                const results = document.getElementById('searchResults');
                results.innerHTML = '<p class="text-sm text-yellow-400">⚠ Please enter a search query</p>';
                return;
            }

            const results = document.getElementById('searchResults');
            results.innerHTML = '<p class="text-sm text-secondary">🔍 Searching HuggingFace...</p>';

            try {
                // Add timeout to prevent hanging
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 35000); // 35 second timeout (backend has 30s)
                
                const resp = await fetch(`/v1/search?query=${encodeURIComponent(query)}`, {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (!resp.ok) {
                    throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
                }
                
                const data = await resp.json();
                
                if (data.error) {
                    throw new Error(typeof data.error === 'string' ? data.error : JSON.stringify(data.error));
                }
                
                const models = data.results || [];

                if (models.length === 0) {
                    results.innerHTML = '<p class="text-sm text-secondary">No models found. Try different keywords like "llama", "phi", "mistral".</p>';
                    return;
                }

                results.innerHTML = '';
                models.slice(0, 10).forEach(model => {
                    const div = document.createElement('div');
                    div.className = 'model-item';
                    const downloadCmd = model.download_command || `offgrid download-hf ${model.id}`;
                    const sizeInfo = model.size_gb ? `${model.size_gb} GB` : 'Size unknown';
                    const quantInfo = model.best_quant ? ` · ${model.best_quant}` : '';
                    const escapedCmd = downloadCmd.replace(/'/g, "\\'");
                    
                    div.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div class="flex-1">
                                <div class="font-semibold text-sm text-accent">${model.name || model.id}</div>
                                <div class="text-xs text-secondary mt-1">${sizeInfo}${quantInfo} · ${model.downloads || 0} downloads</div>
                            </div>
                            <button onclick="downloadModelWithCommand('${escapedCmd}')" class="btn btn-primary btn-sm">Download</button>
                        </div>
                    `;
                    results.appendChild(div);
                });
            } catch (error) {
                console.error('Search error:', error);
                
                // Provide helpful error message based on error type
                let errorHtml = '';
                if (error.name === 'AbortError' || error.message.includes('Timeout') || error.message.includes('exceeded')) {
                    errorHtml = `
                        <div class="text-sm">
                            <p class="text-red-400 mb-2">⚠ Search timeout: HuggingFace API not responding</p>
                            <p class="text-secondary mb-3">This usually means no internet connection or HuggingFace is slow.</p>
                            <div class="text-xs text-secondary">
                                <p class="font-semibold text-accent mb-2">Try instead:</p>
                                <p class="mb-1">• Use the terminal: <span class="font-mono bg-secondary px-2 py-1 rounded">offgrid search llama</span></p>
                                <p class="mb-1">• Download directly: <span class="font-mono bg-secondary px-2 py-1 rounded">offgrid download-hf TheBloke/TinyLlama-1.1B-Chat-v1.0-GGUF</span></p>
                            </div>
                        </div>
                    `;
                } else {
                    errorHtml = `
                        <div class="text-sm">
                            <p class="text-red-400 mb-2">Search error: ${error.message}</p>
                            <p class="text-secondary mb-2">Use the Terminal tab to search instead:</p>
                            <p class="text-xs font-mono bg-secondary px-2 py-1 rounded inline-block">offgrid search ${query}</p>
                        </div>
                    `;
                }
                results.innerHTML = errorHtml;
            }
        }

        // Download model with specific command
        async function downloadModelWithCommand(command) {
            // Switch to terminal tab and execute download command
            switchTab('terminal');
            document.getElementById('terminalInput').value = command;
            runCommand();
        }

        // Download model (fallback for installed models)
        async function downloadModel(modelName) {
            // Switch to terminal tab and execute download command
            switchTab('terminal');
            document.getElementById('terminalInput').value = `offgrid download ${modelName}`;
            runCommand();
        }

        // Load installed models
        async function loadInstalledModels() {
            const container = document.getElementById('installedModels');
            container.innerHTML = '<p class="text-sm text-secondary">Loading...</p>';

            try {
                // Force refresh models from filesystem
                try {
                    await fetch('/models/refresh', { method: 'POST' });
                } catch (e) {
                    console.warn('Failed to refresh models, using cached list:', e);
                }
                
                const resp = await fetch('/models');
                const data = await resp.json();
                const models = data.data || [];

                if (models.length === 0) {
                    container.innerHTML = '<p class="text-sm text-secondary">No models installed</p>';
                    return;
                }

                container.innerHTML = '';
                models.forEach(model => {
                    const div = document.createElement('div');
                    div.className = 'model-item';
                    const modelId = (model.id || '').replace(/'/g, "\\'");
                    
                    // Format size if available (assuming it might be in metadata)
                    // Since the API might not return size directly in the root object, we check
                    // But for now we'll just show the ID cleanly
                    
                    div.innerHTML = `
                        <div class="flex justify-between items-center gap-3">
                            <div class="flex-1 min-w-0">
                                <div class="font-semibold text-sm text-accent truncate" title="${model.id}">${model.id}</div>
                                <div class="flex gap-2 mt-1">
                                    <span class="text-xs bg-secondary px-1.5 py-0.5 rounded text-secondary font-mono">GGUF</span>
                                </div>
                            </div>
                            <div class="flex gap-2">
                                <button onclick="runQuickCommand('offgrid run ${modelId}')" class="btn btn-primary btn-sm flex-shrink-0">Run</button>
                                <button onclick="removeModel('${modelId}')" class="btn btn-danger btn-sm flex-shrink-0">Remove</button>
                            </div>
                        </div>
                    `;
                    container.appendChild(div);
                });
            } catch (error) {
                container.innerHTML = '<p class="text-sm text-red-400">Failed to load models</p>';
            }
        }

        // Remove model
        async function removeModel(modelId) {
            showModal({
                type: 'error',
                title: 'Remove Model?',
                message: `Are you sure you want to remove <strong>${modelId}</strong>?<br><br>This will delete the model file from your system.`,
                confirmText: 'Remove',
                cancelText: 'Cancel',
                onConfirm: () => {
                    confirmRemoveModel(modelId);
                }
            });
        }

        // Execute the actual removal via terminal
        async function confirmRemoveModel(modelId) {
            try {
                // Clear saved model if it's the one being deleted
                if (currentModel === modelId) {
                    currentModel = '';
                    localStorage.removeItem('offgrid_current_model');
                }
                
                // Switch to terminal tab to show progress
                switchTab('terminal');
                
                // Execute remove command
                const input = document.getElementById('terminalInput');
                input.value = `offgrid remove ${modelId} --yes`;
                
                // Trigger the command
                const event = new KeyboardEvent('keydown', { key: 'Enter', code: 'Enter', keyCode: 13 });
                input.dispatchEvent(event);
                
                // Note: Model list refresh happens in handleOffgridCommand after command completes
            } catch (error) {
                showModal({
                    type: 'error',
                    title: 'Remove Failed',
                    message: `Failed to remove model: ${error.message}`,
                    confirmText: 'OK'
                });
            }
        }

        // USB Import/Export Functions
        
        // Scan USB drive for models
        async function scanUSB() {
            const usbPath = document.getElementById('usbImportPath').value.trim();
            const resultsDiv = document.getElementById('usbScanResults');
            const statusDiv = document.getElementById('usbImportStatus');
            
            if (!usbPath) {
                statusDiv.innerHTML = '<span class="text-yellow-400">⚠ Please enter a USB path</span>';
                return;
            }
            
            statusDiv.innerHTML = '';
            resultsDiv.innerHTML = '<span class="text-accent">🔍 Scanning USB drive...</span>';
            
            try {
                const response = await fetch('/v1/usb/scan', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ usb_path: usbPath })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    const count = data.count || 0;
                    if (count > 0) {
                        const totalSize = data.models.reduce((sum, m) => sum + m.size, 0);
                        const totalGB = (totalSize / (1024 * 1024 * 1024)).toFixed(2);
                        
                        resultsDiv.innerHTML = `
                            <div class="p-2 bg-secondary rounded border border-accent">
                                <div class="font-medium text-accent mb-2">Found ${count} model(s) - ${totalGB} GB</div>
                                <div class="space-y-1 max-h-32 overflow-y-auto">
                                    ${data.models.map(m => `
                                        <div class="text-xs flex justify-between">
                                            <span class="font-mono">${m.file_name}</span>
                                            <span class="text-secondary">${(m.size / (1024*1024*1024)).toFixed(2)} GB</span>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    } else {
                        resultsDiv.innerHTML = '<span class="text-secondary">No GGUF models found</span>';
                    }
                } else {
                    const error = data.error || 'Scan failed';
                    resultsDiv.innerHTML = `<span class="text-red-400">✗ ${error}</span>`;
                }
            } catch (error) {
                resultsDiv.innerHTML = `<span class="text-red-400">✗ Error: ${error.message}</span>`;
            }
        }
        
        async function importFromUSB() {
            const usbPath = document.getElementById('usbImportPath').value.trim();
            const statusDiv = document.getElementById('usbImportStatus');
            const progressDiv = document.getElementById('usbImportProgress');
            const progressBar = document.getElementById('usbImportProgressBar');
            const progressText = document.getElementById('usbImportProgressText');
            
            if (!usbPath) {
                statusDiv.innerHTML = '<span class="text-yellow-400">⚠ Please enter a USB path</span>';
                return;
            }
            
            statusDiv.innerHTML = '';
            progressDiv.classList.remove('hidden');
            progressBar.style.width = '0%';
            progressText.innerHTML = 'Starting import...';
            
            try {
                const response = await fetch('/v1/usb/import', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: usbPath })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    const count = data.imported_count || 0;
                    progressBar.style.width = '100%';
                    progressText.innerHTML = `✓ Successfully imported ${count} model(s)`;
                    setTimeout(() => {
                        progressDiv.classList.add('hidden');
                        statusDiv.innerHTML = `<span class="text-green-400">✓ Import complete - ${count} model(s) added</span>`;
                    }, 2000);
                    loadInstalledModels(); // Refresh the models list
                } else {
                    const error = data.error || 'Import failed';
                    progressDiv.classList.add('hidden');
                    statusDiv.innerHTML = `<span class="text-red-400">✗ ${error}</span>`;
                }
            } catch (error) {
                progressDiv.classList.add('hidden');
                statusDiv.innerHTML = `<span class="text-red-400">✗ Error: ${error.message}</span>`;
            }
        }
        
        async function exportToUSB() {
            const usbPath = document.getElementById('usbExportPath').value.trim();
            const statusDiv = document.getElementById('usbExportStatus');
            const progressDiv = document.getElementById('usbExportProgress');
            const progressBar = document.getElementById('usbExportProgressBar');
            const progressText = document.getElementById('usbExportProgressText');
            
            if (!usbPath) {
                statusDiv.innerHTML = '<span class="text-yellow-400">⚠ Please enter a USB path</span>';
                return;
            }
            
            statusDiv.innerHTML = '';
            progressDiv.classList.remove('hidden');
            progressBar.style.width = '0%';
            progressText.innerHTML = 'Starting export...';
            
            try {
                const response = await fetch('/v1/usb/export', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: usbPath })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    const count = data.exported_count || 0;
                    const size = data.total_size_gb || 0;
                    progressBar.style.width = '100%';
                    progressText.innerHTML = `✓ Exported ${count} model(s) (${size.toFixed(2)} GB)`;
                    setTimeout(() => {
                        progressDiv.classList.add('hidden');
                        statusDiv.innerHTML = `
                            <div class="p-2 bg-secondary rounded border border-green-500">
                                <div class="text-green-400 font-medium">✓ Export Complete</div>
                                <div class="text-xs text-secondary mt-1">
                                    ${count} model(s) exported (${size.toFixed(2)} GB)<br>
                                    Location: ${usbPath}/offgrid-models/<br>
                                    Manifest and README included
                                </div>
                            </div>
                        `;
                    }, 2000);
                } else {
                    const error = data.error || 'Export failed';
                    progressDiv.classList.add('hidden');
                    statusDiv.innerHTML = `<span class="text-red-400">✗ ${error}</span>`;
                }
            } catch (error) {
                progressDiv.classList.add('hidden');
                statusDiv.innerHTML = `<span class="text-red-400">✗ Error: ${error.message}</span>`;
            }
        }

        // Terminal commands
        function clearTerminal() {
            terminalOutputBuffer = ''; // Clear any buffered output
            document.getElementById('terminalOutput').innerHTML = `
                <div class="terminal-line terminal-success">OffGrid Terminal v0.2..0</div>
                <div class="terminal-line">Connected to real offgrid binary</div>
                <div class="terminal-line">Type 'help' for available commands or 'offgrid --help' for all options</div>
            `;
        }

        function killCommand() {
            if (currentTerminalAbort) {
                currentTerminalAbort.abort();
                currentTerminalAbort = null;
            }
            terminalRunning = false;
            const inputLine = document.getElementById('terminalInputLine');
            inputLine.classList.remove('terminal-running');
            document.getElementById('terminalInput').disabled = false;
            document.getElementById('killBtn').classList.add('hidden');
            addTerminalOutput('Command killed', 'error');
        }

        function runQuickCommand(cmd) {
            document.getElementById('terminalInput').value = cmd;
            runCommand();
        }

        function runCommand() {
            const input = document.getElementById('terminalInput');
            const cmd = input.value.trim();
            if (!cmd) return;

            // Handle chat mode
            if (terminalChatMode) {
                // Prevent sending while already processing
                if (terminalRunning || pendingRequest) {
                    console.log('Terminal chat request already in progress');
                    return; // Silently ignore, don't show error
                }
                
                // Throttle terminal chat requests
                const now = Date.now();
                if (now - lastRequestTime < requestCooldown) {
                    console.log('Throttling terminal chat request');
                    return;
                }
                lastRequestTime = now;
                
                if (cmd === 'exit' || cmd === 'quit') {
                    addTerminalOutput(cmd, 'prompt');
                    addTerminalOutput('Exiting chat mode...', 'success');
                    terminalChatMode = false;
                    terminalChatModel = '';
                    terminalChatHistory = [];
                    input.value = '';
                    return;
                } else if (cmd === 'clear') {
                    clearTerminal();
                    addTerminalOutput(`Chat mode with ${terminalChatModel}`, 'success');
                    addTerminalOutput('Type your message or "exit" to quit');
                    addTerminalOutput('> ', 'success');
                    input.value = '';
                    return;
                }
                
                // Send message in chat mode - disable input while processing
                addTerminalOutput(cmd, 'prompt');
                input.value = '';
                input.disabled = true;
                terminalRunning = true;
                pendingRequest = true;
                sendTerminalChat(cmd);
                return;
            }

            if (terminalRunning) {
                addTerminalOutput('Command already running. Use Kill button to stop it.', 'error');
                return;
            }
            
            // Add to history
            if (commandHistory[0] !== cmd) {
                commandHistory.unshift(cmd);
                if (commandHistory.length > 50) commandHistory.pop();
            }
            historyIndex = -1;

            addTerminalOutput(cmd, 'prompt');
            input.value = '';

            const parts = cmd.split(' ').filter(p => p);
            const command = parts[0];
            const args = parts.slice(1);

            // Set running state
            terminalRunning = true;
            const inputLine = document.getElementById('terminalInputLine');
            inputLine.classList.add('terminal-running');
            input.disabled = true;
            document.getElementById('killBtn').classList.remove('hidden');

            switch (command) {
                case 'offgrid':
                    handleOffgridCommand(args);
                    break;
                case 'clear':
                    clearTerminal();
                    resetTerminalState();
                    break;
                case 'help':
                    showHelp();
                    resetTerminalState();
                    break;
                case 'history':
                    showHistory();
                    resetTerminalState();
                    break;
                default:
                    addTerminalOutput(`Unknown command: ${command}. Type 'help' for available commands`, 'error');
                    resetTerminalState();
            }
        }

        function resetTerminalState() {
            terminalRunning = false;
            const inputLine = document.getElementById('terminalInputLine');
            inputLine.classList.remove('terminal-running');
            document.getElementById('terminalInput').disabled = false;
            document.getElementById('killBtn').classList.add('hidden');
        }

        function showHelp() {
            const help = [
                'Available Commands:',
                '',
                'Terminal Commands:',
                '  clear                         Clear terminal screen',
                '  history                       Show command history',
                '  help                          Show this help',
                '',
                'OffGrid Commands (runs real offgrid binary):',
                '  offgrid list                  List installed models',
                '  offgrid search <query>        Search for models to download',
                '  offgrid download <model>      Download a model',
                '  offgrid remove <model>        Remove an installed model',
                '  offgrid run <model>           Load model and switch to Chat tab',
                '  offgrid info                  Show system information',
                '  offgrid doctor                Run diagnostics',
                '  offgrid --help                Show all offgrid commands',
                '  offgrid --version             Show version',
                '',
                'Tips:',
                '  - Use arrow keys (↑/↓) to navigate history',
                '  - Use Tab for command autocomplete',
                '  - Press Ctrl+C or click Kill to stop command',
                '  - For interactive chat, use "offgrid run <model>" or Chat tab'
            ];
            help.forEach(line => addTerminalOutput(line));
        }

        function showHistory() {
            if (commandHistory.length === 0) {
                addTerminalOutput('No command history');
                return;
            }
            addTerminalOutput('Command History:');
            commandHistory.slice(0, 10).forEach((cmd, i) => {
                addTerminalOutput(`  ${i + 1}. ${cmd}`);
            });
        }

        async function handleOffgridCommand(args) {
            if (args.length === 0) {
                addTerminalOutput('Usage: offgrid <command>', 'error');
                addTerminalOutput('Try: offgrid help');
                resetTerminalState();
                return;
            }

            // Create abort controller for this command
            currentTerminalAbort = new AbortController();
            
            try {
                // Execute real offgrid command via streaming endpoint for real-time output
                const resp = await fetch('/v1/terminal/exec/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        command: 'offgrid',
                        args: args
                    }),
                    signal: currentTerminalAbort?.signal
                });

                if (!resp.ok) {
                    addTerminalOutput(`Command failed: HTTP ${resp.status}`, 'error');
                    resetTerminalState();
                    return;
                }

                // Read streaming response
                const reader = resp.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let exitCode = 0;

                while (true) {
                    const {done, value} = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, {stream: true});
                    
                    // Process complete SSE events
                    const lines = buffer.split('\n\n');
                    buffer = lines.pop(); // Keep incomplete event in buffer

                    for (const event of lines) {
                        if (!event.trim()) continue;
                        
                        // Parse SSE format: "event: type\ndata: line1\ndata: line2\n..."
                        const eventLines = event.split('\n');
                        let eventType = '';
                        const dataLines = [];
                        
                        for (const eLine of eventLines) {
                            if (eLine.startsWith('event:')) {
                                eventType = eLine.substring(6).trim();
                            } else if (eLine.startsWith('data:')) {
                                dataLines.push(eLine.substring(5).trim());
                            }
                        }
                        
                        if (!eventType) continue;
                        
                        const data = dataLines.join('\n');
                        
                        if (eventType === 'output') {
                            // Display output in real-time
                            if (data) addTerminalRawOutput(data);
                        } else if (eventType === 'exit') {
                            exitCode = parseInt(data);
                        } else if (eventType === 'error') {
                            addTerminalOutput(`Error: ${data}`, 'error');
                        }
                    }
                }
                
                // Special handling for 'run' command - enable terminal chat mode
                const subcmd = args[0];
                if (subcmd === 'run' && args.length > 1 && exitCode === 0) {
                    // Extract just the model name (first argument after run), ignoring flags
                    // We assume the syntax is: offgrid run <model_id> [flags]

                    const modelName = args[1];
                    
                    // Enable chat mode
                    terminalChatMode = true;
                    terminalChatModel = modelName;
                    terminalChatHistory = [];
                    addTerminalOutput('', 'normal');
                    addTerminalOutput('Chat mode enabled. Type your messages below.', 'success');
                    addTerminalOutput('Commands: "exit" to quit, "clear" to reset screen', 'success');
                    addTerminalOutput('> ', 'success');
                }

                if (exitCode !== 0) {
                    addTerminalOutput(`Command exited with code ${exitCode}`, 'error');
                }

                // Refresh UI after certain commands (only on success)
                if (['download', 'remove', 'delete'].includes(subcmd) && exitCode === 0) {
                    // Wait longer to ensure backend has updated
                    setTimeout(() => {
                        loadInstalledModels();
                        loadChatModels();
                    }, 2500);
                }

            } catch (error) {
                if (error.name === 'AbortError') {
                    addTerminalOutput('Command aborted', 'error');
                } else {
                    addTerminalOutput(`Error: ${error.message}`, 'error');
                }
            } finally {
                flushTerminalBuffer(); // Flush any remaining buffered output
                resetTerminalState();
                currentTerminalAbort = null;
            }
        }



        // Send chat message in terminal mode
        async function sendTerminalChat(message) {
            try {
                terminalChatHistory.push({ role: 'user', content: message });
                
                const resp = await fetch('/v1/chat/completions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: terminalChatModel,
                        messages: terminalChatHistory,
                        stream: false,
                        temperature: 0.7,
                        max_tokens: 2000
                    })
                });

                if (!resp.ok) {
                    let errorMsg = `HTTP ${resp.status}`;
                    try {
                        const errorData = await resp.json();
                        errorMsg = errorData.error?.message || errorMsg;
                    } catch (e) {
                        // Ignore JSON parse errors
                    }
                    addTerminalOutput(`Error: ${errorMsg}`, 'error');
                    terminalChatHistory.pop(); // Remove failed message
                    return;
                }

                const data = await resp.json();
                const assistantMsg = data.choices?.[0]?.message?.content || 'No response';
                const actualModel = data.model || terminalChatModel;
                
                terminalChatHistory.push({ role: 'assistant', content: assistantMsg });
                
                // Show model info if different from expected
                if (actualModel !== terminalChatModel) {
                    addTerminalOutput(`[Using model: ${actualModel}]`, 'error');
                }
                
                addTerminalOutput('', 'normal');
                addTerminalOutput(assistantMsg, 'success');
                addTerminalOutput('', 'normal');
                addTerminalOutput('> ', 'success');
                
            } catch (error) {
                addTerminalOutput(`Error: ${error.message}`, 'error');
                if (terminalChatHistory.length > 0 && terminalChatHistory[terminalChatHistory.length - 1].role === 'user') {
                    terminalChatHistory.pop(); // Remove failed message
                }
            } finally {
                // Re-enable input after processing
                terminalRunning = false;
                pendingRequest = false;
                document.getElementById('terminalInput').disabled = false;
                document.getElementById('terminalInput').focus();
            }
        }

        // Format progress line with visual progress bar
        function formatProgressLine(text) {
            const cleanText = stripAnsi(text);
            
            // Extract percentage if present
            const percentMatch = cleanText.match(/(\d+(?:\.\d+)?)\s*%/);
            const percent = percentMatch ? parseFloat(percentMatch[1]) : null;
            
            // Clean up the text and format nicely
            let formattedText = parseAnsiColors(text);
            
            if (percent !== null) {
                // Create visual progress bar
                const progressBar = `
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <span style="min-width: 50px; text-align: right; color: #7ee787;">${percent.toFixed(1)}%</span>
                        <div style="flex: 1; max-width: 200px; height: 6px; background: #21262d; border-radius: 3px; overflow: hidden;">
                            <div style="width: ${Math.min(percent, 100)}%; height: 100%; background: linear-gradient(90deg, #238636, #2ea043); transition: width 0.15s ease;"></div>
                        </div>
                        <span style="color: #8b949e; font-size: 12px;">${cleanText.replace(/\d+(?:\.\d+)?\s*%/, '').trim()}</span>
                    </div>
                `;
                return progressBar;
            }
            
            return formattedText;
        }

        // Strip ANSI escape codes
        function stripAnsi(text) {
            // Strip all ANSI escape codes (colors, cursor movement, etc.)
            return text.replace(/\x1b\[[0-9;]*[a-zA-Z]/g, '');
        }

        // Parse ANSI color codes and convert to HTML with CSS classes
        function parseAnsiColors(text) {
            // Map of ANSI codes to CSS classes
            const colorMap = {
                // Basic 16 colors
                '30': 'ansi-black',
                '31': 'ansi-red',
                '32': 'ansi-green',
                '33': 'ansi-yellow',
                '34': 'ansi-blue',
                '35': 'ansi-magenta',
                '36': 'ansi-cyan',
                '37': 'ansi-white',
                '90': 'ansi-gray',
                
                // 256-color palette (extended colors used in offgrid)
                '38;5;45': 'ansi-cyan',      // Bright cyan - headers
                '38;5;78': 'ansi-green',     // Bright green
                '38;5;141': 'ansi-purple',   // Purple - command names
                '38;5;196': 'ansi-red',      // Bright red - errors
                '38;5;226': 'ansi-yellow',   // Bright yellow
                '38;5;240': 'ansi-gray',     // Gray - dim text
                
                // Text styles
                '1': 'ansi-bold',            // Bold
                '2': 'ansi-dim',             // Dim/faint
                '22': 'ansi-normal',         // Normal intensity
            };
            
            // Escape HTML and convert ALL spaces to &nbsp; for guaranteed alignment
            function escapeHtml(str) {
                return str
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/ /g, '\u00A0'); // Convert every space to non-breaking space
            }
            
            let result = '';
            let currentClasses = new Set();
            let lastIndex = 0;
            
            // First, clean up any malformed ANSI sequences (missing escape char)
            // Replace [<codes>m with proper \x1b[<codes>m if not already escaped
            text = text.replace(/(?<!\x1b)\[([0-9;]+)m/g, '\x1b[$1m');
            
            // Match ANSI escape sequences: ESC [ <codes> m
            const ansiRegex = /\x1b\[([0-9;]+)m/g;
            let match;
            
            while ((match = ansiRegex.exec(text)) !== null) {
                // Add text before this escape code (escape HTML entities)
                const textChunk = text.substring(lastIndex, match.index);
                result += escapeHtml(textChunk);
                lastIndex = match.index + match[0].length;
                
                const codes = match[1].split(';');
                
                for (const code of codes) {
                    if (code === '0') {
                        // Reset - close all open spans and clear classes
                        if (currentClasses.size > 0) {
                            result += '</span>';
                            currentClasses.clear();
                        }
                    } else {
                        const cssClass = colorMap[code] || colorMap[codes.join(';')];
                        if (cssClass) {
                            // Close previous span if exists
                            if (currentClasses.size > 0) {
                                result += '</span>';
                            }
                            // Add new class and open new span
                            currentClasses.add(cssClass);
                            result += `<span class="${Array.from(currentClasses).join(' ')}">`;
                        }
                    }
                }
            }
            
            // Add remaining text (escape HTML)
            const remainingText = text.substring(lastIndex);
            result += escapeHtml(remainingText);
            
            // Close any remaining open spans
            if (currentClasses.size > 0) {
                result += '</span>';
            }
            
            return result;
        }

        function addTerminalOutput(text, type = 'normal') {
            const terminal = document.getElementById('terminalOutput');
            const line = document.createElement('div');
            line.className = 'terminal-line';
            
            if (type === 'prompt') {
                line.className = 'terminal-line terminal-prompt';
                line.textContent = text;
            } else if (type === 'error') {
                line.className = 'terminal-line terminal-error';
                line.textContent = text;
            } else if (type === 'success') {
                line.className = 'terminal-line terminal-success';
                // Use marked for markdown rendering
                try {
                    line.innerHTML = marked.parse(text);
                } catch (e) {
                    line.textContent = text;
                }
            } else if (type === 'raw') {
                // Raw output with ANSI colors
                line.innerHTML = parseAnsiColors(text);
            } else {
                // Normal output - preserve whitespace
                line.textContent = text;
            }
            
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
        }

        // Buffer for incomplete ANSI sequences across chunks
        let terminalOutputBuffer = '';

        function addTerminalRawOutput(text) {
            const terminal = document.getElementById('terminalOutput');
            
            // Combine with any buffered text from previous chunk
            let currentText = terminalOutputBuffer + text;
            
            // Split by newlines
            const lines = currentText.split('\n');
            
            // The last part is the new buffer (incomplete line)
            const newBuffer = lines.pop();
            
            // Remove the last line if it was dynamic (incomplete/progress)
            const lastLine = terminal.lastElementChild;
            if (lastLine && lastLine.dataset.dynamic === "true") {
                lastLine.remove();
            }
            
            // Process complete lines
            lines.forEach((lineText) => {
                // Handle \r (carriage return) - take the last part
                if (lineText.includes('\r')) {
                    const parts = lineText.split('\r');
                    lineText = parts[parts.length - 1];
                }
                
                // Skip completely empty lines (reduce visual clutter)
                const cleanText = stripAnsi(lineText).trim();
                if (!cleanText) {
                    // Add small spacing element instead of empty line
                    const spacer = document.createElement('div');
                    spacer.className = 'terminal-line';
                    spacer.innerHTML = '&nbsp;';
                    spacer.style.height = '4px';
                    spacer.style.margin = '0';
                    terminal.appendChild(spacer);
                    return;
                }
                
                // Check if this is a progress line
                const isProgress = cleanText.startsWith('Progress:') || 
                                   cleanText.includes('%') && (cleanText.includes('Downloading') || cleanText.includes('MB'));
                
                if (isProgress) {
                    // Check if the last line in terminal is also a progress line
                    const lastTermLine = terminal.lastElementChild;
                    if (lastTermLine && lastTermLine.dataset.progress === "true") {
                        // Update existing progress line
                        lastTermLine.innerHTML = formatProgressLine(lineText);
                        return; // Skip appending new line
                    }
                    
                    // Create new progress line
                    const line = document.createElement('div');
                    line.className = 'terminal-line terminal-progress';
                    line.dataset.progress = "true";
                    line.innerHTML = formatProgressLine(lineText);
                    terminal.appendChild(line);
                    return;
                }
                
                // Check if this is a section header (all caps or ends with colon)
                const isSectionHeader = /^[A-Z][A-Z\s]+:?$/.test(cleanText) || 
                                        (cleanText.endsWith(':') && cleanText.length < 40 && !cleanText.includes('  '));
                
                const line = document.createElement('div');
                if (isSectionHeader) {
                    line.className = 'terminal-line terminal-section-header';
                } else {
                    line.className = 'terminal-line';
                }
                line.innerHTML = parseAnsiColors(lineText);
                terminal.appendChild(line);
            });
            
            // Process new buffer (incomplete line)
            if (newBuffer !== undefined && newBuffer !== '') {
                let content = newBuffer;
                // Handle \r
                if (content.includes('\r')) {
                    const parts = content.split('\r');
                    content = parts[parts.length - 1];
                }
                
                const cleanContent = stripAnsi(content).trim();
                const isProgress = cleanContent.startsWith('Progress:') || 
                                   cleanContent.includes('%') && (cleanContent.includes('Downloading') || cleanContent.includes('MB'));

                if (isProgress) {
                    const lastTermLine = terminal.lastElementChild;
                    if (lastTermLine && lastTermLine.dataset.progress === "true") {
                        lastTermLine.innerHTML = formatProgressLine(content);
                        lastTermLine.dataset.dynamic = "true";
                        terminalOutputBuffer = newBuffer || '';
                        terminal.scrollTop = terminal.scrollHeight;
                        return;
                    }
                    
                    // Create new progress line
                    const line = document.createElement('div');
                    line.className = 'terminal-line terminal-progress';
                    line.dataset.progress = "true";
                    line.dataset.dynamic = "true";
                    line.innerHTML = formatProgressLine(content);
                    terminal.appendChild(line);
                    terminalOutputBuffer = newBuffer || '';
                    terminal.scrollTop = terminal.scrollHeight;
                    return;
                }
                
                const line = document.createElement('div');
                line.className = 'terminal-line';
                line.dataset.dynamic = "true"; // Mark as dynamic/incomplete
                line.innerHTML = parseAnsiColors(content);
                terminal.appendChild(line);
            }
            
            terminalOutputBuffer = newBuffer || '';
            terminal.scrollTop = terminal.scrollHeight;
        }
        
        // Flush any remaining buffer content (call this when command completes)
        function flushTerminalBuffer() {
            if (terminalOutputBuffer) {
                const terminal = document.getElementById('terminalOutput');
                const line = document.createElement('div');
                line.className = 'terminal-line';
                line.innerHTML = parseAnsiColors(terminalOutputBuffer);
                terminal.appendChild(line);
                terminalOutputBuffer = '';
                terminal.scrollTop = terminal.scrollHeight;
            }
        }

        // ==================== RAG (Knowledge Base) Functions ====================
        
        let ragEnabled = false;
        
        async function loadRAGStatus() {
            try {
                const response = await fetch('/v1/rag/status');
                const data = await response.json();
                ragEnabled = data.enabled;
                
                const badge = document.getElementById('ragStatusBadge');
                const disableBtn = document.getElementById('ragDisableBtn');
                const modelSelect = document.getElementById('ragEmbeddingModel');
                
                if (data.enabled) {
                    badge.className = 'badge badge-success';
                    badge.textContent = 'Enabled';
                    disableBtn.classList.remove('hidden');
                    // Set the current model in the dropdown
                    if (data.embedding_model) {
                        modelSelect.value = data.embedding_model;
                    }
                } else {
                    badge.className = 'badge badge-secondary';
                    badge.textContent = 'Disabled';
                    disableBtn.classList.add('hidden');
                }
                
                // Update stats
                if (data.stats) {
                    document.getElementById('ragDocCount').textContent = data.stats.document_count || 0;
                    document.getElementById('ragChunkCount').textContent = data.stats.chunk_count || 0;
                    document.getElementById('ragEmbeddingCount').textContent = data.stats.embedding_count || 0;
                }
            } catch (e) {
                console.error('Failed to load RAG status:', e);
            }
        }
        
        async function loadRAGEmbeddingModels() {
            try {
                // First get current RAG status to know which model is active
                const statusResp = await fetch('/v1/rag/status');
                const status = await statusResp.json();
                const currentModel = status.embedding_model || '';
                
                const response = await fetch('/v1/models');
                const data = await response.json();
                const select = document.getElementById('ragEmbeddingModel');
                select.innerHTML = '<option value="">Select model to enable...</option>';
                
                const embeddingModels = data.data.filter(m => 
                    m.id.toLowerCase().includes('embed') || 
                    m.id.toLowerCase().includes('minilm') ||
                    m.id.toLowerCase().includes('bge') ||
                    m.id.toLowerCase().includes('nomic')
                );
                
                let modelsToShow = embeddingModels.length > 0 ? embeddingModels : data.data;
                
                modelsToShow.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.id;
                    select.appendChild(option);
                });
                
                // Set the dropdown to show current model if RAG is enabled
                if (currentModel) {
                    select.value = currentModel;
                }
            } catch (e) {
                console.error('Failed to load embedding models:', e);
            }
        }
        
        // Called when embedding model dropdown changes
        async function onEmbeddingModelChange() {
            const model = document.getElementById('ragEmbeddingModel').value;
            
            if (!model) {
                // If cleared, disable RAG
                if (ragEnabled) {
                    await disableRAG();
                }
                return;
            }
            
            // Enable RAG with selected model
            try {
                const response = await fetch('/v1/rag/enable', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ embedding_model: model })
                });
                if (!response.ok) {
                    const err = await response.text();
                    throw new Error(err);
                }
                loadRAGStatus();
            } catch (e) {
                showAlert('Failed to enable RAG: ' + e.message, 'error');
            }
        }
        
        async function disableRAG() {
            try {
                await fetch('/v1/rag/disable', { method: 'POST' });
                document.getElementById('ragEmbeddingModel').value = '';
                loadRAGStatus();
            } catch (e) {
                showAlert('Failed to disable RAG: ' + e.message, 'error');
            }
        }
        
        // Legacy function - kept for compatibility
        async function toggleRAG() {
            if (ragEnabled) {
                await disableRAG();
            } else {
                await onEmbeddingModelChange();
            }
        }
        
        // Toggle developer tools section
        function toggleDevTools() {
            const content = document.getElementById('devToolsContent');
            const icon = document.getElementById('devToolsIcon');
            content.classList.toggle('hidden');
            icon.style.transform = content.classList.contains('hidden') ? '' : 'rotate(180deg)';
        }
        
        async function refreshRAGDocuments() {
            try {
                const response = await fetch('/v1/documents');
                const data = await response.json();
                const list = document.getElementById('ragDocumentsList');
                
                if (!data.documents || data.documents.length === 0) {
                    list.innerHTML = '<p class="text-secondary text-sm">No documents uploaded yet.</p>';
                    return;
                }
                
                list.innerHTML = data.documents.map(doc => `
                    <div class="flex items-center justify-between p-3 bg-tertiary rounded-lg">
                        <div class="flex items-center gap-3">
                            <svg class="w-5 h-5 text-accent" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                            </svg>
                            <div>
                                <div class="font-medium">${doc.name}</div>
                                <div class="text-xs text-secondary">${doc.chunk_count} chunks • ${formatBytes(doc.size)}</div>
                            </div>
                        </div>
                        <button onclick="deleteRAGDocument('${doc.id}')" class="btn btn-secondary btn-sm text-red-400 hover:text-red-300">
                            Delete
                        </button>
                    </div>
                `).join('');
                
                loadRAGStatus(); // Refresh stats
            } catch (e) {
                console.error('Failed to load documents:', e);
            }
        }
        
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }
        
        async function ingestRAGText() {
            const content = document.getElementById('ragTextInput').value.trim();
            const name = document.getElementById('ragTextName').value.trim() || 'untitled.txt';
            
            if (!content) {
                showAlert('Please enter some text content', 'warning');
                return;
            }
            
            if (!ragEnabled) {
                showAlert('Please enable RAG first by selecting an embedding model', 'warning');
                return;
            }
            
            try {
                const response = await fetch('/v1/documents/ingest', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, content })
                });
                
                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.error || 'Failed to ingest document');
                }
                
                document.getElementById('ragTextInput').value = '';
                document.getElementById('ragTextName').value = '';
                refreshRAGDocuments();
                showAlert('Document added successfully!', 'success');
            } catch (e) {
                showAlert('Failed to ingest document: ' + e.message, 'error');
            }
        }
        
        async function deleteRAGDocument(docId) {
            showConfirm('Are you sure you want to delete this document?', async () => {
                try {
                    await fetch('/v1/documents/delete', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ id: docId })
                    });
                    refreshRAGDocuments();
                } catch (e) {
                    showAlert('Failed to delete document: ' + e.message, 'error');
                }
            }, { title: 'Delete Document', confirmText: 'Delete', type: 'error' });
        }
        
        async function searchRAGDocuments() {
            const query = document.getElementById('ragSearchQuery').value.trim();
            if (!query) {
                showAlert('Please enter a search query', 'warning');
                return;
            }
            
            const resultsDiv = document.getElementById('ragSearchResults');
            resultsDiv.innerHTML = '<p class="text-secondary">Searching...</p>';
            
            try {
                const response = await fetch('/v1/documents/search', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query, top_k: 5 })
                });
                
                const data = await response.json();
                
                if (!data.results || data.results.length === 0) {
                    resultsDiv.innerHTML = '<p class="text-secondary">No results found.</p>';
                    return;
                }
                
                resultsDiv.innerHTML = data.results.map((r, i) => `
                    <div class="p-3 bg-tertiary rounded-lg">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-sm font-medium">${r.document_name}</span>
                            <span class="text-xs text-accent">Score: ${(r.score * 100).toFixed(1)}%</span>
                        </div>
                        <p class="text-sm text-secondary">${r.chunk.content.substring(0, 300)}${r.chunk.content.length > 300 ? '...' : ''}</p>
                    </div>
                `).join('');
            } catch (e) {
                resultsDiv.innerHTML = `<p class="text-red-400">Search failed: ${e.message}</p>`;
            }
        }
        
        // Drag & Drop handlers for RAG
        function handleRAGDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('border-accent');
        }
        
        function handleRAGDragLeave(event) {
            event.currentTarget.classList.remove('border-accent');
        }
        
        async function handleRAGDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('border-accent');
            
            const files = event.dataTransfer.files;
            await uploadRAGFiles(files);
        }
        
        async function handleRAGFileSelect(event) {
            const files = event.target.files;
            await uploadRAGFiles(files);
            event.target.value = ''; // Reset for next upload
        }
        
        async function uploadRAGFiles(files) {
            if (!ragEnabled) {
                showAlert('Please enable RAG first by selecting an embedding model', 'warning');
                return;
            }
            
            for (const file of files) {
                const formData = new FormData();
                formData.append('file', file);
                
                try {
                    const response = await fetch('/v1/documents/ingest', {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        const err = await response.json();
                        throw new Error(err.error || 'Failed to upload');
                    }
                } catch (e) {
                    showAlert(`Failed to upload ${file.name}: ${e.message}`, 'error');
                }
            }
            
            refreshRAGDocuments();
        }
        
        // ==================== Benchmark Functions ====================
        
        let benchmarkHistory = JSON.parse(localStorage.getItem('offgrid_benchmarks') || '[]');
        
        async function loadBenchmarkModels() {
            try {
                const response = await fetch('/v1/models');
                const data = await response.json();
                const select = document.getElementById('benchmarkModel');
                select.innerHTML = '<option value="">Choose a model...</option>';
                
                // Filter for LLM models (not embeddings)
                const llmModels = data.data.filter(m => 
                    !m.id.toLowerCase().includes('embed') && 
                    !m.id.toLowerCase().includes('minilm') &&
                    !m.id.toLowerCase().includes('bge')
                );
                
                llmModels.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.id;
                    select.appendChild(option);
                });
            } catch (e) {
                console.error('Failed to load models:', e);
            }
        }
        
        async function loadSystemInfo() {
            try {
                const response = await fetch('/v1/system/info');
                const data = await response.json();
                
                // Format CPU - truncate if too long
                let cpuName = data.cpu || 'Unknown';
                if (cpuName.length > 40) {
                    cpuName = cpuName.substring(0, 37) + '...';
                }
                document.getElementById('sysInfoCPU').textContent = cpuName;
                document.getElementById('sysInfoCPU').title = data.cpu || 'Unknown'; // Full name on hover
                
                // Format RAM
                if (data.total_memory) {
                    const totalGB = (data.total_memory / 1024 / 1024 / 1024).toFixed(1);
                    const freeGB = data.free_memory ? (data.free_memory / 1024 / 1024 / 1024).toFixed(1) : '?';
                    document.getElementById('sysInfoRAM').textContent = `${totalGB} GB`;
                    document.getElementById('sysInfoRAM').title = `${freeGB} GB available`;
                } else {
                    document.getElementById('sysInfoRAM').textContent = 'Unknown';
                }
                
                // Format GPU
                let gpuName = data.gpu || 'CPU only';
                if (gpuName.length > 30) {
                    gpuName = gpuName.substring(0, 27) + '...';
                }
                document.getElementById('sysInfoGPU').textContent = gpuName;
                if (data.gpu_memory) {
                    const gpuMemGB = (data.gpu_memory / 1024 / 1024 / 1024).toFixed(1);
                    document.getElementById('sysInfoGPU').title = `${data.gpu} (${gpuMemGB} GB VRAM)`;
                } else {
                    document.getElementById('sysInfoGPU').title = data.gpu || 'CPU only';
                }
                
                // Backend
                document.getElementById('sysInfoBackend').textContent = data.backend || 'llama.cpp';
                
            } catch (e) {
                console.error('Failed to load system info:', e);
                document.getElementById('sysInfoCPU').textContent = 'Error loading';
                document.getElementById('sysInfoRAM').textContent = 'Error loading';
                document.getElementById('sysInfoGPU').textContent = 'Error loading';
            }
        }
        
        async function runBenchmark() {
            const model = document.getElementById('benchmarkModel').value;
            if (!model) {
                showAlert('Please select a model first', 'warning');
                return;
            }
            
            const promptLength = document.getElementById('benchmarkPromptLength').value;
            const outputTokens = parseInt(document.getElementById('benchmarkOutputTokens').value);
            
            const btn = document.getElementById('benchmarkRunBtn');
            const progress = document.getElementById('benchmarkProgress');
            btn.disabled = true;
            btn.innerHTML = '<svg class="w-4 h-4 mr-2 animate-spin" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path></svg>Running...';
            progress.classList.remove('hidden');
            
            // Generate test prompt based on length
            let prompt = '';
            switch (promptLength) {
                case 'short':
                    prompt = 'Write a haiku about programming.';
                    break;
                case 'medium':
                    prompt = 'Explain the concept of recursion in programming. Include an example and discuss when it should be used versus iteration.';
                    break;
                case 'long':
                    prompt = 'Write a comprehensive guide on building a REST API. Cover the following topics: 1) What is REST and its principles, 2) HTTP methods and status codes, 3) Authentication and authorization, 4) Error handling, 5) Best practices for API design. Include code examples where appropriate.';
                    break;
            }
            
            const startTime = performance.now();
            let firstTokenTime = null;
            let tokenCount = 0;
            
            try {
                const response = await fetch('/v1/chat/completions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: model,
                        messages: [{ role: 'user', content: prompt }],
                        max_tokens: outputTokens,
                        stream: true
                    })
                });
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                            try {
                                const data = JSON.parse(line.slice(6));
                                if (data.choices && data.choices[0].delta && data.choices[0].delta.content) {
                                    if (!firstTokenTime) {
                                        firstTokenTime = performance.now();
                                    }
                                    tokenCount++;
                                    
                                    // Update progress
                                    const percent = Math.min((tokenCount / outputTokens) * 100, 100);
                                    document.getElementById('benchmarkProgressBar').style.width = percent + '%';
                                    document.getElementById('benchmarkPercent').textContent = Math.round(percent) + '%';
                                    
                                    // Update live metrics
                                    const elapsed = (performance.now() - startTime) / 1000;
                                    document.getElementById('benchLiveTokensPerSec').textContent = (tokenCount / elapsed).toFixed(1);
                                    if (firstTokenTime) {
                                        document.getElementById('benchLiveTimeToFirst').textContent = Math.round(firstTokenTime - startTime);
                                    }
                                    document.getElementById('benchLiveTotalTime').textContent = elapsed.toFixed(2);
                                }
                            } catch (e) { }
                        }
                    }
                }
                
                const endTime = performance.now();
                const totalTime = (endTime - startTime) / 1000;
                const ttft = firstTokenTime ? (firstTokenTime - startTime) : 0;
                const tokensPerSec = tokenCount / totalTime;
                
                // Get memory usage from health endpoint
                let memoryGB = '--';
                try {
                    const healthRes = await fetch('/health');
                    const healthData = await healthRes.json();
                    if (healthData.system && healthData.system.memory_mb) {
                        memoryGB = (healthData.system.memory_mb / 1024).toFixed(2);
                        document.getElementById('benchLiveMemory').textContent = memoryGB;
                    }
                } catch (e) { }
                
                // Save to history
                const result = {
                    model,
                    tokensPerSec: tokensPerSec.toFixed(1),
                    ttft: Math.round(ttft),
                    totalTime: totalTime.toFixed(2),
                    memory: memoryGB,
                    date: new Date().toLocaleString(),
                    promptLength,
                    outputTokens
                };
                
                benchmarkHistory.unshift(result);
                benchmarkHistory = benchmarkHistory.slice(0, 20); // Keep last 20
                localStorage.setItem('offgrid_benchmarks', JSON.stringify(benchmarkHistory));
                
                renderBenchmarkHistory();
                
            } catch (e) {
                showAlert('Benchmark failed: ' + e.message, 'error');
            } finally {
                btn.disabled = false;
                btn.innerHTML = '<svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>Run Benchmark';
                progress.classList.add('hidden');
            }
        }
        
        function renderBenchmarkHistory() {
            const table = document.getElementById('benchmarkHistoryTable');
            const chart = document.getElementById('benchmarkChart');
            
            if (benchmarkHistory.length === 0) {
                table.innerHTML = '<tr><td colspan="6" class="text-center py-4 text-secondary">No benchmarks yet</td></tr>';
                chart.innerHTML = '<p class="text-secondary text-sm text-center py-4">Run benchmarks to see comparison charts</p>';
                return;
            }
            
            // Render table
            table.innerHTML = benchmarkHistory.map(r => `
                <tr class="border-b border-theme">
                    <td class="py-2 px-3">${r.model}</td>
                    <td class="text-right py-2 px-3 font-mono">${r.tokensPerSec}</td>
                    <td class="text-right py-2 px-3 font-mono">${r.ttft}</td>
                    <td class="text-right py-2 px-3 font-mono">${r.totalTime}s</td>
                    <td class="text-right py-2 px-3 font-mono">${r.memory}</td>
                    <td class="text-right py-2 px-3 text-secondary text-xs">${r.date}</td>
                </tr>
            `).join('');
            
            // Render simple bar chart for tokens/sec
            const maxTokens = Math.max(...benchmarkHistory.map(r => parseFloat(r.tokensPerSec)));
            chart.innerHTML = benchmarkHistory.slice(0, 5).map(r => {
                const width = (parseFloat(r.tokensPerSec) / maxTokens) * 100;
                return `
                    <div class="flex items-center gap-3">
                        <div class="w-32 truncate text-sm">${r.model.split('/').pop()}</div>
                        <div class="flex-1 bg-tertiary rounded-full h-4 overflow-hidden">
                            <div class="bg-accent h-full rounded-full transition-all" style="width: ${width}%"></div>
                        </div>
                        <div class="w-20 text-right text-sm font-mono">${r.tokensPerSec} t/s</div>
                    </div>
                `;
            }).join('');
        }
        
        function clearBenchmarkHistory() {
            showConfirm('Clear all benchmark history?', () => {
                benchmarkHistory = [];
                localStorage.removeItem('offgrid_benchmarks');
                renderBenchmarkHistory();
            }, { title: 'Clear History', confirmText: 'Clear All', type: 'warning' });
        }

        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            // Restore active tab
            const savedTab = localStorage.getItem('offgrid_active_tab');
            if (savedTab && document.getElementById('tab-' + savedTab)) {
                switchTab(savedTab);
            } else {
                switchTab('chat');
            }
            
            // Load saved messages
            loadMessages();
            
            // Load chat models
            loadChatModels();
            
            // Setup Knowledge Base toggle indicator
            const kbCheckbox = document.getElementById('useKnowledgeBase');
            const ragIndicator = document.getElementById('ragIndicator');
            const ragIndicatorText = document.getElementById('ragIndicatorText');
            
            // Restore saved preference
            const savedKbPref = localStorage.getItem('offgrid_use_knowledge_base');
            if (savedKbPref === 'true') {
                kbCheckbox.checked = true;
                ragIndicator.classList.remove('hidden');
                ragIndicatorText.classList.remove('hidden');
            }
            
            kbCheckbox.addEventListener('change', async () => {
                if (kbCheckbox.checked) {
                    // Check if RAG is enabled on the server
                    try {
                        const response = await fetch('/v1/rag/status');
                        const data = await response.json();
                        if (!data.enabled) {
                            showAlert('Knowledge Base is not enabled on the server. Go to the Knowledge Base tab and enable RAG first.', 'warning');
                            kbCheckbox.checked = false;
                            return;
                        }
                        if (!data.stats || data.stats.document_count === 0) {
                            showAlert('No documents in knowledge base. Upload some documents in the Knowledge Base tab first.', 'warning');
                        }
                    } catch (e) {
                        console.error('Failed to check RAG status:', e);
                    }
                    ragIndicator.classList.remove('hidden');
                    ragIndicatorText.classList.remove('hidden');
                    localStorage.setItem('offgrid_use_knowledge_base', 'true');
                } else {
                    ragIndicator.classList.add('hidden');
                    ragIndicatorText.classList.add('hidden');
                    localStorage.setItem('offgrid_use_knowledge_base', 'false');
                }
            });
        });

        // Theme Toggle Logic
        const themeToggleBtn = document.getElementById('theme-toggle');
        const htmlElement = document.documentElement;
        
        // Check for saved theme preference or system preference
        const savedTheme = localStorage.getItem('theme');
        const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        
        // Set initial theme
        if (savedTheme === 'dark' || (!savedTheme && systemTheme === 'dark')) {
            htmlElement.setAttribute('data-theme', 'dark');
        } else {
            htmlElement.removeAttribute('data-theme');
        }
        
        themeToggleBtn.addEventListener('click', () => {
            if (htmlElement.getAttribute('data-theme') === 'dark') {
                htmlElement.removeAttribute('data-theme');
                localStorage.setItem('theme', 'light');
            } else {
                htmlElement.setAttribute('data-theme', 'dark');
                localStorage.setItem('theme', 'dark');
            }
        });
    </script>

    <!-- File Browser Modal -->
    <div id="fileBrowserModal" class="modal-overlay" style="display: none;">
        <div class="modal-dialog" style="max-width: 700px; max-height: 80vh; overflow: hidden; display: flex; flex-direction: column;">
            <div class="modal-header">
                <span class="modal-icon"></span>
                <h3 class="modal-title">Select Folder</h3>
            </div>
            <div class="modal-body" style="flex: 1; overflow: hidden; display: flex; flex-direction: column;">
                <!-- Common Paths -->
                <div class="mb-3">
                    <div class="text-xs text-secondary mb-2">Quick Access:</div>
                    <div id="commonPathsList" class="flex flex-wrap gap-2"></div>
                </div>
                
                <!-- Current Path and Navigation -->
                <div class="mb-3">
                    <div class="text-xs text-secondary mb-1">Current Path:</div>
                    <div class="flex gap-2">
                        <input type="text" id="browserCurrentPath" readonly 
                               class="flex-1 input-theme rounded px-3 py-2 text-xs font-mono bg-secondary" />
                        <button onclick="browseParentDir()" class="btn btn-secondary px-3" title="Go up one level">
                            Up
                        </button>
                        <button onclick="refreshBrowser()" class="btn btn-secondary px-3" title="Refresh">
                            Refresh
                        </button>
                    </div>
                </div>
                
                <!-- File List -->
                <div style="flex: 1; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 4px;">
                    <div id="browserFileList" class="text-sm"></div>
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeFileBrowser()">Cancel</button>
                <button class="btn btn-primary" onclick="selectCurrentPath()">Select Current Folder</button>
            </div>
        </div>
    </div>

    <script>
        // File Browser functionality
        let currentBrowserPath = '';
        let fileBrowserTarget = ''; // 'import' or 'export'
        
        async function browseForPath(target) {
            fileBrowserTarget = target;
            const modal = document.getElementById('fileBrowserModal');
            modal.style.display = 'flex';
            
            // Load common paths
            await loadCommonPaths();
            
            // Browse to default path
            const currentPath = target === 'import' 
                ? document.getElementById('usbImportPath').value 
                : document.getElementById('usbExportPath').value;
            
            await browseTo(currentPath || '');
        }
        
        async function loadCommonPaths() {
            const container = document.getElementById('commonPathsList');
            container.innerHTML = '<span class="text-xs text-secondary">Loading...</span>';
            
            try {
                const response = await fetch('/v1/filesystem/common-paths');
                const data = await response.json();
                
                if (response.ok && data.paths) {
                    container.innerHTML = data.paths
                        .filter(p => p.exists)
                        .map(p => `
                            <button onclick="browseTo('${p.path.replace(/'/g, "\\'")}')" 
                                    class="px-3 py-1 text-xs bg-secondary hover:bg-accent hover:text-white rounded border border-theme transition-colors"
                                    title="${p.description}">
                                ${p.label}
                            </button>
                        `).join('');
                } else {
                    container.innerHTML = '<span class="text-xs text-red-400">Failed to load paths</span>';
                }
            } catch (error) {
                container.innerHTML = '<span class="text-xs text-red-400">Error loading paths</span>';
            }
        }
        
        async function browseTo(path) {
            const listContainer = document.getElementById('browserFileList');
            const pathInput = document.getElementById('browserCurrentPath');
            
            listContainer.innerHTML = '<div class="p-4 text-center text-secondary text-sm">Loading...</div>';
            
            try {
                const response = await fetch('/v1/filesystem/browse', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: path })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    currentBrowserPath = data.current_path;
                    pathInput.value = currentBrowserPath;
                    
                    let html = '';
                    
                    // Add directories
                    if (data.directories && data.directories.length > 0) {
                        const visibleDirs = data.directories.filter(d => !d.is_hidden);
                        visibleDirs.forEach(dir => {
                            html += `
                                <div class="file-entry directory" onclick="browseTo('${dir.path.replace(/'/g, "\\'")}')">
                                    <span class="file-icon">▸</span>
                                    <span class="file-name">${dir.name}</span>
                                </div>
                            `;
                        });
                    }
                    
                    // Show message if no directories
                    if (!html) {
                        html = '<div class="p-4 text-center text-secondary text-sm">No subdirectories</div>';
                    }
                    
                    listContainer.innerHTML = html;
                } else {
                    listContainer.innerHTML = `<div class="p-4 text-center text-red-400 text-sm">${data.error || 'Failed to browse'}</div>`;
                }
            } catch (error) {
                listContainer.innerHTML = `<div class="p-4 text-center text-red-400 text-sm">Error: ${error.message}</div>`;
            }
        }
        
        function browseParentDir() {
            const pathInput = document.getElementById('browserCurrentPath');
            const currentPath = pathInput.value;
            
            // Extract parent path
            const parts = currentPath.split('/').filter(p => p);
            if (parts.length > 0) {
                parts.pop();
                const parentPath = '/' + parts.join('/');
                browseTo(parentPath || '/');
            }
        }
        
        function refreshBrowser() {
            const pathInput = document.getElementById('browserCurrentPath');
            browseTo(pathInput.value);
        }
        
        function selectCurrentPath() {
            const pathInput = document.getElementById('browserCurrentPath');
            const selectedPath = pathInput.value;
            
            if (fileBrowserTarget === 'import') {
                document.getElementById('usbImportPath').value = selectedPath;
            } else {
                document.getElementById('usbExportPath').value = selectedPath;
            }
            
            closeFileBrowser();
        }
        
        function closeFileBrowser() {
            const modal = document.getElementById('fileBrowserModal');
            modal.style.display = 'none';
        }
        
        // Close modal when clicking outside
        document.getElementById('fileBrowserModal')?.addEventListener('click', (e) => {
            if (e.target.id === 'fileBrowserModal') {
                closeFileBrowser();
            }
        });
    </script>

    <style>
        .file-entry {
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background-color 0.15s;
            border-bottom: 1px solid var(--border-color);
        }
        
        .file-entry:hover {
            background-color: var(--bg-secondary);
        }
        
        .file-entry.directory {
            font-weight: 500;
        }
        
        .file-icon {
            font-size: 16px;
            width: 20px;
            text-align: center;
        }
        
        .file-name {
            flex: 1;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
        }
    </style>
</body>
</html>
