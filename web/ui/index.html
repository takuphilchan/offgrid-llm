<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OffGrid LLM</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
    <!-- Marked.js for Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif;
        }
        
        body { 
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #e2e8f0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .card { 
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.95) 0%, rgba(51, 65, 85, 0.9) 100%);
            border: 1px solid rgba(51, 65, 85, 0.8);
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            backdrop-filter: blur(10px);
        }
        
        .card:hover {
            border-color: rgba(6, 182, 212, 0.5);
            box-shadow: 0 4px 20px rgba(6, 182, 212, 0.15);
        }
        
        .btn {
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s ease, box-shadow 0.2s ease;
            border: none;
            font-size: 13px;
            font-weight: 600;
            outline: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .btn:hover:not(:disabled) {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .btn-sm { 
            padding: 6px 14px; 
            font-size: 12px; 
        }
        
        .btn:disabled { 
            opacity: 0.5; 
            cursor: not-allowed;
        }
        
        .btn-primary { 
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: white; 
        }
        
        .btn-primary:hover:not(:disabled) { 
            background: linear-gradient(135deg, #0891b2 0%, #0e7490 100%);
        }
        
        .btn-secondary { 
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
            color: white; 
        }
        
        .btn-secondary:hover:not(:disabled) { 
            background: linear-gradient(135deg, #475569 0%, #334155 100%);
        }
        
        .btn-danger { 
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white; 
        }
        
        .btn-danger:hover:not(:disabled) { 
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
        }
        
        .btn-info { 
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: white; 
        }
        
        .btn-info:hover:not(:disabled) { 
            background: linear-gradient(135deg, #0891b2 0%, #0e7490 100%);
        }
        
        .tab { 
            padding: 14px 24px; 
            cursor: pointer; 
            border-bottom: 3px solid transparent; 
            transition: all 0.2s ease;
            font-weight: 500;
        }
        
        .tab:hover { 
            background: rgba(30, 41, 59, 0.5);
            color: #06b6d4;
        }
        
        .tab.active { 
            border-bottom-color: #06b6d4;
            background: rgba(30, 41, 59, 0.8);
            color: #06b6d4;
        }
        
        .message { 
            padding: 20px 0;
            margin-bottom: 0;
            word-wrap: break-word;
            border-bottom: 1px solid rgba(51, 65, 85, 0.3);
        }
        
        .message:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        
        .message-wrapper {
            max-width: 56rem;
            margin: 0 auto;
        }
        
        .message-user { 
            background: transparent;
        }
        
        .message-user .message-wrapper {
            display: flex;
            gap: 1rem;
            align-items: flex-start;
        }
        
        .message-assistant { 
            background: rgba(30, 41, 59, 0.3);
        }
        
        .message-assistant .message-wrapper {
            display: flex;
            gap: 1rem;
            align-items: flex-start;
        }
        
        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 4px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
        }
        
        .message-user .message-avatar {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }
        
        .message-assistant .message-avatar {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: white;
        }
        
        .message-body {
            flex: 1;
            min-width: 0;
        }
        
        .message-actions { 
            display: flex; 
            gap: 8px; 
            margin-top: 12px; 
        }
        
        /* Modal Overlay Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            animation: fadeIn 0.2s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .modal-dialog {
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.98) 0%, rgba(51, 65, 85, 0.98) 100%);
            border: 1px solid rgba(51, 65, 85, 0.8);
            border-radius: 16px;
            padding: 32px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .modal-dialog.warning {
            border-color: rgba(245, 158, 11, 0.6);
            box-shadow: 0 20px 60px rgba(245, 158, 11, 0.2);
        }
        
        .modal-dialog.error {
            border-color: rgba(239, 68, 68, 0.6);
            box-shadow: 0 20px 60px rgba(239, 68, 68, 0.2);
        }
        
        .modal-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .modal-icon {
            font-size: 32px;
            line-height: 1;
        }
        
        .modal-title {
            font-size: 20px;
            font-weight: 700;
            color: #e5e7eb;
        }
        
        .modal-body {
            margin-bottom: 24px;
            color: #d1d5db;
            line-height: 1.6;
        }
        
        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }
        
        .terminal-card {
            background: #1e1e1e !important;
            background-image: none !important;
            border: 1px solid #3e3e42 !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4) !important;
            backdrop-filter: none !important;
        }
        
        .terminal-card:hover {
            border-color: #3e3e42 !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4) !important;
        }
        
        .terminal { 
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 8px;
            padding: 16px;
            font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
            font-size: 15px;
            overflow-y: auto;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.5);
        }
        
        .terminal-output { 
            height: 500px;
            overflow-y: auto; 
            margin-bottom: 12px; 
            line-height: 1.6;
            background: #1e1e1e;
        }
        
        .terminal-line { 
            color: #d4d4d4; 
            margin-bottom: 2px; 
            white-space: pre; 
            word-break: break-word; 
            font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
        }
        
        /* ANSI color classes - optimized for readability on dark background */
        .ansi-black { color: #555555; }
        .ansi-cyan { color: #4FC1FF; font-weight: 500; }
        .ansi-green { color: #4EC9B0; font-weight: 500; }
        .ansi-yellow { color: #DCDCAA; font-weight: 500; }
        .ansi-red { color: #F48771; font-weight: 500; }
        .ansi-blue { color: #569CD6; font-weight: 500; }
        .ansi-magenta { color: #C586C0; font-weight: 500; }
        .ansi-purple { color: #C586C0; font-weight: 500; }
        .ansi-gray { color: #9d9d9d; }
        .ansi-white { color: #e5e5e5; }
        .ansi-bold { font-weight: 700; }
        .ansi-dim { color: #999999; font-weight: 400; }
        .ansi-normal { font-weight: 400; opacity: 1; }
        
        .terminal-error { 
            color: #ff6b6b; 
            font-weight: 600; 
        }
        
        .terminal-success { 
            color: #06b6d4; 
            font-weight: 600; 
        }
        
        .terminal-prompt { 
            color: #06b6d4; 
            font-weight: 700; 
        }
        
        .terminal-input-line { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            padding-top: 8px;
            border-top: 1px solid #30363d;
        }
        
        .terminal-input { 
            background: transparent; 
            border: none; 
            color: #06b6d4; 
            flex: 1; 
            outline: none; 
            font-family: inherit; 
            font-size: 15px; 
        }
        
        .terminal-running { 
            opacity: 0.6; 
            pointer-events: none; 
        }
        
        .model-item { 
            padding: 16px; 
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.9) 0%, rgba(51, 65, 85, 0.8) 100%);
            border: 1px solid rgba(51, 65, 85, 0.8);
            border-radius: 10px;
            margin-bottom: 10px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .model-item:hover { 
            background: linear-gradient(135deg, rgba(51, 65, 85, 0.9) 0%, rgba(71, 85, 105, 0.8) 100%);
            border-color: rgba(6, 182, 212, 0.5);
            box-shadow: 0 2px 8px rgba(6, 182, 212, 0.2);
        }
        
        .badge { 
            display: inline-block; 
            padding: 4px 12px; 
            border-radius: 6px; 
            font-size: 11px; 
            font-weight: 700;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .badge-success { 
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white; 
        }
        
        .badge-warning { 
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white; 
        }
        
        .badge-error { 
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white; 
        }
        
        .badge-info { 
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: white; 
        }
        
        .hidden { 
            display: none; 
        }
        
        input:focus, select:focus, textarea:focus { 
            outline: none; 
            border-color: #06b6d4;
            box-shadow: 0 0 0 3px rgba(6, 182, 212, 0.1);
        }
        
        .chat-container { 
            display: flex; 
            flex-direction: column; 
            height: calc(100vh - 220px);
            min-height: 600px;
        }
        
        .chat-messages { 
            flex: 1; 
            overflow-y: auto; 
            padding: 16px; 
        }
        
        .chat-input-area { 
            padding: 16px; 
            border-top: 1px solid rgba(51, 65, 85, 0.8);
            background: rgba(15, 23, 42, 0.5);
        }
        
        .scrollable { 
            overflow-y: auto; 
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            display: flex;
            flex-direction: column;
        }
        
        .scrollable::-webkit-scrollbar { 
            width: 10px; 
        }
        
        .scrollable::-webkit-scrollbar-track { 
            background: rgba(30, 41, 59, 0.5);
            border-radius: 5px;
        }
        
        .scrollable::-webkit-scrollbar-thumb { 
            background: linear-gradient(135deg, #64748b 0%, #475569 100%);
            border-radius: 5px; 
        }
        
        .scrollable::-webkit-scrollbar-thumb:hover { 
            background: linear-gradient(135deg, #475569 0%, #334155 100%);
        }
        
        .settings-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); 
            gap: 16px; 
        }
        
        .stat-card { 
            text-align: center; 
            padding: 20px;
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.8) 0%, rgba(51, 65, 85, 0.6) 100%);
            border-radius: 10px;
            transition: box-shadow 0.2s ease;
        }
        
        .stat-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .stat-value { 
            font-size: 32px; 
            font-weight: 700; 
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .stat-label { 
            font-size: 13px; 
            color: #94a3b8; 
            margin-top: 6px;
            font-weight: 500;
        }
        
        header {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.95) 0%, rgba(30, 41, 59, 0.95) 100%);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }
        
        nav {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.9) 0%, rgba(30, 41, 59, 0.9) 100%);
            backdrop-filter: blur(10px);
        }
        
        /* Code block styling */
        .message-content pre {
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 16px;
            margin: 12px 0;
            overflow-x: auto;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .message-content code {
            font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .message-content pre code {
            display: block;
            padding: 0;
            background: transparent;
            border: none;
        }
        
        .message-content :not(pre) > code {
            background: rgba(110, 118, 129, 0.4);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 13px;
            color: #e2e8f0;
        }
        
        /* Prose styling for markdown content */
        .message-content.prose {
            max-width: none;
        }
        
        .message-content.prose p {
            margin: 8px 0;
            line-height: 1.7;
        }
        
        .message-content.prose ul, 
        .message-content.prose ol {
            margin: 8px 0;
            padding-left: 24px;
        }
        
        .message-content.prose li {
            margin: 4px 0;
        }
        
        .message-content.prose h1,
        .message-content.prose h2,
        .message-content.prose h3,
        .message-content.prose h4 {
            margin: 16px 0 8px 0;
            font-weight: 600;
            color: #06b6d4;
        }
        
        .message-content.prose h1 { font-size: 1.5em; }
        .message-content.prose h2 { font-size: 1.3em; }
        .message-content.prose h3 { font-size: 1.1em; }
        
        .message-content.prose blockquote {
            border-left: 4px solid #06b6d4;
            padding-left: 16px;
            margin: 12px 0;
            color: #94a3b8;
            font-style: italic;
        }
        
        .message-content.prose a {
            color: #06b6d4;
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }
        
        .message-content.prose a:hover {
            border-bottom-color: #06b6d4;
        }
        
        .message-content.prose table {
            border-collapse: collapse;
            width: 100%;
            margin: 12px 0;
        }
        
        .message-content.prose th,
        .message-content.prose td {
            border: 1px solid #334155;
            padding: 8px 12px;
            text-align: left;
        }
        
        .message-content.prose th {
            background: rgba(6, 182, 212, 0.1);
            font-weight: 600;
            color: #06b6d4;
        }
    </style>
</head>
<body>
    <header class="bg-slate-900 border-b border-slate-700 px-6 py-4 flex-shrink-0">
        <div class="flex items-center justify-between">
            <h1 class="text-xl font-bold text-cyan-400">OffGrid LLM</h1>
            <div class="flex items-center gap-3">
                <span id="statusBadge" class="badge badge-success">Ready</span>
                <span class="text-xs text-slate-400">v0.1.5</span>
            </div>
        </div>
    </header>

    <nav class="bg-slate-900 border-b border-slate-700 px-6 flex-shrink-0">
        <div class="flex gap-1">
            <button onclick="switchTab('chat')" id="tab-chat" class="tab active">Chat</button>
            <button onclick="switchTab('sessions')" id="tab-sessions" class="tab">Sessions</button>
            <button onclick="switchTab('models')" id="tab-models" class="tab">Models</button>
            <button onclick="switchTab('terminal')" id="tab-terminal" class="tab">Terminal</button>
        </div>
    </nav>

    <main class="flex-1 flex flex-col overflow-hidden">
        <!-- Chat Tab -->
        <div id="content-chat" class="h-full flex flex-col overflow-hidden">
            <div class="card flex-shrink-0">
                <div class="flex items-center gap-3 flex-wrap mb-3">
                    <select id="chatModel" class="flex-1 min-w-[200px] bg-slate-800 border border-slate-600 rounded px-3 py-2 text-sm">
                        <option value="">Loading...</option>
                    </select>
                    <select id="systemPrompt" onchange="applySystemPrompt()" class="flex-1 min-w-[200px] bg-slate-800 border border-slate-600 rounded px-3 py-2 text-sm">
                        <option value="">No System Prompt</option>
                        <option value="research">Research Assistant</option>
                        <option value="tutor">Study Tutor</option>
                        <option value="coder">Code Reviewer</option>
                        <option value="writer">Academic Writer</option>
                        <option value="custom">Custom Prompt...</option>
                    </select>
                </div>
                <div class="flex items-center gap-3 flex-wrap">
                    <div class="flex gap-2 flex-wrap">
                        <label class="flex items-center gap-2 text-xs">
                            <input type="checkbox" id="streamToggle" checked class="rounded">
                            <span>Stream</span>
                        </label>
                        <label class="flex items-center gap-2 text-xs">
                            <span>Temp:</span>
                            <input type="number" id="temperature" value="0.7" step="0.1" min="0" max="2" 
                                   class="w-16 bg-slate-800 border border-slate-600 rounded px-2 py-1 text-xs">
                        </label>
                        <label class="flex items-center gap-2 text-xs">
                            <span>Max:</span>
                            <input type="number" id="maxTokens" value="1000" step="100" min="100" max="4000" 
                                   class="w-20 bg-slate-800 border border-slate-600 rounded px-2 py-1 text-xs">
                        </label>
                    </div>
                    <div class="flex gap-2 ml-auto">
                        <button onclick="saveCurrentSession()" class="btn btn-info btn-sm">Save Session</button>
                        <button onclick="showExportOptions()" class="btn btn-info btn-sm">Export</button>
                        <button onclick="clearChat()" class="btn btn-secondary btn-sm">Clear</button>
                    </div>
                </div>
            </div>

            <div class="flex-1 flex flex-col overflow-hidden" style="background: #0f172a;">
                <div id="chatMessages" class="flex-1 scrollable px-4 py-4">
                    <div class="text-center text-slate-400 py-32">
                        <p class="text-xl font-medium">Start a conversation</p>
                        <p class="text-sm mt-2 text-slate-500">Select a model and type your message below</p>
                    </div>
                </div>
                <div class="flex-shrink-0" style="background: #0f172a; border-top: 1px solid rgba(51, 65, 85, 0.5);">
                    <div class="max-w-3xl mx-auto py-4 px-4">
                        <div class="relative bg-slate-800 rounded-xl border border-slate-600 focus-within:border-cyan-500 transition-colors shadow-lg">
                            <textarea id="chatInput" placeholder="Message OffGrid LLM..." 
                               onkeydown="handleChatKeydown(event)"
                               oninput="autoResizeTextarea(this)"
                               rows="1"
                               style="max-height: 200px; min-height: 52px;"
                               class="w-full bg-transparent border-none px-4 py-3 pr-12 text-sm text-white resize-none focus:outline-none"></textarea>
                            <button onclick="sendChat()" id="sendBtn" 
                                    class="absolute right-2 bottom-2 w-8 h-8 rounded-lg bg-cyan-600 hover:bg-cyan-700 disabled:bg-slate-600 disabled:cursor-not-allowed transition-colors flex items-center justify-center">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" class="text-white">
                                    <path d="M.5 1.163A1 1 0 0 1 1.97.28l12.868 6.837a1 1 0 0 1 0 1.766L1.969 15.72A1 1 0 0 1 .5 14.836V10.33a1 1 0 0 1 .816-.983L8.5 8 1.316 6.653A1 1 0 0 1 .5 5.67V1.163Z" fill="currentColor"/>
                                </svg>
                            </button>
                            <button onclick="stopGeneration()" id="stopBtn" 
                                    class="absolute right-2 bottom-2 w-8 h-8 rounded-lg bg-red-600 hover:bg-red-700 transition-colors items-center justify-center hidden">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" class="text-white">
                                    <rect x="3" y="3" width="10" height="10" rx="2" fill="currentColor"/>
                                </svg>
                            </button>
                        </div>
                        <div class="flex items-center justify-between mt-2 text-xs text-slate-500 px-1">
                            <div class="flex gap-3">
                                <span id="tokenCount">0 tokens</span>
                                <span>•</span>
                                <span id="messageCount">0 messages</span>
                            </div>
                            <span id="statusBadge" class="text-xs font-medium">Ready</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Sessions Tab -->
        <div id="content-sessions" class="hidden h-full overflow-auto px-6 py-4">
            <div class="card max-w-5xl mx-auto">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="text-lg font-semibold">Saved Sessions</h3>
                    <button onclick="createNewSession()" class="btn btn-primary btn-sm">New Session</button>
                </div>
                <div class="mb-4">
                    <input type="text" id="sessionSearch" placeholder="Search sessions..." 
                           onkeyup="filterSessions()"
                           class="w-full bg-slate-800 border border-slate-600 rounded px-3 py-2 text-sm" />
                </div>
                <div id="sessionsList" class="space-y-2">
                    <p class="text-sm text-slate-400 text-center py-8">No saved sessions yet. Start chatting and click 'Save' to preserve your conversations.</p>
                </div>
            </div>
        </div>

        <!-- Models Tab -->
        <div id="content-models" class="hidden h-full overflow-auto px-6 py-4">
            <div class="max-w-5xl mx-auto space-y-4">
            
            <!-- USB Import/Export Section -->
            <div class="card">
                <h3 class="text-lg font-semibold mb-4">USB Model Transfer</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <h4 class="text-sm font-medium mb-2 text-cyan-400">Import from USB</h4>
                        <p class="text-xs text-slate-400 mb-3">Load models from a USB drive prepared with OffGrid bundles</p>
                        <div class="flex gap-2">
                            <input type="text" id="usbImportPath" placeholder="/media/usb or /mnt/usb" 
                                   value="/media/usb"
                                   class="flex-1 bg-slate-800 border border-slate-600 rounded px-3 py-2 text-sm" />
                            <button onclick="importFromUSB()" class="btn btn-primary">Import</button>
                        </div>
                        <div id="usbImportStatus" class="mt-2 text-xs"></div>
                    </div>
                    <div>
                        <h4 class="text-sm font-medium mb-2 text-cyan-400">Export to USB</h4>
                        <p class="text-xs text-slate-400 mb-3">Create a portable bundle of your models on USB</p>
                        <div class="flex gap-2">
                            <input type="text" id="usbExportPath" placeholder="/media/usb or /mnt/usb" 
                                   value="/media/usb"
                                   class="flex-1 bg-slate-800 border border-slate-600 rounded px-3 py-2 text-sm" />
                            <button onclick="exportToUSB()" class="btn btn-primary">Export</button>
                        </div>
                        <div id="usbExportStatus" class="mt-2 text-xs"></div>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h3 class="text-lg font-semibold mb-4">Search & Download Models</h3>
                <div class="flex gap-2 mb-4">
                    <input type="text" id="searchQuery" placeholder="Search models (e.g., llama, phi, mistral)..." 
                           class="flex-1 bg-slate-800 border border-slate-600 rounded px-3 py-2 text-sm" />
                    <button onclick="searchModels()" class="btn btn-primary">Search</button>
                </div>
                <div id="searchResults" class="space-y-2"></div>
            </div>

            <div class="card">
                <h3 class="text-lg font-semibold mb-4">Installed Models</h3>
                <div id="installedModels" class="space-y-2">
                    <p class="text-sm text-slate-400">Loading...</p>
                </div>
            </div>
            </div>
        </div>

        <!-- Terminal Tab -->
        <div id="content-terminal" class="hidden h-full flex flex-col px-6 py-4">
            <div class="max-w-5xl mx-auto flex-1 flex flex-col gap-4 w-full">
            <div class="card terminal-card flex-1 flex flex-col overflow-hidden">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-lg font-semibold">Terminal</h3>
                    <div class="flex gap-2">
                        <button onclick="killCommand()" id="killBtn" class="btn btn-danger btn-sm hidden">Kill</button>
                        <button onclick="clearTerminal()" class="btn btn-secondary btn-sm">Clear</button>
                    </div>
                </div>
                <div class="terminal-output scrollable" id="terminalOutput">
                    <div class="terminal-line terminal-success">OffGrid Terminal v0.1.2</div>
                    <div class="terminal-line">Connected to real offgrid binary</div>
                    <div class="terminal-line">Type 'help' for available commands or 'offgrid --help' for all options</div>
                </div>
                <div class="terminal-input-line" id="terminalInputLine">
                    <span class="terminal-prompt">$</span>
                    <input type="text" id="terminalInput" placeholder="Enter command..." 
                           onkeydown="handleTerminalKeydown(event)"
                           class="terminal-input" autocomplete="off" />
                </div>
            </div>
            
            <div class="card flex-shrink-0">
                <h4 class="text-sm font-semibold mb-2">Quick Commands</h4>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-2">
                    <button onclick="runQuickCommand('offgrid list')" class="btn btn-secondary btn-sm">List Models</button>
                    <button onclick="runQuickCommand('offgrid info')" class="btn btn-secondary btn-sm">Server Info</button>
                    <button onclick="runQuickCommand('offgrid doctor')" class="btn btn-secondary btn-sm">Run Test</button>
                    <button onclick="runQuickCommand('offgrid help')" class="btn btn-secondary btn-sm">Help</button>
                </div>
            </div>
            </div>
        </div>
    </main>

    <script>
        let currentModel = '';
        let messages = [];
        let isGenerating = false;
        let abortController = null;
        let commandHistory = [];
        let historyIndex = -1;
        let terminalRunning = false;
        let currentTerminalAbort = null;
        let terminalChatMode = false;
        let terminalChatModel = '';
        let terminalChatHistory = [];
        
        // Session management
        let sessions = JSON.parse(localStorage.getItem('offgrid_sessions') || '[]');
        let currentSessionId = null;
        let currentSystemPrompt = '';
        
        // System prompts for different use cases
        const systemPrompts = {
            research: "You are a knowledgeable research assistant. Help users understand complex topics, find relevant information, and think critically about academic questions. Provide detailed, well-sourced responses with references when possible.",
            tutor: "You are a patient and encouraging tutor. Break down complex concepts into simple explanations, use analogies and examples, ask questions to check understanding, and adapt your teaching style to the student's level.",
            coder: "You are an expert code reviewer and programming mentor. Provide detailed code reviews, suggest improvements for readability and performance, explain best practices, and help debug issues. Format all code with proper syntax highlighting.",
            writer: "You are an academic writing assistant. Help with essay structure, grammar, clarity, citation formats, and academic tone. Provide constructive feedback and suggestions for improvement.",
        };
        
        // Request throttling to prevent system overload
        let lastRequestTime = 0;
        let requestCooldown = 300; // Minimum 300ms between requests
        let pendingRequest = false;

        // Tab switching
        function switchTab(tab) {
            document.querySelectorAll('[id^="content-"]').forEach(el => el.classList.add('hidden'));
            document.querySelectorAll('.tab').forEach(el => el.classList.remove('active'));
            document.getElementById('content-' + tab).classList.remove('hidden');
            document.getElementById('tab-' + tab).classList.add('active');
            
            if (tab === 'models') {
                loadInstalledModels();
                // Clear search input
                document.getElementById('searchQuery').value = '';
                document.getElementById('searchResults').innerHTML = '';
            }
            if (tab === 'sessions') {
                renderSessions();
            }
            if (tab === 'chat') {
                loadChatModels();
                updateChatStats();
            }
        }

        // Chat keyboard handler
        function handleChatKeydown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendChat();
            }
        }
        
        // Auto-resize textarea
        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 200) + 'px';
        }

        // Terminal keyboard handler
        function handleTerminalKeydown(event) {
            const input = event.target;
            
            if (event.key === 'Enter') {
                event.preventDefault();
                runCommand();
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    input.value = commandHistory[historyIndex] || '';
                }
            } else if (event.key === 'ArrowDown') {
                event.preventDefault();
                if (historyIndex > 0) {
                    historyIndex--;
                    input.value = commandHistory[historyIndex] || '';
                } else if (historyIndex === 0) {
                    historyIndex = -1;
                    input.value = '';
                }
            } else if (event.key === 'Tab') {
                event.preventDefault();
                autocompleteCommand(input);
            }
        }

        function autocompleteCommand(input) {
            const val = input.value;
            const commands = [
                'offgrid list',
                'offgrid download ',
                'offgrid remove ',
                'offgrid search ',
                'offgrid run ',
                'offgrid info',
                'offgrid doctor',
                'offgrid --help',
                'offgrid --version',
                'help',
                'clear',
                'history'
            ];
            const match = commands.find(cmd => cmd.startsWith(val));
            if (match) {
                input.value = match;
            }
        }

        function updateChatStats() {
            document.getElementById('messageCount').textContent = `${messages.length} messages`;
            const totalTokens = messages.reduce((sum, m) => sum + (m.content?.length || 0), 0);
            document.getElementById('tokenCount').textContent = `~${Math.ceil(totalTokens / 4)} tokens`;
        }

        // Load models for chat
        async function loadChatModels() {
            try {
                const resp = await fetch('/models');
                const data = await resp.json();
                const models = data.data || [];
                const select = document.getElementById('chatModel');
                select.innerHTML = '';
                
                if (models.length === 0) {
                    select.innerHTML = '<option value="">No models available</option>';
                    return;
                }
                
                models.forEach(m => {
                    const opt = document.createElement('option');
                    opt.value = m.id;
                    opt.textContent = m.id;
                    select.appendChild(opt);
                });
                
                // Auto-select first model if none selected
                if (!currentModel && models.length > 0) {
                    currentModel = models[0].id;
                    select.value = currentModel;
                }

                // Add change handler
                select.onchange = handleModelChange;
            } catch (e) {
                console.error('Failed to load models:', e);
                document.getElementById('chatModel').innerHTML = '<option value="">Error loading models</option>';
            }
        }

        // Handle model dropdown change
        function handleModelChange() {
            const select = document.getElementById('chatModel');
            const newModel = select.value;
            
            console.log('[MODEL CHANGE] Dropdown changed to:', newModel);
            console.log('[MODEL CHANGE] Current model:', currentModel);
            
            if (!newModel) {
                console.log('[MODEL CHANGE] No model selected, ignoring');
                return;
            }
            
            // Just update the current model - don't clear chat or show confirmation
            // The backend will switch models automatically on next message
            const oldModel = currentModel;
            currentModel = newModel;
            
            console.log('[MODEL CHANGE] Switched from', oldModel, 'to', newModel);
            
            // Update status badge
            const statusBadge = document.getElementById('statusBadge');
            statusBadge.className = 'badge badge-success';
            statusBadge.textContent = `Ready (${newModel})`;
        }

        // Modal dialog system
        function showModal({ type = 'info', title, message, confirmText = 'OK', cancelText = 'Cancel', onConfirm, onCancel }) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const iconMap = {
                warning: '⚠️',
                error: '❌',
                info: 'ℹ️',
                success: '✓'
            };
            
            overlay.innerHTML = `
                <div class="modal-dialog ${type}">
                    <div class="modal-header">
                        <span class="modal-icon">${iconMap[type] || iconMap.info}</span>
                        <h3 class="modal-title">${title}</h3>
                    </div>
                    <div class="modal-body">
                        ${message}
                    </div>
                    <div class="modal-actions">
                        ${cancelText ? `<button class="btn btn-secondary" data-action="cancel">${cancelText}</button>` : ''}
                        <button class="btn ${type === 'error' ? 'btn-danger' : 'btn-primary'}" data-action="confirm">${confirmText}</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Handle clicks
            overlay.addEventListener('click', (e) => {
                if (e.target.classList.contains('modal-overlay')) {
                    overlay.remove();
                    if (onCancel) onCancel();
                }
            });
            
            overlay.querySelector('[data-action="confirm"]')?.addEventListener('click', () => {
                overlay.remove();
                if (onConfirm) onConfirm();
            });
            
            overlay.querySelector('[data-action="cancel"]')?.addEventListener('click', () => {
                overlay.remove();
                if (onCancel) onCancel();
            });
        }

        // Clear chat
        function clearChat() {
            if (messages.length === 0) return;
            
            showModal({
                type: 'error',
                title: 'Clear All Messages?',
                message: `This will delete all <strong>${messages.length} messages</strong> in the conversation.`,
                confirmText: 'Clear Chat',
                cancelText: 'Cancel',
                onConfirm: () => {
                    messages = [];
                    const chatMessages = document.getElementById('chatMessages');
                    chatMessages.innerHTML = '';
                    updateChatStats();
                }
            });
        }

        // Export chat with enhanced options
        function showExportOptions() {
            if (messages.length === 0) {
                showModal({
                    type: 'warning',
                    title: 'No Messages',
                    message: 'There are no messages to export yet.',
                    confirmText: 'OK',
                    cancelText: null
                });
                return;
            }
            const format = prompt('Export format:\n1. Markdown (recommended for research)\n2. Plain text\n3. JSON\n\nEnter 1, 2, or 3:', '1');
            if (!format) return;
            
            let content, mimeType, extension;
            const timestamp = new Date().toISOString().split('T')[0];
            const filename = `chat-${currentModel}-${timestamp}`;
            
            if (format === '1') {
                // Markdown format with code blocks
                content = `# Chat with ${currentModel}\n**Date:** ${new Date().toLocaleString()}\n**Messages:** ${messages.length}\n\n---\n\n`;
                messages.forEach(m => {
                    content += `## ${m.role === 'user' ? 'User' : 'Assistant'}\n\n`;
                    // Detect and format code blocks
                    const hasCode = m.content.includes('```');
                    content += hasCode ? m.content : m.content.replace(/`([^`]+)`/g, '`$1`');
                    content += '\n\n---\n\n';
                });
                mimeType = 'text/markdown';
                extension = 'md';
            } else if (format === '3') {
                // JSON format for programmatic access
                content = JSON.stringify({
                    model: currentModel,
                    timestamp: new Date().toISOString(),
                    messageCount: messages.length,
                    messages: messages
                }, null, 2);
                mimeType = 'application/json';
                extension = 'json';
            } else {
                // Plain text
                content = messages.map(m => `${m.role.toUpperCase()}: ${m.content}`).join('\n\n');
                mimeType = 'text/plain';
                extension = 'txt';
            }
            
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename}.${extension}`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // System prompt functions
        function applySystemPrompt() {
            const select = document.getElementById('systemPrompt');
            const value = select.value;
            
            if (value === 'custom') {
                const custom = prompt('Enter your custom system prompt:');
                if (custom) {
                    currentSystemPrompt = custom;
                    showModal({
                        type: 'success',
                        title: 'Success',
                        message: 'Custom prompt applied',
                        confirmText: 'OK'
                    });
                }
            } else if (value) {
                currentSystemPrompt = systemPrompts[value];
                showModal({
                    type: 'success',
                    title: 'Success',
                    message: `${select.options[select.selectedIndex].text} mode activated`,
                    confirmText: 'OK'
                });
            } else {
                currentSystemPrompt = '';
            }
        }

        // Session Management Functions
        function saveCurrentSession() {
            if (messages.length === 0) {
                showModal({
                    type: 'error',
                    title: 'Cannot Save',
                    message: 'No messages to save',
                    confirmText: 'OK'
                });
                return;
            }
            
            const title = prompt('Enter a title for this session:', `Chat ${new Date().toLocaleDateString()}`);
            if (!title) return;
            
            const session = {
                id: currentSessionId || Date.now(),
                title: title,
                model: currentModel,
                messages: [...messages],
                systemPrompt: currentSystemPrompt,
                timestamp: new Date().toISOString(),
                messageCount: messages.length
            };
            
            const existingIndex = sessions.findIndex(s => s.id === session.id);
            if (existingIndex >= 0) {
                sessions[existingIndex] = session;
            } else {
                sessions.unshift(session);
                currentSessionId = session.id;
            }
            
            localStorage.setItem('offgrid_sessions', JSON.stringify(sessions));
            showModal({
                type: 'success',
                title: 'Saved',
                message: `Session saved: "${title}"`,
                confirmText: 'OK'
            });
        }

        function renderSessions() {
            const container = document.getElementById('sessionsList');
            
            if (sessions.length === 0) {
                container.innerHTML = '<p class="text-sm text-slate-400 text-center py-8">No saved sessions yet. Start chatting and click \'Save\' to preserve your conversations.</p>';
                return;
            }
            
            container.innerHTML = sessions.map(session => `
                <div class="card hover:border-cyan-500 cursor-pointer" data-session-id="${session.id}">
                    <div class="flex items-start justify-between">
                        <div class="flex-1" onclick="loadSession(${session.id})">
                            <h4 class="font-semibold text-cyan-400 mb-1">${session.title}</h4>
                            <p class="text-xs text-slate-400 mb-2">
                                ${session.model} • ${session.messageCount} messages • ${new Date(session.timestamp).toLocaleString()}
                            </p>
                            <p class="text-xs text-slate-500 line-clamp-2">${session.messages[0]?.content.substring(0, 100)}...</p>
                        </div>
                        <button onclick="deleteSession(${session.id}); event.stopPropagation();" class="btn btn-danger btn-sm ml-2">Delete</button>
                    </div>
                </div>
            `).join('');
        }

        function loadSession(id) {
            const session = sessions.find(s => s.id === id);
            if (!session) return;
            
            if (messages.length > 0) {
                showModal({
                    type: 'warning',
                    title: 'Load Session?',
                    message: 'Current chat will be replaced. Continue?',
                    confirmText: 'Load Session',
                    cancelText: 'Cancel',
                    onConfirm: () => {
                        messages = [...session.messages];
                        currentModel = session.model;
                        currentSessionId = session.id;
                        currentSystemPrompt = session.systemPrompt || '';
                        
                        // Update UI
                        document.getElementById('chatModel').value = currentModel;
                        const chatMessages = document.getElementById('chatMessages');
                        chatMessages.innerHTML = '';
                        messages.forEach(m => {
                            addChatMessage(m.role, m.content);
                        });
                        
                        switchTab('chat');
                        showModal({
                            type: 'success',
                            title: 'Loaded',
                            message: `Session loaded: "${session.title}"`,
                            confirmText: 'OK'
                        });
                    }
                });
                return;
            }
            
            messages = [...session.messages];
            currentModel = session.model;
            currentSessionId = session.id;
            currentSystemPrompt = session.systemPrompt || '';
            
            // Update UI
            document.getElementById('chatModel').value = currentModel;
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.innerHTML = '';
            messages.forEach(m => {
                addChatMessage(m.role, m.content);
            });
            
            switchTab('chat');
        }

        function deleteSession(id) {
            showModal({
                type: 'error',
                title: 'Delete Session?',
                message: 'This action cannot be undone.',
                confirmText: 'Delete',
                cancelText: 'Cancel',
                onConfirm: () => {
                    sessions = sessions.filter(s => s.id !== id);
                    localStorage.setItem('offgrid_sessions', JSON.stringify(sessions));
                    
                    if (currentSessionId === id) {
                        currentSessionId = null;
                    }
                    
                    renderSessions();
                }
            });
        }

        function createNewSession() {
            if (messages.length > 0) {
                showModal({
                    type: 'warning',
                    title: 'Start New Session?',
                    message: 'Current chat will be cleared.',
                    confirmText: 'New Session',
                    cancelText: 'Cancel',
                    onConfirm: () => {
                        clearChatSilent();
                        currentSessionId = null;
                        switchTab('chat');
                        showModal({
                            type: 'success',
                            title: 'New Session',
                            message: 'New session started',
                            confirmText: 'OK'
                        });
                    }
                });
                return;
            }
            
            clearChatSilent();
            currentSessionId = null;
            switchTab('chat');
            showModal({
                type: 'success',
                title: 'New Session',
                message: 'New session started',
                confirmText: 'OK'
            });
        }

        function filterSessions() {
            const query = document.getElementById('sessionSearch').value.toLowerCase();
            const sessionCards = document.querySelectorAll('[data-session-id]');
            
            sessionCards.forEach(card => {
                const text = card.textContent.toLowerCase();
                card.style.display = text.includes(query) ? 'block' : 'none';
            });
        }

        function clearChatSilent() {
            messages = [];
            document.getElementById('chatMessages').innerHTML = `
                <div class="text-center text-slate-400 py-20">
                    <p>Start a conversation</p>
                    <p class="text-xs mt-2 text-slate-500">Select a model and type below</p>
                </div>
            `;
            document.getElementById('chatInput').value = '';
            updateChatStats();
        }

        // Stop generation
        function stopGeneration() {
            if (abortController) {
                abortController.abort();
                abortController = null;
            }
            isGenerating = false;
            document.getElementById('sendBtn').disabled = false;
            document.getElementById('stopBtn').classList.add('hidden');
            document.getElementById('statusBadge').className = 'badge badge-success';
            document.getElementById('statusBadge').textContent = 'Ready';
        }

        // Send chat message with streaming
        async function sendChat() {
            console.log('[SEND CHAT] Function called');
            // Prevent rapid-fire requests
            if (isGenerating || pendingRequest) {
                console.log('[SEND CHAT] Request already in progress, ignoring... isGenerating:', isGenerating, 'pendingRequest:', pendingRequest);
                return;
            }
            
            const input = document.getElementById('chatInput');
            const msg = input.value.trim();
            console.log('[SEND CHAT] Message:', msg);
            if (!msg) return;
            
            // Throttle requests to prevent system overload
            const now = Date.now();
            const timeSinceLastRequest = now - lastRequestTime;
            if (timeSinceLastRequest < requestCooldown) {
                console.log(`[SEND CHAT] Throttling: Wait ${requestCooldown - timeSinceLastRequest}ms before next request`);
                return;
            }
            
            lastRequestTime = now;
            pendingRequest = true;
            console.log('[SEND CHAT] Set pendingRequest = true');

            const model = document.getElementById('chatModel').value;
            console.log('[SEND CHAT] Selected model from dropdown:', model);
            console.log('[SEND CHAT] Current model:', currentModel);
            
            if (!model) {
                console.log('[SEND CHAT] No model selected!');
                pendingRequest = false; // Clear flag
                const statusBadge = document.getElementById('statusBadge');
                statusBadge.className = 'badge badge-warning';
                statusBadge.textContent = 'Select Model';
                setTimeout(() => {
                    statusBadge.className = 'badge badge-success';
                    statusBadge.textContent = 'Ready';
                }, 3000);
                return;
            }

            // Update current model (allow switching without blocking message send)
            currentModel = model;
            console.log('[SEND CHAT] Updated currentModel to:', currentModel);

            const sendBtn = document.getElementById('sendBtn');
            const stopBtn = document.getElementById('stopBtn');
            const streamEnabled = document.getElementById('streamToggle').checked;
            const temperature = parseFloat(document.getElementById('temperature').value);
            const maxTokens = parseInt(document.getElementById('maxTokens').value);

            isGenerating = true;
            input.disabled = true;
            sendBtn.disabled = true;
            stopBtn.classList.remove('hidden');

            messages.push({ role: 'user', content: msg });
            addChatMessage('user', msg);
            input.value = '';
            updateChatStats();

            const statusBadge = document.getElementById('statusBadge');
            statusBadge.className = 'text-xs font-medium text-yellow-400';
            
            // Show loading indicator with elapsed time
            let loadingInterval;
            let elapsedSeconds = 0;
            statusBadge.textContent = 'Loading model...';
            loadingInterval = setInterval(() => {
                elapsedSeconds++;
                if (elapsedSeconds < 60) {
                    statusBadge.textContent = `Loading model... ${elapsedSeconds}s`;
                } else {
                    const mins = Math.floor(elapsedSeconds / 60);
                    const secs = elapsedSeconds % 60;
                    statusBadge.textContent = `Loading model... ${mins}m ${secs}s`;
                }
            }, 1000);

            abortController = new AbortController();
            const startTime = Date.now();

            // Prepare messages with system prompt if present
            let apiMessages = [...messages];
            if (currentSystemPrompt && currentSystemPrompt.trim()) {
                // Check if first message is already a system message
                if (apiMessages.length === 0 || apiMessages[0].role !== 'system') {
                    apiMessages = [{ role: 'system', content: currentSystemPrompt }, ...apiMessages];
                }
            }

            try {
                const response = await fetch('/v1/chat/completions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: model,
                        messages: apiMessages,
                        stream: streamEnabled,
                        temperature: temperature,
                        max_tokens: maxTokens
                    }),
                    signal: abortController.signal
                });

                if (!response.ok) {
                    let errorDetails = '';
                    try {
                        const errorData = await response.json();
                        errorDetails = errorData.error?.message || JSON.stringify(errorData);
                    } catch (e) {
                        errorDetails = response.statusText;
                    }
                    throw new Error(`Server error (${response.status}): ${errorDetails}`);
                }

                if (streamEnabled) {
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let assistantMsg = '';
                    let msgDiv = null;

                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n').filter(line => line.trim() !== '');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                if (data === '[DONE]') continue;

                                try {
                                    const json = JSON.parse(data);
                                    const content = json.choices[0]?.delta?.content || '';
                                    if (content) {
                                        // First token received - model is loaded and generating
                                        if (loadingInterval) {
                                            clearInterval(loadingInterval);
                                            loadingInterval = null;
                                            statusBadge.textContent = 'Generating...';
                                        }
                                        
                                        assistantMsg += content;
                                        if (!msgDiv) {
                                            msgDiv = addChatMessage('assistant', '', startTime);
                                        }
                                        // Update streaming content with markdown rendering
                                        const contentDiv = msgDiv.querySelector('.message-content');
                                        contentDiv.innerHTML = marked.parse(assistantMsg);
                                        // Apply syntax highlighting to any new code blocks
                                        contentDiv.querySelectorAll('pre code').forEach((block) => {
                                            hljs.highlightElement(block);
                                        });
                                    }
                                } catch (e) {
                                    // Skip invalid JSON
                                }
                            }
                        }
                    }

                    if (assistantMsg) {
                        messages.push({ role: 'assistant', content: assistantMsg });
                        const elapsed = Date.now() - startTime;
                        msgDiv.querySelector('.time-badge').textContent = `${elapsed}ms`;
                    }
                } else {
                    // Non-streaming mode - model is loaded when we get response
                    if (loadingInterval) {
                        clearInterval(loadingInterval);
                        loadingInterval = null;
                        statusBadge.textContent = 'Generating...';
                    }
                    
                    const result = await response.json();
                    const assistantMsg = result.choices[0]?.message?.content || '';
                    const elapsed = Date.now() - startTime;
                    if (assistantMsg) {
                        messages.push({ role: 'assistant', content: assistantMsg });
                        addChatMessage('assistant', assistantMsg, startTime);
                    }
                }

                updateChatStats();
                if (loadingInterval) {
                    clearInterval(loadingInterval);
                    loadingInterval = null;
                }
                statusBadge.className = 'text-xs font-medium text-green-400';
                statusBadge.textContent = 'Ready';
            } catch (error) {
                if (loadingInterval) {
                    clearInterval(loadingInterval);
                    loadingInterval = null;
                }
                
                if (error.name === 'AbortError') {
                    addChatMessage('assistant', '[Generation stopped by user]', startTime);
                    statusBadge.className = 'text-xs font-medium text-green-400';
                    statusBadge.textContent = 'Ready';
                } else {
                    const errorMsg = error.message || 'Unknown error occurred';
                    console.error('Chat error:', error);
                    
                    // Better error messages for common issues
                    let userMessage = `⚠ Error: ${errorMsg}`;
                    if (errorMsg.includes('503') || errorMsg.includes('Failed to load model')) {
                        userMessage = `⚠ Model is taking longer than expected to load.\n\nThis can happen on slower systems. Please try again in a few moments.`;
                    } else if (errorMsg.includes('500')) {
                        userMessage = `⚠ Server error occurred.\n\nThe model may still be loading. Please wait a moment and try again.`;
                    }
                    
                    addChatMessage('assistant', userMessage, startTime);
                    statusBadge.className = 'text-xs font-medium text-red-400';
                    statusBadge.textContent = 'Error';
                }
            } finally {
                if (loadingInterval) {
                    clearInterval(loadingInterval);
                }
                isGenerating = false;
                pendingRequest = false;
                abortController = null;
                input.disabled = false;
                sendBtn.disabled = false;
                stopBtn.classList.add('hidden');
                input.focus();
            }
        }

        function addChatMessage(role, content, startTime) {
            const container = document.getElementById('chatMessages');
            if (container.querySelector('.text-center')) {
                container.innerHTML = '';
            }

            const div = document.createElement('div');
            div.className = 'message message-' + role;
            
            // Configure marked.js with syntax highlighting
            marked.setOptions({
                highlight: function(code, lang) {
                    if (lang && hljs.getLanguage(lang)) {
                        try {
                            return hljs.highlight(code, { language: lang }).value;
                        } catch (e) {
                            console.error('Highlight error:', e);
                        }
                    }
                    return hljs.highlightAuto(code).value;
                },
                breaks: true,
                gfm: true
            });

            // Parse markdown content
            const formattedContent = marked.parse(content);
            const avatar = role === 'user' ? 'U' : 'AI';
            const timestamp = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            const elapsed = startTime ? `${Date.now() - startTime}ms` : '';
            
            div.innerHTML = `
                <div class="message-wrapper">
                    <div class="message-avatar">${avatar}</div>
                    <div class="message-body">
                        <div class="flex items-center gap-2 mb-2">
                            <span class="text-xs font-medium text-slate-400">${role === 'user' ? 'You' : 'Assistant'}</span>
                            <span class="text-xs text-slate-500">${timestamp}</span>
                            ${elapsed ? `<span class="time-badge text-xs text-cyan-400">${elapsed}</span>` : ''}
                        </div>
                        <div class="text-sm message-content prose prose-invert max-w-none">${formattedContent}</div>
                        ${role === 'assistant' ? `
                        <div class="message-actions mt-3">
                            <button onclick="copyMessage(this)" class="btn btn-secondary btn-sm">Copy</button>
                            <button onclick="regenerateMessage()" class="btn btn-info btn-sm">Regenerate</button>
                        </div>` : ''}
                    </div>
                </div>
            `;
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
            
            // Apply highlighting to all code blocks in this message
            div.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            return div;
        }

        function copyMessage(btn) {
            const content = btn.closest('.message').querySelector('.message-content').textContent;
            navigator.clipboard.writeText(content).then(() => {
                const original = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = original, 2000);
            });
        }

        function regenerateMessage() {
            if (messages.length < 2) return;
            messages.pop(); // Remove last assistant message
            const lastUserMsg = messages[messages.length - 1];
            messages.pop(); // Remove last user message
            document.getElementById('chatInput').value = lastUserMsg.content;
            sendChat();
        }

        // Search models
        async function searchModels() {
            const query = document.getElementById('searchQuery').value.trim();
            if (!query) {
                const results = document.getElementById('searchResults');
                results.innerHTML = '<p class="text-sm text-yellow-400">⚠ Please enter a search query</p>';
                return;
            }

            const results = document.getElementById('searchResults');
            results.innerHTML = '<p class="text-sm text-slate-400">Searching...</p>';

            try {
                const resp = await fetch(`/v1/search?query=${encodeURIComponent(query)}`);
                
                if (!resp.ok) {
                    results.innerHTML = `<p class="text-sm text-red-400">Search failed: HTTP ${resp.status}</p>`;
                    return;
                }
                
                const data = await resp.json();
                
                if (data.error) {
                    const errorMsg = typeof data.error === 'string' ? data.error : JSON.stringify(data.error);
                    results.innerHTML = `<p class="text-sm text-red-400">Search error: ${errorMsg}</p>`;
                    return;
                }
                
                const models = data.results || [];

                if (models.length === 0) {
                    results.innerHTML = '<p class="text-sm text-slate-400">No models found. Try different keywords like "llama", "phi", "mistral".</p>';
                    return;
                }

                results.innerHTML = '';
                models.slice(0, 10).forEach(model => {
                    const div = document.createElement('div');
                    div.className = 'model-item';
                    const downloadCmd = model.download_command || `offgrid download-hf ${model.id}`;
                    const sizeInfo = model.size_gb ? `${model.size_gb} GB` : 'Size unknown';
                    const quantInfo = model.best_quant ? ` · ${model.best_quant}` : '';
                    const escapedCmd = downloadCmd.replace(/'/g, "\\'");
                    
                    div.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div class="flex-1">
                                <div class="font-semibold text-sm text-cyan-400">${model.name || model.id}</div>
                                <div class="text-xs text-slate-400 mt-1">${sizeInfo}${quantInfo} · ${model.downloads || 0} downloads</div>
                            </div>
                            <button onclick="downloadModelWithCommand('${escapedCmd}')" class="btn btn-primary btn-sm">Download</button>
                        </div>
                    `;
                    results.appendChild(div);
                });
            } catch (error) {
                results.innerHTML = `<p class="text-sm text-red-400">Search failed: ${error.message}</p>`;
            }
        }

        // Download model with specific command
        async function downloadModelWithCommand(command) {
            // Switch to terminal tab and execute download command
            switchTab('terminal');
            document.getElementById('terminalInput').value = command;
            runCommand();
        }

        // Download model (fallback for installed models)
        async function downloadModel(modelName) {
            // Switch to terminal tab and execute download command
            switchTab('terminal');
            document.getElementById('terminalInput').value = `offgrid download ${modelName}`;
            runCommand();
        }

        // Load installed models
        async function loadInstalledModels() {
            const container = document.getElementById('installedModels');
            container.innerHTML = '<p class="text-sm text-slate-400">Loading...</p>';

            try {
                const resp = await fetch('/models');
                const data = await resp.json();
                const models = data.data || [];

                if (models.length === 0) {
                    container.innerHTML = '<p class="text-sm text-slate-400">No models installed</p>';
                    return;
                }

                container.innerHTML = '';
                models.forEach(model => {
                    const div = document.createElement('div');
                    div.className = 'model-item';
                    const modelId = (model.id || '').replace(/'/g, "\\'");
                    div.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div class="flex-1">
                                <div class="font-semibold text-sm text-cyan-400">${model.id}</div>
                            </div>
                            <button onclick="removeModel('${modelId}')" class="btn btn-danger btn-sm">Remove</button>
                        </div>
                    `;
                    container.appendChild(div);
                });
            } catch (error) {
                container.innerHTML = '<p class="text-sm text-red-400">Failed to load models</p>';
            }
        }

        // Remove model
        async function removeModel(modelId) {
            const container = document.getElementById('installedModels');
            const confirmDiv = document.createElement('div');
            confirmDiv.className = 'card mb-4';
            confirmDiv.style.background = 'linear-gradient(135deg, rgba(239, 68, 68, 0.2) 0%, rgba(220, 38, 38, 0.2) 100%)';
            confirmDiv.style.border = '1px solid rgba(239, 68, 68, 0.5)';
            confirmDiv.innerHTML = `
                <div class="text-center">
                    <p class="text-red-400 font-semibold mb-3">⚠ Remove Model?</p>
                    <p class="text-sm mb-4">Are you sure you want to remove <span class="font-semibold">${modelId}</span>?</p>
                    <div class="flex gap-2 justify-center">
                        <button onclick="confirmRemoveModel('${modelId.replace(/'/g, "\\'")}')">Remove</button>
                        <button onclick="this.closest('.card').remove()" class="btn btn-secondary btn-sm">Cancel</button>
                    </div>
                </div>
            `;
            container.insertBefore(confirmDiv, container.firstChild);
        }

        // USB Import/Export Functions
        async function importFromUSB() {
            const usbPath = document.getElementById('usbImportPath').value.trim();
            const statusDiv = document.getElementById('usbImportStatus');
            
            if (!usbPath) {
                statusDiv.innerHTML = '<span class="text-yellow-400">⚠ Please enter a USB path</span>';
                return;
            }
            
            statusDiv.innerHTML = '<span class="text-cyan-400">⏳ Importing models from USB...</span>';
            
            try {
                const response = await fetch('/v1/usb/import', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: usbPath })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    const count = data.imported_count || 0;
                    statusDiv.innerHTML = `<span class="text-green-400">✓ Successfully imported ${count} model(s)</span>`;
                    loadInstalledModels(); // Refresh the models list
                } else {
                    const error = data.error || 'Import failed';
                    statusDiv.innerHTML = `<span class="text-red-400">✗ ${error}</span>`;
                }
            } catch (error) {
                statusDiv.innerHTML = `<span class="text-red-400">✗ Error: ${error.message}</span>`;
            }
        }
        
        async function exportToUSB() {
            const usbPath = document.getElementById('usbExportPath').value.trim();
            const statusDiv = document.getElementById('usbExportStatus');
            
            if (!usbPath) {
                statusDiv.innerHTML = '<span class="text-yellow-400">⚠ Please enter a USB path</span>';
                return;
            }
            
            statusDiv.innerHTML = '<span class="text-cyan-400">⏳ Exporting models to USB...</span>';
            
            try {
                const response = await fetch('/v1/usb/export', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: usbPath })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    const count = data.exported_count || 0;
                    const size = data.total_size_gb || 0;
                    statusDiv.innerHTML = `<span class="text-green-400">✓ Exported ${count} model(s) (${size.toFixed(2)} GB)</span>`;
                } else {
                    const error = data.error || 'Export failed';
                    statusDiv.innerHTML = `<span class="text-red-400">✗ ${error}</span>`;
                }
            } catch (error) {
                statusDiv.innerHTML = `<span class="text-red-400">✗ Error: ${error.message}</span>`;
            }
        }

        // Terminal commands
        function clearTerminal() {
            document.getElementById('terminalOutput').innerHTML = `
                <div class="terminal-line terminal-success">OffGrid Terminal v0.1.2</div>
                <div class="terminal-line">Connected to real offgrid binary</div>
                <div class="terminal-line">Type 'help' for available commands or 'offgrid --help' for all options</div>
            `;
        }

        function killCommand() {
            if (currentTerminalAbort) {
                currentTerminalAbort.abort();
                currentTerminalAbort = null;
            }
            terminalRunning = false;
            const inputLine = document.getElementById('terminalInputLine');
            inputLine.classList.remove('terminal-running');
            document.getElementById('terminalInput').disabled = false;
            document.getElementById('killBtn').classList.add('hidden');
            addTerminalOutput('Command killed', 'error');
        }

        function runQuickCommand(cmd) {
            document.getElementById('terminalInput').value = cmd;
            runCommand();
        }

        function runCommand() {
            const input = document.getElementById('terminalInput');
            const cmd = input.value.trim();
            if (!cmd) return;

            // Handle chat mode
            if (terminalChatMode) {
                // Prevent sending while already processing
                if (terminalRunning || pendingRequest) {
                    console.log('Terminal chat request already in progress');
                    return; // Silently ignore, don't show error
                }
                
                // Throttle terminal chat requests
                const now = Date.now();
                if (now - lastRequestTime < requestCooldown) {
                    console.log('Throttling terminal chat request');
                    return;
                }
                lastRequestTime = now;
                
                if (cmd === 'exit' || cmd === 'quit') {
                    addTerminalOutput(cmd, 'prompt');
                    addTerminalOutput('Exiting chat mode...', 'success');
                    terminalChatMode = false;
                    terminalChatModel = '';
                    terminalChatHistory = [];
                    input.value = '';
                    return;
                } else if (cmd === 'clear') {
                    clearTerminal();
                    addTerminalOutput(`Chat mode with ${terminalChatModel}`, 'success');
                    addTerminalOutput('Type your message or "exit" to quit');
                    addTerminalOutput('> ', 'success');
                    input.value = '';
                    return;
                }
                
                // Send message in chat mode - disable input while processing
                addTerminalOutput(cmd, 'prompt');
                input.value = '';
                input.disabled = true;
                terminalRunning = true;
                pendingRequest = true;
                sendTerminalChat(cmd);
                return;
            }

            if (terminalRunning) {
                addTerminalOutput('Command already running. Use Kill button to stop it.', 'error');
                return;
            }
            
            // Add to history
            if (commandHistory[0] !== cmd) {
                commandHistory.unshift(cmd);
                if (commandHistory.length > 50) commandHistory.pop();
            }
            historyIndex = -1;

            addTerminalOutput(cmd, 'prompt');
            input.value = '';

            const parts = cmd.split(' ').filter(p => p);
            const command = parts[0];
            const args = parts.slice(1);

            // Set running state
            terminalRunning = true;
            const inputLine = document.getElementById('terminalInputLine');
            inputLine.classList.add('terminal-running');
            input.disabled = true;
            document.getElementById('killBtn').classList.remove('hidden');

            switch (command) {
                case 'offgrid':
                    handleOffgridCommand(args);
                    break;
                case 'clear':
                    clearTerminal();
                    resetTerminalState();
                    break;
                case 'help':
                    showHelp();
                    resetTerminalState();
                    break;
                case 'history':
                    showHistory();
                    resetTerminalState();
                    break;
                default:
                    addTerminalOutput(`Unknown command: ${command}. Type 'help' for available commands`, 'error');
                    resetTerminalState();
            }
        }

        function resetTerminalState() {
            terminalRunning = false;
            const inputLine = document.getElementById('terminalInputLine');
            inputLine.classList.remove('terminal-running');
            document.getElementById('terminalInput').disabled = false;
            document.getElementById('killBtn').classList.add('hidden');
        }

        function showHelp() {
            const help = [
                'Available Commands:',
                '',
                'Terminal Commands:',
                '  clear      - Clear terminal screen',
                '  history    - Show command history',
                '  help       - Show this help',
                '',
                'OffGrid Commands (runs real offgrid binary):',
                '  offgrid list                - List installed models',
                '  offgrid search <query>      - Search for models to download',
                '  offgrid download <model>    - Download a model',
                '  offgrid remove <model>      - Remove an installed model',
                '  offgrid run <model>         - Load model and switch to Chat tab',
                '  offgrid info                - Show system information',
                '  offgrid doctor              - Run diagnostics',
                '  offgrid --help              - Show all offgrid commands',
                '  offgrid --version           - Show version',
                '',
                'Tips:',
                '  - Use arrow keys (↑/↓) to navigate history',
                '  - Use Tab for command autocomplete',
                '  - Press Ctrl+C or click Kill to stop command',
                '  - For interactive chat, use "offgrid run <model>" or Chat tab'
            ];
            help.forEach(line => addTerminalOutput(line));
        }

        function showHistory() {
            if (commandHistory.length === 0) {
                addTerminalOutput('No command history');
                return;
            }
            addTerminalOutput('Command History:');
            commandHistory.slice(0, 10).forEach((cmd, i) => {
                addTerminalOutput(`  ${i + 1}. ${cmd}`);
            });
        }

        async function handleOffgridCommand(args) {
            if (args.length === 0) {
                addTerminalOutput('Usage: offgrid <command>', 'error');
                addTerminalOutput('Try: offgrid help');
                resetTerminalState();
                return;
            }

            // Create abort controller for this command
            currentTerminalAbort = new AbortController();
            
            try {
                // Execute real offgrid command via backend
                const resp = await fetch('/v1/terminal/exec', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        command: 'offgrid',
                        args: args
                    }),
                    signal: currentTerminalAbort?.signal
                });

                if (!resp.ok) {
                    addTerminalOutput(`Command failed: HTTP ${resp.status}`, 'error');
                    return;
                }

                const data = await resp.json();
                
                if (data.error) {
                    addTerminalOutput(`Error: ${data.error}`, 'error');
                    return;
                }

                // Display the actual command output
                const output = data.output || '';
                
                // Special handling for 'run' command - enable terminal chat mode
                const subcmd = args[0];
                if (subcmd === 'run' && args.length > 1) {
                    const modelName = args.slice(1).join(' ');
                    
                    // Display output with ANSI parsing
                    if (output) {
                        const lines = output.split('\n');
                        lines.forEach(line => {
                            if (line.trim()) {
                                addTerminalOutput(line, 'raw');
                            }
                        });
                    }
                    
                    // Enable chat mode
                    terminalChatMode = true;
                    terminalChatModel = modelName;
                    terminalChatHistory = [];
                    addTerminalOutput('', 'normal');
                    addTerminalOutput('Chat mode enabled. Type your messages below.', 'success');
                    addTerminalOutput('Commands: "exit" to quit, "clear" to reset screen', 'success');
                    addTerminalOutput('> ', 'success');
                    
                    resetTerminalState();
                    currentTerminalAbort = null;
                    return;
                }
                
                if (output) {
                    // Output exactly as received from server - no modifications
                    const lines = output.split('\n');
                    lines.forEach(line => {
                        addTerminalOutput(line, 'raw');
                    });
                }

                if (data.exitCode !== 0 && !output) {
                    addTerminalOutput(`Command exited with code ${data.exitCode}`, 'error');
                }

                // Refresh UI after certain commands
                if (['download', 'remove', 'delete'].includes(subcmd)) {
                    setTimeout(() => {
                        loadInstalledModels();
                        loadChatModels();
                    }, 1000);
                }

            } catch (error) {
                if (error.name === 'AbortError') {
                    addTerminalOutput('Command aborted', 'error');
                } else {
                    addTerminalOutput(`Error: ${error.message}`, 'error');
                }
            } finally {
                resetTerminalState();
                currentTerminalAbort = null;
            }
        }



        // Send chat message in terminal mode
        async function sendTerminalChat(message) {
            try {
                terminalChatHistory.push({ role: 'user', content: message });
                
                const resp = await fetch('/v1/chat/completions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: terminalChatModel,
                        messages: terminalChatHistory,
                        stream: false,
                        temperature: 0.7,
                        max_tokens: 2000
                    })
                });

                if (!resp.ok) {
                    let errorMsg = `HTTP ${resp.status}`;
                    try {
                        const errorData = await resp.json();
                        errorMsg = errorData.error?.message || errorMsg;
                    } catch (e) {
                        // Ignore JSON parse errors
                    }
                    addTerminalOutput(`Error: ${errorMsg}`, 'error');
                    terminalChatHistory.pop(); // Remove failed message
                    return;
                }

                const data = await resp.json();
                const assistantMsg = data.choices?.[0]?.message?.content || 'No response';
                const actualModel = data.model || terminalChatModel;
                
                terminalChatHistory.push({ role: 'assistant', content: assistantMsg });
                
                // Show model info if different from expected
                if (actualModel !== terminalChatModel) {
                    addTerminalOutput(`[Using model: ${actualModel}]`, 'error');
                }
                
                addTerminalOutput('', 'normal');
                addTerminalOutput(assistantMsg, 'success');
                addTerminalOutput('', 'normal');
                addTerminalOutput('> ', 'success');
                
            } catch (error) {
                addTerminalOutput(`Error: ${error.message}`, 'error');
                if (terminalChatHistory.length > 0 && terminalChatHistory[terminalChatHistory.length - 1].role === 'user') {
                    terminalChatHistory.pop(); // Remove failed message
                }
            } finally {
                // Re-enable input after processing
                terminalRunning = false;
                pendingRequest = false;
                document.getElementById('terminalInput').disabled = false;
                document.getElementById('terminalInput').focus();
            }
        }

        // Strip ANSI escape codes
        function stripAnsi(text) {
            // Strip all ANSI escape codes (colors, cursor movement, etc.)
            return text.replace(/\x1b\[[0-9;]*[a-zA-Z]/g, '');
        }

        // Parse ANSI color codes and convert to HTML with CSS classes
        function parseAnsiColors(text) {
            // Map of ANSI codes to CSS classes
            const colorMap = {
                // Basic 16 colors
                '30': 'ansi-black',
                '31': 'ansi-red',
                '32': 'ansi-green',
                '33': 'ansi-yellow',
                '34': 'ansi-blue',
                '35': 'ansi-magenta',
                '36': 'ansi-cyan',
                '37': 'ansi-white',
                '90': 'ansi-gray',
                
                // 256-color palette (extended colors used in offgrid)
                '38;5;45': 'ansi-cyan',      // Bright cyan - headers
                '38;5;78': 'ansi-green',     // Bright green
                '38;5;141': 'ansi-purple',   // Purple - command names
                '38;5;196': 'ansi-red',      // Bright red - errors
                '38;5;226': 'ansi-yellow',   // Bright yellow
                '38;5;240': 'ansi-gray',     // Gray - dim text
                
                // Text styles
                '1': 'ansi-bold',            // Bold
                '2': 'ansi-dim',             // Dim/faint
                '22': 'ansi-normal',         // Normal intensity
            };
            
            let result = '';
            let currentClasses = new Set();
            let lastIndex = 0;
            
            // Match ANSI escape sequences: ESC [ <codes> m
            const ansiRegex = /\x1b\[([0-9;]+)m/g;
            let match;
            
            while ((match = ansiRegex.exec(text)) !== null) {
                // Add text before this escape code (escape HTML entities but preserve UTF-8)
                const textChunk = text.substring(lastIndex, match.index);
                result += textChunk
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                lastIndex = match.index + match[0].length;
                
                const codes = match[1].split(';');
                
                for (const code of codes) {
                    if (code === '0') {
                        // Reset - close all open spans and clear classes
                        if (currentClasses.size > 0) {
                            result += '</span>';
                            currentClasses.clear();
                        }
                    } else {
                        const cssClass = colorMap[code] || colorMap[codes.join(';')];
                        if (cssClass) {
                            // Close previous span if exists
                            if (currentClasses.size > 0) {
                                result += '</span>';
                            }
                            // Add new class and open new span
                            currentClasses.add(cssClass);
                            result += `<span class="${Array.from(currentClasses).join(' ')}">`;
                        }
                    }
                }
            }
            
            // Add remaining text (escape HTML but preserve UTF-8)
            const remainingText = text.substring(lastIndex);
            result += remainingText
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            
            // Close any remaining open spans
            if (currentClasses.size > 0) {
                result += '</span>';
            }
            
            return result;
        }

        function addTerminalOutput(text, type = 'normal') {
            const terminal = document.getElementById('terminalOutput');
            const line = document.createElement('div');
            line.className = 'terminal-line';
            
            if (type === 'prompt') {
                line.className = 'terminal-line terminal-prompt';
                line.textContent = '$ ' + text;
            } else if (type === 'error') {
                line.className = 'terminal-line terminal-error';
                line.textContent = text;
            } else if (type === 'success') {
                line.className = 'terminal-line terminal-success';
                line.textContent = text;
            } else if (type === 'raw') {
                // Raw output - parse ANSI colors and render with proper styling
                line.innerHTML = parseAnsiColors(text);
            } else {
                // Normal output - preserve whitespace
                line.textContent = text;
            }
            
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
        }

        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            loadChatModels();
        });
    </script>
</body>
</html>
